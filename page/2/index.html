<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="hongru">





  <link rel="alternate" href="/atom.xml" title="Water的博客" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
<meta property="og:type" content="website">
<meta property="og:title" content="Water的博客">
<meta property="og:url" content="https://hongruqi.github.io/page/2/index.html">
<meta property="og:site_name" content="Water的博客">
<meta property="og:description" content="不积跬步，无以致千里；不积小流，无以成江海。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Water的博客">
<meta name="twitter:description" content="不积跬步，无以致千里；不积小流，无以成江海。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://hongruqi.github.io/page/2/">





  <title>Water的博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Water的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">2019，行者无疆</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/21/UIWindow 整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Water的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/21/UIWindow 整理/" itemprop="url">UIWindow 整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-21T00:00:00+08:00">
                2016-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UIWindow-整理"><a href="#UIWindow-整理" class="headerlink" title="UIWindow 整理"></a>UIWindow 整理</h1><p>##<strong>UIWindow概念</strong><br>UIWindw定义了一个负责管理，协调一个App的View是如何显示在设备屏幕上的窗口类，除非一个App可以显示在一个外部的设备屏幕上，那么一个App只拥有一个窗口。UIWindow本身没有标题栏，关闭操作栏等任何的装饰物，用户不会看见，移动或者是关闭它，这跟Mac OS上的window有很大的差别。      UIWindow的两大主要功能是提供了一块给View的显示区域，并且负责分发各种事件给View，比如传递触摸事件给各项View或者其它对象。而改变App的显示内容，可以改变UIWindow的rootView，而不需要去创建一个新的UIWindow。同时，它还负责与ViewController协同去处理设备旋转时的情况。      讲到Window还必须要提的两个概念是UIWindowLevel以及KeyWindow。UIWindowLevel是一个CGFloat值，现在UIKit定义了三种Level:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelNormal</span>; </span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelAlert</span>;</span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelStatusBar</span></span><br></pre></td></tr></table></figure></p>
<p>UIWindowLevel为2D的iOS世界引入了Z轴的概念，它相当于以屏幕为原地，以使用者为正方向的一根轴。值越小代表离使用者越远，越大代表越靠近使用者。高Level的Window会盖住低Level的window，若是两者Level一样则根据添加顺序来决定，这类似于我们添加子View(UIWindow本来也就是UIView的子类)。而上面三个值分别是0.0,2000.0,1000.0，而大部分在App上使用的都是UIWindowLevelNormal，这也是每个Window被创建出来时的默认值。    我们在创建一个新的window的时候，要让它显示出来必须要调用makeKeyAndVisible方法，让window显示出来，并让它成为一个KeyWindow。KeyWindow是UIApplication的一个开放属性，它是当前App的主window，用来接收键盘输入以及非触摸事件(触摸事件是传递给触摸事件发生的window，不一定是keyWindow)，或者是跟坐标值无关的事件都会被传递给keyWindow。并且在同一时刻，只有一个window会成为keyWindow。但是需要注意一件事情，成为keywindow与windowLevel无关，并不是windowLevel最高的window会成为keywindow.</p>
<p>##<strong>UIWindow在App启动时扮演的角色</strong><br><strong>(1)The Main Function</strong><br>  所有以C语言为基础的程序的入口都是main函数，iOS App也不例外。以下程序就是iOS App的main函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span> </span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])&#123; </span><br><span class="line">      <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>])); </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>唯一不同的是你不用去写main函数，这是Xcode自动创建的。这段代码也很简单，它唯一做的工作就是把控制权移交给UIKit framework，根据第三个参数principalClassName创建一个UIApplication对象，根据第四个参数创建一个AppDelegate对象。 </p>
<p><strong>(2)UIApplication</strong><br>     UIApplication是一个App的核心，它主要的职能是负责方便系统和App的交互，管理Event Loop进行各项事件的处理，以及向自己的Delegate，即AppDelegate进行一些关键事件的传递。一个App只有一个UIApplication单例对象，可以通过[UIApplication sharedApplication]来获得单例。它还能做一些应用级别的事，比如设置桌面上App图标右上角的红点数字，或者是使用openURL直接拨电话，发短信等。在此不做延伸。<br><img src="http://upload-images.jianshu.io/upload_images/901318-74734c584f6565e3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpeg"></p>
<p><strong> (3)UIWindow</strong></p>
<p>UIWindow是iOS启动之后，被创建的第一个视图控件。它有可能是通过Interface Builder被创建出来的，也有可能是我们在AppDelegate中自定义创建出来的。当它被创建，添加了rootView之后，一个App的界面最终被展示在用户面前。而如果是自定义创建window时，我们通常会使用window.rootViewController来为它添加rootView，值得注意的是，这句代码仅仅是给UIWindow添加了rootViewController的view，或者说这是一种更加便利的方式来为UIWindow添加rootView,而这个rootViewController属性并不是用来让controller与UIWindow之间进行通信的。除此之外，UIWindow还负责与UIApplication一起负责传递Event给View以及ViewController。</p>
<p>##拾遗<br><strong>(1)UITextEffectsWindow</strong><br> 这是iOS8引入的一个新window，是键盘所在的window。它的windowLevel是10，高于UIWindowLevelNormal。<br><strong>(2)UIRemoteKeyboardWindow</strong><br>iOS9之后,新增了一个类型为 UIRemoteKeyboardWindow 的窗口用来显示键盘按钮。目前对这个研究还不是很多，以后有了新发现再与大家分享。    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/20/iOS 性能提升总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Water的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/20/iOS 性能提升总结/" itemprop="url">iOS 性能提升总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-20T00:00:00+08:00">
                2016-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-性能提升总结"><a href="#iOS-性能提升总结" class="headerlink" title="iOS 性能提升总结"></a>iOS 性能提升总结</h1><p>##使用复用机制</p>
<p>在我们使用 UITableView 和 UICollectionView 时我们通常会遇到「复用 Cell」这个提法，所谓「复用 Cell」就是指当需要展示的数据条目较多时，只创建较少数量的 Cell 对象（一般是屏幕可显示的 Cell 数再加一）并通过复用它们的方式来展示数据的机制。这种机制不会为每一条数据都创建一个 Cell，所以可以节省内存，提升程序的效率和交互流畅性。<br>从 iOS 6 以后，我们在 UITableView 和 UICollectionView 中不光可以复用 Cell，还可以复用各个 Section 的 Header 和 Footer。<br>在 UITableView 做复用的时候，会用到的 API：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复用 Cell：</span></span><br><span class="line">- [<span class="built_in">UITableView</span> dequeueReusableCellWithIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> registerNib:forCellReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> registerClass:forCellReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> dequeueReusableCellWithIdentifier:forIndexPath:];<span class="comment">// 复用 Section 的 Header/Footer：</span></span><br><span class="line">- [<span class="built_in">UITableView</span> registerNib:forHeaderFooterViewReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> registerClass:forHeaderFooterViewReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> dequeueReusableHeaderFooterViewWithIdentifier:];</span><br></pre></td></tr></table></figure></p>
<p>复用机制是一个很好的机制，但是不正确的使用却会给我们的程序带来很多问题。下面拿 UITableView 复用 Cell 来举例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier =  <span class="string">@"UITableViewCell"</span>; </span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>;</span><br><span class="line">    cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123; </span><br><span class="line">         cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleSubtitle</span> reuseIdentifier:CellIdentifier]; </span><br><span class="line"><span class="comment">// 偶数行 Cell 的 textLabel 的文字颜色为红色。</span></span><br><span class="line">        <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">               [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> redColor]]; </span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cell.textLabel.text = <span class="string">@"Title"</span>;</span><br><span class="line"> <span class="comment">// 偶数行 Cell 的 detailTextLabel 显示 Detail 文字。</span></span><br><span class="line">      <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">       cell.detailTextLabel.text = <span class="string">@"Detail"</span>; </span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们本来是希望只有偶数行的 textLabel 的文字颜色为红色，并且显示 Detail 文字，但是当你滑动 TableView 的时候发现不对了，有些奇数行的 textLabel 的文字颜色为红色，而且还显示了 Detail 文字，很奇怪。其实造成这个问题的原因就是「复用」，当一个 Cell 被拿来复用时，它所有被设置的属性（包括样式和内容）都会被拿来复用，如果刚好某一个的 Cell 你没有显式地设置它的属性，那么它这些属性就直接复用别的 Cell 的了。就如上面的代码中，我们并没有显式地设置奇数行的 Cell 的 textLabel 的文字颜色以及 detailTextLabel 的文字，那么它就有可能复用别的 Cell 的这些属性了。此外，还有个问题，对偶数行 Cell 的 textLabel 的文字颜色的设置放在了初始一个 Cell 的 if 代码块里，这样在复用的时候，逻辑走不到这里去，那么也会出现复用问题。所以，上面的代码需要改成这样：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier = <span class="string">@"UITableViewCell"</span>; </span><br><span class="line">   <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>; </span><br><span class="line">   cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; </span><br><span class="line">   <span class="keyword">if</span> (!cell) &#123; </span><br><span class="line">       cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleSubtitle</span> reuseIdentifier:CellIdentifier];</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   cell.textLabel.text = <span class="string">@"Title"</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">       [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> redColor]]; </span><br><span class="line">       cell.detailTextLabel.text = <span class="string">@"Detail"</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">       [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> blackColor]];</span><br><span class="line">       cell.detailTextLabel.text = <span class="literal">nil</span>; </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总之在复用的时候需要记住：<br><strong>设置 Cell 的存在差异性的那些属性（包括样式和内容）时，有了 if 最好就要有 else，要显式的覆盖所有可能性。</strong><br><strong>设置 Cell 的存在差异性的那些属性时，代码要放在初始化代码块的外部。</strong></p>
<p>上面的代码中，我们展示了 - [UITableView dequeueReusableCellWithIdentifier:];<br> 的用法。下面看看另几个 API 的用法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITableView</span> *myTableView;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123; </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">        <span class="comment">// Setup table view. </span></span><br><span class="line">    <span class="keyword">self</span>.myTableView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.myTableView.dataSource = <span class="keyword">self</span>;</span><br><span class="line">   [<span class="keyword">self</span>.myTableView registerClass:[MyTableViewCell <span class="keyword">class</span>] forCellReuseIdentifier:<span class="string">@"MyTableViewCell"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier = <span class="string">@"MyTableViewCell"</span>; </span><br><span class="line">     <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>; </span><br><span class="line">     cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];</span><br><span class="line">     cell.textLabel.text = <span class="string">@"Title"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">           [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> redColor]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> blackColor]];</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，- [UITableView dequeueReusableCellWithIdentifier:forIndexPath:];<br> 必须搭配- [UITableView registerClass:forCellReuseIdentifier:];或者- [UITableView registerNib:forCellReuseIdentifier:];<br> 使用。当有可重用的 Cell 时，前者直接拿来复用，并调用 - [UITableViewCell prepareForReuse]<br> 方法；当没有时，前者会调用 Identifier 对应的那个注册的 UITableViewCell 类的 - [UITableViewCell initWithStyle:reuseIdentifier:]方法来初始化一个，这里省去了你自己初始化的步骤。当你自定义了一个 UITableViewCell 的子类时，你可以这样来用。</p>
<p>##优化 UITableView<br>UITableView 是我们最常用来展示数据的控件之一，并且通常需要 UITableView 在承载较多内容的同时保证交互的流畅性，对 UITableView 的性能优化是我们开发应用程序必备的技巧之一。<br>在前文「使用复用机制」一节，已经提到了 UITableView 的复用机制。现在就来看看 UITableView 在复用时最主要的两个回调方法：- [UITableView tableView:cellForRowAtIndexPath:]和- [UITableView tableView:heightForRowAtIndexPath:]。UITableView 是继承自 UIScrollView，所以在渲染的过程中它会先确定它的 contentSize 及每个 Cell 的位置，然后才会把复用的 Cell 放置到对应的位置。比如现在一共有 50 个 Cell，当前屏幕上显示 5 个。那么在第一次创建或 reloadData 的时候， UITableView 会先调用 50 次- [UITableView tableView:heightForRowAtIndexPath:]<br> 确定 contentSize 及每个 Cell 的位置，然后再调用 5 次 - [UITableView tableView:cellForRowAtIndexPath:]<br> 来渲染当前屏幕的 Cell。在滑动屏幕的时候，每当一个 Cell 进入屏幕时，都需要调用一次 - [UITableView tableView:cellForRowAtIndexPath:]和- [UITableView tableView:heightForRowAtIndexPath:]方法。<br>了解了 UITableView 的复用机制以及相关回调方法的调用次序，这里就对 UITableView 的性能优化方案做一个总结：</p>
<ul>
<li>通过正确的设置 reuseIdentifier 来重用 Cell。</li>
<li>尽量减少不必要的透明 View。</li>
<li>尽量避免渐变效果、图片拉伸和离屏渲染。</li>
<li>当不同的行的高度不一样时，尽量缓存它们的高度值。</li>
<li>如果 Cell 展示的内容来自网络，确保用异步加载的方式来获取数据，并且缓存服务器的 response。</li>
<li>使用 shadowPath 来设置阴影效果。</li>
<li>尽量减少 subview 的数量，对于 subview 较多并且样式多变的 Cell，可以考虑用异步绘制或重写 drawRect。</li>
<li>尽量优化 - [UITableView tableView:cellForRowAtIndexPath:]</li>
<li>方法中的处理逻辑，如果确实要做一些处理，可以考虑做一次，缓存结果。</li>
<li>选择合适的数据结构来承载数据，不同的数据结构对不同操作的开销是存在差异的。</li>
<li>对于 rowHeight、sectionFooterHeight、sectionHeaderHeight 尽量使用常量。</li>
</ul>
<p>##尽可能设置 View 为不透明<br>UIView 有一个 opaque属性，在你不需要透明效果时，你应该尽量设置它为 YES 可以提高绘图过程的效率。<br>在一个静态的视图里，这点可能影响不大，但是当在一个可以滚动的 Scroll View 中或是一个复杂的动画中，透明的效果可能会对程序的性能有较大的影响。</p>
<p>##避免臃肿的 XIB 文件<br>如果你压根不用 XIB，那就不需要看了。</p>
<p>在你需要重用某些自定义 View 或者因为历史兼容原因用到 XIB 的时候，你需要注意：当你加载一个 XIB 时，它的所有内容都会被加载，如果这个 XIB 里面有个 View 你不会马上就用到，你其实就是在浪费宝贵的内存。而加载 StoryBoard 时并不会把所有的 ViewController 都加载，只会按需加载。</p>
<p>##不要阻塞主线程<br>基本上 UIKit 会把它所有的工作都放在主线程执行，比如：绘制界面、管理手势、响应输入等等。当你把所有代码逻辑都放在主线程时，有可能因为耗时太长卡住主线程造成程序无法响应、流畅性太差等问题。造成这种问题的大多数场景是因为你的程序把 I/O 操作放在了主线程，比如从硬盘或者网络读写数据等等。</p>
<p>你可以通过异步的方式来进行这些操作，把他们放在别的线程中处理。比如处理网络请求时，你可以使用 NSURLConnection 的异步调用 API：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span> *)request queue:(<span class="built_in">NSOperationQueue</span> *)queue completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>*, <span class="built_in">NSData</span>*, <span class="built_in">NSError</span>*))handler;</span><br></pre></td></tr></table></figure></p>
<p>或者使用第三方的类库，比如 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>。<br>当你做一些耗时比较长的操作时，你可以使用 GCD、NSOperation、NSOperationQueue。比如 GCD 的常见使用方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">     <span class="comment">// switch to another thread and perform your expensive operation</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; </span><br><span class="line">            <span class="comment">// switch back to the main thread to update your UI</span></span><br><span class="line">     &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>关于 GCD 更多的知识，你可以看看这篇文章：<a href="http://www.atatech.org/articles/41244" target="_blank" rel="noopener">GCD</a>。</p>
<p>###图片尺寸匹配 UIImageView</p>
<p>当你从 App bundle 中加载图片到 UIImageView 中显示时，最好确保图片的尺寸能够和 UIImageView 的尺寸相匹配（当然，需要考虑 @2x @3x 的情况），否则会使得 UIImageView 在显示图片时需要做拉伸，这样会影响性能，尤其是在一个 UIScrollView 的容器里。</p>
<p>有时候，你的图片是从网络加载的，这时候你并不能控制图片的尺寸，不过你可以在图片下载下来后去手动 scale 一下它，当然，最好是在一个后台线程做这件事，然后在 UIImageView 中使用 resize 后的图片。<br>关于这一点SDWebImage进行了优化，如果你使用SDWebImage，它会帮你进行Scale优化。</p>
<p>##选择合适的容器<br>我们经常需要用到容器来转载多个对象，我们通常用到的包括：NSArray、NSDictionary、NSSet，它们的特性如下：</p>
<ul>
<li>Array：数组。有序的，通过 index 查找很快，通过 value 查找很慢，插入和删除较慢。</li>
<li>Dictionary：字典。存储键值对，通过键查找很快。</li>
<li>Set：集合。无序的，通过 value 查找很快，插入和删除较快。</li>
</ul>
<p>根据以上特性，在编程中需要选择适合的容器。更多内容请看：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Collections/Collections.html" target="_blank" rel="noopener">Collections Programming Topics</a></p>
<p>##启用 GZIP 数据压缩<br>现在越来越多的应用需要跟服务器进行数据交互，当交互的数据量较大时，网络传输的时延就会较长，通过启动数据压缩功能，尤其是对于文本信息，可以降低网络传输的数据量，从而减短网络交互的时间。</p>
<p>一个好消息是当你使用 NSURLConnection 或者基于此的一些网络交互类库（比如 AFNetworking）时 iOS 已经默认支持 GZIP 压缩。并且，很多服务器已经支持发送压缩数据。</p>
<p>通过在服务器和客户端程序中启用对网络交互数据的压缩，是一条提高应用程序性能的途径。</p>
<p>##View 的复用和懒加载机制<br>当你的程序中需要展示很多的 View 的时候，这就意味着需要更多的 CPU 处理时间和内存空间，这个情况对程序性能的影响在你使用 UIScrollView 来装载和呈现界面时会变得尤为显著。</p>
<p>处理这种情况的一种方案就是向 UITableView 和 UICollectionView 学习，不要一次性把所有的 subviews 都创建出来，而是在你需要他们的时候创建，并且用复用机制去复用他们。这样减少了内存分配的开销，节省了内存空间。</p>
<p>「懒加载机制」就是把创建对象的时机延后到不得不需要它们的时候。这个机制常常用在对一个类的属性的初始化上，比如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableView</span> *)myTableView &#123; </span><br><span class="line">    <span class="keyword">if</span> (!_myTableView) &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> viewBounds = <span class="keyword">self</span>.view.bounds;</span><br><span class="line">    _myTableView = [[<span class="built_in">UITableView</span> alloc] initWithFrame:viewBounds style:<span class="built_in">UITableViewStylePlain</span>];</span><br><span class="line">    _myTableView.showsHorizontalScrollIndicator = <span class="literal">NO</span>; </span><br><span class="line">    _myTableView.showsVerticalScrollIndicator = <span class="literal">NO</span>; </span><br><span class="line">    _myTableView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [_myTableView setSeparatorStyle:<span class="built_in">UITableViewCellSeparatorStyleNone</span>];</span><br><span class="line">    _myTableView.dataSource = <span class="keyword">self</span>; </span><br><span class="line">    _myTableView.delegate = <span class="keyword">self</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> _myTableView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有当我们第一次用到 self.myTableView 的时候采取初始化和创建它。<br>但是，存在这样一种场景：你点击一个按钮的时候，你需要显示一个 View，这时候你有两种实现方案：</p>
<ol>
<li>在当前界面第一次加载的时候就创建出这个 View，只是把它隐藏起来，当你需要它的时候，只用显示它就行了。</li>
<li>使用「懒加载机制」，在你需要这个 View 的时候才创建它，并展示它。<br>这两种方案都各有利弊。采用方案一，你在不需要这个 View 的时候显然白白地占用了更多的内存，但是当你点击按钮展示它的时候，你的程序能响应地相对较快，因为你只需要改变它的 hidden 属性。采用方案二，那么你得到的效果相反，你更准确的使用了内存，但是如果对这个 View 的初始化和创建比较耗时，那么响应性相对就没那么好了。</li>
</ol>
<p>所以当你考虑使用何种方案时，你需要根据现实的情况来参考，去权衡到底哪个因素才是影响性能的瓶颈，然后再做出选择。</p>
<p>##缓存</p>
<p>在开发我们的程序时，一个很重要的经验法则就是：对那些更新频度低，访问频度高的内容做缓存。<br>有哪些东西使我们可以缓存的呢？比如下面这些：</p>
<ul>
<li>服务器的响应信息（response）。</li>
<li>图片。</li>
<li>计算值。比如：UITableView 的 row heights。<br>NSURLConnection 可以根据 HTTP 头部的设置来决定把资源内容缓存在磁盘或者内存，你甚至可以设置让它只加载缓存里的内容：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMutableURLRequest</span> *)imageRequestWithURL:(<span class="built_in">NSURL</span> *)url &#123; </span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url]; </span><br><span class="line">    request.cachePolicy = <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>; </span><br><span class="line">    <span class="comment">// this will make sure the request always returns the cached image </span></span><br><span class="line">    request.HTTPShouldHandleCookies = <span class="literal">NO</span>;</span><br><span class="line">    request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">    [request addValue:<span class="string">@"image/*"</span> forHTTPHeaderField:<span class="string">@"Accept"</span>]; </span><br><span class="line">    ]<span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 HTTP 缓存的更多内容可以关注 NSURLCache。关于缓存其他非 HTTP 请求的内容，可以关注 NSCache。对于图片缓存，可以关注一个第三方库 <a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>。</p>
<p>##关于图形绘制<br>当我们为一个 UIButton 设置背景图片时，对于这个背景图片的处理，我们有很多种方案，你可以使用全尺寸图片直接设置，还可以用 resizable images，或者使用 CALayer、CoreGraphics 甚至 OpenGL 来绘制。<br>当然，不同的方案的编码复杂度不一样，性能也不一样。关于图形绘制的不同方案的性能问题，可以看看：<a href="https://robots.thoughtbot.com/designing-for-ios-graphics-performance" target="_blank" rel="noopener">Designing for iOS: Graphics Performance</a><br>简而言之，使用 pre-rendered 的图片会更快，因为这样就不需要在程序中去创建一个图像，并在上面绘制各种形状了（Offscreen Rendering，离屏渲染）。但是缺点是你必须把这些图片资源打包到代码包，从而需要增加程序包的体积。这就是为什么 resizable images 是一个很棒的选择：不需要全尺寸图，让 iOS 为你绘制图片中那些可以拉伸的部分，从而减小了图片体积；并且你不需要为不同大小的控件准备不同尺寸的图片。比如两个按钮的大小不一样，但是他们的背景图样式是一样的，你只需要准备一个对应样式的 resizable image，然后在设置这两个按钮的背景图的时候分别做拉伸就可以了。<br>但是一味的使用使用预置的图片也会有一些缺点，比如你做一些简单的动画的时候各个帧都用图片叠加，这样就可能要使用大量图片。<br>总之，你需要去在图形绘制的性能和应用程序包的大小上做权衡，找到最合适的性能优化方案。</p>
<p>##处理 Memory Warnings</p>
<p>关于内存警告，苹果的官方文档是这样说的：</p>
<blockquote>
<p>If your app receives this warning, it must free up as much memory as possible. The best way to do this is to remove strong references to caches, image objects, and other data objects that can be recreated later.</p>
</blockquote>
<p>我们可以通过这些方式来获得内存警告：<br>在 AppDelegate 中实现 - [AppDelegate applicationDidReceiveMemoryWarning:]代理方法。<br>在 UIViewController 中重载 didReceiveMemoryWarning方法。<br>监听 UIApplicationDidReceiveMemoryWarningNotification通知。</p>
<p>当通过这些方式监听到内存警告时，你需要马上释放掉不需要的内存从而避免程序被系统杀掉。<br>比如，在一个 UIViewController 中，你可以清除那些当前不显示的 View，同时可以清除这些 View 对应的内存中的数据，而有图片缓存机制的话也可以在这时候释放掉不显示在屏幕上的图片资源。<br>但是需要注意的是，你这时清除的数据，必须是可以在重新获取到的，否则可能因为必要数据为空，造成程序出错。在开发的时候，可以使用 iOS Simulator 的 Simulate memory warning的功能来测试你处理内存警告的代码。</p>
<p>##复用高开销的对象<br>在 Objective-C 中有些对象的初始化过程很缓慢，比如：NSDateFormatter和 NSCalendar，但是有些时候，你也不得不使用它们。为了这样的高开销的对象成为影响程序性能的重要因素，我们可以复用它们。<br>比如，我们在一个类里添加一个 NSDateFormatter 的对象，并使用懒加载机制来使用它，整个类只用到一个这样的对象，并只初始化一次：<br>保证应用快速启动的指导原则：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your .h or inside a class extension</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDateFormatter</span> *dateFormatter;</span><br><span class="line"><span class="comment">// inside the implementation (.m)</span></span><br><span class="line"><span class="comment">// When you need, just use self.dateFormatter</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123; </span><br><span class="line">     <span class="keyword">if</span> (! _dateFormatter) &#123; </span><br><span class="line">     _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">     [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>]; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> _dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是上面的代码在多线程环境下会有问题，所以我们可以改进如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no property is required anymore. The following code goes inside the implementation (.m)</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *dateFormatter; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">   <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">      _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init]; </span><br><span class="line">      [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>];</span><br><span class="line">   &#125;);</span><br><span class="line"> <span class="keyword">return</span> dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就线程安全了。（关于多线程 GCD 的知识，可以看看这篇文章：<a href="http://www.samirchen.com/ios-gcd/" target="_blank" rel="noopener">GCD</a>）<br>需要注意的是：设置 NSDateFormatter 的 date format 跟创建一个新的 NSDateFormatter 对象一样慢，因此当你的程序中要用到多种格式的 date format，而每种又会用到多次的时候，你可以尝试为每种 date format 创建一个可复用的 NSDateFormatter 对象来提供程序的性能。</p>
<p>##减少应用启动时间<br>快速启动应用对于用户来说可以留下很好的印象。尤其是第一次使用时。尽量将启动过程中的处理分拆成各个异步处理流，比如：网络请求、数据库访问、数据解析等等。<br>避免臃肿的 XIB 文件，因为它们会在你的主线程中进行加载。重申：Storyboard 没这个问题，放心使用。<br>注意：在测试程序启动性能的时候，最好用与 Xcode 断开连接的设备进行测试。因为 watchdog 在使用 Xcode 进行调试的时候是不会启动的。</p>
<p>##选择正确的数据格式</p>
<p>我们的 iOS 应用程序与服务器进行交互时，通常采用的数据格式就是 JSON 和 XML 两种。那么在选择哪一种时，需要考虑到它们的优缺点。<br>JSON 文件的优点是：</p>
<ul>
<li>能够更快的被解析。</li>
<li>在承载相同的数据时，通常体积比 XML 更小，这意味着传输的数据量更小。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>需要整个 JSON 数据全部加载完成后才能开始解析。</li>
</ul>
<p>而 XML 文件的优缺点则刚好反过来。 XML 的一个优点就是它可以使用 <a href="https://en.wikipedia.org/wiki/Simple_API_for_XML" target="_blank" rel="noopener">SAX</a> 来解析数据，从而可以边加载边解析，不用等所有数据都读取完成了才解析。这样在处理很大的数据集的时提高性能和降低内存消耗。<br>所以，你需要根据具体的应用场景来权衡使用何种数据格式。</p>
<p>##合理的设置背景图片<br>我们通常有两种方式来设置一个 View 的背景图片：</p>
<ul>
<li>通过 - [UIColor colorWithPatternImage:]方法来设置 View 的 background color。</li>
<li>通过给 View 添加一个 UIImageView 来设置其背景图片。<br>当你有一个全尺寸图片作为背景图时，你最好用 UIImageView 来，因为 - [UIColor colorWithPatternImage:]<br>是用来可重复填充的小的样式图片。这时对于全尺寸的图片，用 UIImageView 会节省大量的内存。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You could also achieve the same result in Interface Builder</span></span><br><span class="line"><span class="built_in">UIImageView</span> *backgroundView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background"</span>]];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:backgroundView];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是，当你计划采用一个小块的模板样式图片，就像贴瓷砖那样来重复填充整个背景时，你应该用- [UIColor colorWithPatternImage:]<br> 这个方法，因为这时它能够绘制的更快，并且不会用到太多的内存。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"backgroundPattern"</span>]];</span><br></pre></td></tr></table></figure></p>
<p>##优化 WebView<br>UIWebView 在我们的应用程序中非常有用，它可以便捷的展示 Web 的内容，甚至做到你用标准的 UIKit 控件较难做到的视觉效果。但是，你应该注意到你在应用程序里使用的 UIWebView 组件不会比苹果的 Safari 更快。这是首先于 Webkit 的 Nitro Engine 引擎。所以，为了得到更好的性能，你需要优化你的网页内容。</p>
<p>优化第一步就是避免过量使用 Javascript，例如避免使用较大的 Javascript 框架，比如 jQuery。一般使用原生的 Javascript 而不是依赖于 Javascript 框架可以获得更好的性能。</p>
<p>优化第二步，如果可能的话，可以异步加载那些不影响页面行为的 Javascript 脚本，比如一些数据统计脚本。</p>
<p>优化第三步，总是关注你在页面中所使用的图片，根据具体的场景来显示正确尺寸的图片，同时也可以使用上面提到的「使用 Sprites Sheets」的方案来在某些地方减少内存消耗和提高速度。</p>
<p>##减少离屏渲染</p>
<p>什么是「离屏渲染」？离屏渲染，即 Off-Screen Rendering。与之相对的是 On-Screen Rendering，即在当前屏幕渲染，意思是渲染操作是用于在当前屏幕显示的缓冲区进行。那么离屏渲染则是指图层在被显示之前是在当前屏幕缓冲区以外开辟的一个缓冲区进行渲染操作。<br>离屏渲染需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕，而上下文环境的切换是一项高开销的动作。<br>通常图层的以下属性将会触发离屏渲染：</p>
<ul>
<li>阴影（UIView.layer.shadowOffset/shadowRadius/…）</li>
<li>圆角（当 UIView.layer.cornerRadius 和 UIView.layer.maskToBounds 一起使用时）</li>
<li>图层蒙板<br>在 iOS 开发中要给一个 View 添加阴影效果，有很简单快捷的做法：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:...];</span><br><span class="line"><span class="comment">// Setup the shadow ...</span></span><br><span class="line">imageView.layer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">5.0</span>f, <span class="number">5.0</span>f);</span><br><span class="line">imageView.layer.shadowRadius = <span class="number">5.0</span>f;</span><br><span class="line">imageView.layer.shadowOpacity = <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是上面这样的做法有一个坏处是：将触发 Core Animation 做离屏渲染造成开销。<br>那要做到阴影图层效果，又想减少离屏渲染、提高性能的话要怎么做呢？一个好的建议是：设置 ShadowPath 属性。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initFrame:...];</span><br><span class="line"><span class="comment">// Setup the shadow ...</span></span><br><span class="line">imageView.layer.shadowPath = [[<span class="built_in">UIBezierPath</span> bezierPathWithRect:</span><br><span class="line"><span class="built_in">CGRectMake</span>(imageView.bounds.origin.x+<span class="number">5</span>, imageView.bounds.origin.y+<span class="number">5</span>,imageView.bounds.size.width, imageView.bounds.size.height)] <span class="built_in">CGPath</span>];</span><br><span class="line">imageView.layer.shadowOpacity = <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果图层是一个简单几何图形如矩形或者圆角矩形（假设不包含任何透明部分或者子图层），通过设置 ShadowPath 属性来创建出一个对应形状的阴影路径就比较容易，而且 Core Animation 绘制这个阴影也相当简单，不会触发离屏渲染，这对性能来说很有帮助。如果你的图层是一个更复杂的图形，生成正确的阴影路径可能就比较难了，这样子的话你可以考虑用绘图软件预先生成一个阴影背景图。</p>
<p>##光栅化<br>CALayer 有一个属性是 shouldRasterize<br> 通过设置这个属性为 YES 可以将图层绘制到一个屏幕外的图像，然后这个图像将会被缓存起来并绘制到实际图层的 contents 和子图层，如果很很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧来更加高效。但是光栅化原始图像需要时间，而且会消耗额外的内存。这是需要根据实际场景权衡的地方。<br>当我们使用得当时，光栅化可以提供很大的性能优势，但是一定要避免在内容不断变动的图层上使用，否则它缓存方面的好处就会消失，而且会让性能变的更糟。<br>为了检测你是否正确地使用了光栅化方式，可以用 Instrument 的 Core Animation Template 查看一下Color Hits Green and Misses Red<br> 项目，看看是否已光栅化图像被频繁地刷新（这样就说明图层并不是光栅化的好选择，或则你无意间触发了不必要的改变导致了重绘行为）。<br>如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为合适的值。在我们使用 UITableView 和 UICollectionView 时经常会遇到各个 Cell 的样式是一样的，这时候我们可以使用这个属性提高性能：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell.layer.shouldRasterize = <span class="literal">YES</span>;</span><br><span class="line">cell.layer.rasterizationScale = [[<span class="built_in">UIScreen</span> mainScreen] scale];</span><br></pre></td></tr></table></figure></p>
<p>但是，如果你的 Cell 是样式不一样，比如高度不定，排版多变，那就要慎重了。</p>
<p>##选择合适的数据存储方式<br>在 iOS 中可以用来进行数据持有化的方案包括：</p>
<ul>
<li>NSUserDefaults。只适合用来存小数据。</li>
<li>XML、JSON、Plist 等文件。JSON 和 XML 文件的差异在「选择正确的数据格式」已经说过了。</li>
<li>使用 NSCoding 来存档。NSCoding 同样是对文件进行读写，所以它也会面临必须加载整个文件才能继续的问题。</li>
<li>使用 SQLite 数据库。可以配合 <a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a> 使用。数据的相对文件来说还是好处很多的，比如可以按需取数据、不用暴力查找等等。</li>
<li>使用 CoreData。也是数据库技术，跟 SQLite 的性能差异比较小。但是 CoreData 是一个对象图谱模型，显得更面向对象；SQLite 就是常规的 DBMS。</li>
</ul>
<h2 id="使用-Autorelease-Pool"><a href="#使用-Autorelease-Pool" class="headerlink" title="使用 Autorelease Pool"></a>使用 Autorelease Pool</h2><p>NSAutoreleasePool 是用来管理一个自动释放内存池的机制。在我们的应用程序中通常都是 UIKit 隐式的自动使用 Autorelease Pool，但是有时候我们也可以显式的来用它。</p>
<p>比如当你需要在代码中创建许多临时对象时，你会发现内存消耗激增直到这些对象被释放，一个问题是这些内存只会到 UIKit 销毁了它对应的 Autorelease Pool 后才会被释放，这就意味着这些内存不必要地会空占一些时间。这时候就是我们显式的使用 Autorelease Pool 的时候了，一个示例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;for (NSURL *url in urls) &#123; </span></span><br><span class="line">      <span class="keyword">@autoreleasepool</span> &#123; </span><br><span class="line">             <span class="built_in">NSError</span> *error;</span><br><span class="line">             <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span>  stringWithContentsOfURL:url</span><br><span class="line">                                                                encoding:<span class="built_in">NSUTF8StringEncoding</span></span><br><span class="line">                                                                   error:&amp;error];</span><br><span class="line"> <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span> </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码在每一轮迭代中都会释放掉临时对象，从而缓解内存压力，提高性能。</p>
<p>##imageNamed 和 imageWithContentsOfFile<br>在 iOS 应用中加载图片通常有 - [UIImage imageNamed:]<br> 和 -[UIImage imageWithContentsOfFile:]<br> 两种方式。它们的不同在于前者会对图片进行缓存，而后者只是简单的从文件加载文件。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myImage"</span>]; <span class="comment">// caching</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWithContentsOfFile:<span class="string">@"myImage"</span>]; <span class="comment">// no caching</span></span><br></pre></td></tr></table></figure></p>
<p>在整个程序运行的过程中，当你需要加载一张较大的图片，并且只会使用它一次，那么你就没必要缓存这个图片，这时你可以使用 -[UIImage imageWithContentsOfFile:]<br>，这样系统也不会浪费内存来做缓存了。当然，如果你会多次使用到一张图时，用 - [UIImage imageNamed:]<br> 就会高效很多，因为这样就不用每次都从硬盘上加载图片了。</p>
<p>##避免使用 NSDateFormatter</p>
<p>在前文中，我们已经讲到了通过复用或者单例来提高 NSDateFormatter 这个高开销对象的使用效率。但是如果你要追求更快的速度，你可以直接使用 C 语言替代 NSDateFormatter 来解析 date，你可以看看这篇文章：<a href="http://blog.soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments" target="_blank" rel="noopener">link</a>，其中展示了解析 ISO-8601 date string 的代码，你可以根据你的需求改写。完成的代码见：<a href="https://github.com/samsoffes/sstoolkit/blob/master/SSToolkit/NSDate%2BSSToolkitAdditions.m" target="_blank" rel="noopener">SSToolkit/NSDate+SSToolkitAdditions.m</a>。<br>当然，如果你能够控制你接受到的 date 的参数的格式，你一定要尽量选择 Unix timestamps<br> 格式，这样你可以使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDate</span>*)dateFromUnixTimestamp:(<span class="built_in">NSTimeInterval</span>)timestamp &#123; </span><br><span class="line">           <span class="keyword">return</span> [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:timestamp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样你可以轻松的将时间戳转化为 NSDate 对象，并且效率甚至高于上面提到的 C 函数。<br>需要注意的是，很多 web API 返回的时间戳是以<strong>毫秒</strong>为单位的，因为这更利于 Javascript 去处理，但是上面代码用到的方法中 NSTimeInterval 的单位是<strong>秒</strong>，所以当你传参的时候，记得先除以 1000。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/16/Bonjour！实现零配置网络联网的解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Water的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/16/Bonjour！实现零配置网络联网的解决方案/" itemprop="url">Bonjour！实现零配置网络联网的解决方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-16T00:00:00+08:00">
                2016-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Bonjour！实现零配置网络联网的解决方案"><a href="#Bonjour！实现零配置网络联网的解决方案" class="headerlink" title="Bonjour！实现零配置网络联网的解决方案"></a>Bonjour！实现零配置网络联网的解决方案</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>简单介绍一下项目对本地网络连接的需求：车机连接移动设备。</p>
<p>那我们如何进行连接呢。</p>
<ol>
<li><p>首先我们想到的最简单的方法就是通过IP连接。</p>
</li>
<li><p>UDP广播。</p>
</li>
</ol>
<p>利用UDP广播我们能向同一本地网络所有设备发送一条消息,接收到信息后我们能够解析出发送方的端口和IP。</p>
<p>问题：</p>
<ol>
<li>耗电问题。不断的UDP Broadcast 会耗费大量电源。</li>
<li>网络阻塞问题。因为UDP广播会对同一本地网络的所有Host都发送信息。过于密集的发送,有可能会造成网络的堵塞。</li>
<li>稳定性,UDP Socket可能会因为各种情况而中断。</li>
</ol>
<h3 id="什么是-Bonjour"><a href="#什么是-Bonjour" class="headerlink" title="什么是 Bonjour ?"></a>什么是 Bonjour ?</h3><p><strong>bonjour</strong> 是苹果公司发布的一个基于 <strong>ZEROCONF</strong> 工作组 <strong>(IETF</strong>下属小组) 的工作,用于实现零配置网络联网的解决方案。<strong>Bonjour</strong>是基于<strong>IP</strong>层协议的。</p>
<p>Bonjour是Apple推出的零配置网络协议，主要的目的是在缺少中心服务器的情况下解决网络设备的IP获取，名称解析和服务发现等关键问题。</p>
<h3 id="Bonjour可以做什么"><a href="#Bonjour可以做什么" class="headerlink" title="Bonjour可以做什么"></a>Bonjour可以做什么</h3><hr>
<p> Bonjour可以完成的工作主要是在缺少中心服务器的情况下解决IP获取，名称解析和服务发现这三个问题。</p>
<ul>
<li>IP获取<br>在传统网络环境下，设备的IP地址通过两种方式获取，一种是静态配置，通过手工方式为设备指定一个IP地址，一种是动态配置，设备通过路由器的DHCP服务获得动态的IP地址。<br>在无中心服务器的网络环境下，没有中心服务器提供DHCP服务，用户手工配置IP地址也很不方便，这就需要一种新的方式来帮助设备获取IP地址，就是希望设备可以主动为自己指定一个可用的IP地址。<br>在IPV6环境下，IPV6协议本身就提供了设备自指定IP地址的能力，所以实现很简单，直接使用IPV6的协议支持就可以了。<br>在IPV4环境下，Bonjour使用了随机指定IP地址的方法，首先为设备随机指定一个属于本地网段的IP地址，然后检查该地址在本地是否有冲突，如果有冲突就随机生成另一个新的IP地址，直到找到可用IP地址为止。<br>我在做测试的时候没有测试这部分，都是使用的DHCP的动态地址。以后有时间测试了这个部分后再和大家分享测试结果。</li>
<li><strong><em>**</em></strong>名称解析<strong><em>**</em></strong><br>在传统网络环境下，名称和IP地址的对应关系是通过DNS服务解析的。当一个设备需要访问一个域名，如“<a href="http://www.abc.com”，设备将“www.abc.com”发给DNS服务器，服务器返回该域名对应的IP地址，设备再使用返回的IP地址对目标服务器进行访问。" target="_blank" rel="noopener">www.abc.com”，设备将“www.abc.com”发给DNS服务器，服务器返回该域名对应的IP地址，设备再使用返回的IP地址对目标服务器进行访问。</a><br>在没有中心服务器的网络环境中，没有DNS服务器提供域名解析服务，名称解析变成一个严重问题。针对这一问题，业界的解决方案是mDNS，中文叫“组播DNS”，在标准文档RFC6762中定义。<br>“组播DNS”的原理很简单，当一个设备需要解析一个名称时，如“abc.local”，这个设备通过UDP协议向本地网络中的所有设备广播一个消息，问谁是“abc.local”，本地网络中如果有一个设备认为自己是“abc.local”，它就给出响应，说出自己的IP地址。<br>因为“组播DNS”基于UDP协议，采用广播消息的方式，所以不需要一个中心服务器提供DNS解析服务就可以完成本地的名称解析。<br>Bonjour也是基于mDNS协议的，不过Bonjour在mDNS协议上作了扩展，加强了设备响应“组播DNS”请求的能力。在Bonjour协议下，应用只需要对某个名称进行注册，就可以将响应“组播DNS”请求的工作交由底层处理。也就是说在Bonjour协议下，应用不需要侦听本地网络的“组播DNS”请求并进行响应，这些工作由底层系统完成。<br>为了区分全球域名和本地域名，mDNS协议使用“.local.”作为本地域名的根域名。</li>
<li><strong><em>**</em></strong>服务搜索（自动在网络搜索服务）<strong><em>**</em></strong><br>当一个提供服务的设备获取IP地址，并自我指定一个域名后，其实还是不能满足用户的需求。因为用户需要的是某种服务，如打印服务，web服务，用户并不关心这些服务对应的服务器名称和它的IP地址。<br>为了让用户更容易发现本地网络中的各种服务，Bonjour为设备提供了服务发现的能力。<br>Bonjour提供的“服务发现”能力基于一个简单直接的规定，就是提供服务的设备在按以下标准对服务进行注册：“名称.服务类型.传输协议类型.local.”，比如：“DamonWebServer._http._tcp.local.”，又比如“DummiesWebServer._http._tcp.local.”。<br>这样，当一个设备使用希望查找http服务的时候，Bonjour会去查找本地网络中注册过的包含”_http”的服务，然后将结果返回给用户选择。这时用户面对的是“DamonWebServer”和”DummiesWebServer”，用户可以不去关心到底这两个web服务到底在那台设备上，该设备的IP地址是什么。<br>###如何使用Bonjour</li>
</ul>
<hr>
<p> 对于最终用户来讲，Bonjour基本上是透明的，他们不需要了解如何去使用Bonjour，往往都是应用开发者去考虑如何使用Bonjour。<br> 对于应用开发者来讲，他们需要考虑有两部分，一是如何作为Bonjour客户端去发现使用本地服务，二是如何作为服务端如何注册Bonjour服务</p>
<ul>
<li>如何作为Bonjour客户端去发现本地服务<br>iOS开发可以使用NSNetService框架中的NSNetServiceBrowser类去发现本地服务。<br>基本过程如下：<br>首先创建NSNetServiceBrowser实例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    serviceBrowser = [[NSNetServiceBrowser alloc] init];</span><br><span class="line">    serviceBrowser.delegate = self;</span><br><span class="line">    [serviceBrowser searchForServicesOfType:@&quot;_http._tcp.&quot; inDomain:@&quot;local.&quot;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> - (void)netServiceBrowser:(NSNetServiceBrowser *)netServiceBrowser didFindService:(NSNetService *)netService moreComing:(BOOL)moreServicesComing &#123;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如何作为服务端注册Bonjour服务<br>要注册成为Bonjour服务，开发者可以直接创建NSNetService实例，<br>并通过initwithDomain:type:name:port:方法进行初始化，指定服务的域，类型，名称和端口，样例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    service = [[NSNetService alloc] initWithDomain:@&quot;local.&quot; type:@&quot;_http._tcp.&quot; name:@&quot;DamonWebServer&quot; port:port];</span><br></pre></td></tr></table></figure>
<p>NSNetService创建成功后，可以通过setDelegate指定代理，同时通过publish方法发布注册服务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        [service setDelegate:self];</span><br><span class="line">        [service publish];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 其中指定的代理需要遵从“NSNetServiceDelegate”协议，可以对服务发布成功，发布失败等事件。</p>
<p> 正常来讲，如果需要发布一个服务，需要在发布服务之前准备好服务并启动它。不过NSNetService的publish方法并不依赖它所发布的服务，不管服务是否准备好，是否启动，NSNetService的publish都可以成功将服务发布出去，只不过服务发布出去后其它使用这个服务的客户端会发现这个发布出来的服务是个无效服务。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/16/iOS 适配 & 开发策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Water的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/16/iOS 适配 & 开发策略/" itemprop="url">iOS 适配 & 开发策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-16T00:00:00+08:00">
                2016-07-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-适配-amp-开发策略"><a href="#iOS-适配-amp-开发策略" class="headerlink" title="iOS 适配 &amp; 开发策略"></a>iOS 适配 &amp; 开发策略</h1><h2 id="屏幕尺寸适配"><a href="#屏幕尺寸适配" class="headerlink" title="屏幕尺寸适配"></a>屏幕尺寸适配</h2><hr>
<p> 2007 年，初代 iPhone发布，其拥有 3.5寸屏幕，运行 iPhone OS X。在后续几年中Apple 陆续发布了 iPhone 3GS，iPhone 4，iPhone 4S，iPhone 5C，iPhone 5S，iPhone 6，iPhone 6 Plus，iPhone 6S、iPhone 6S Plus，iPhoneSE ，iPhone7，iPhone7 Plus, 2017年9月将发布iphone 8。其运行的操作系统也从 iOS 4、iOS 5、iOS 6、iOS 7 、iOS 8， iOS 9，iOS10，iOS11。随着新版 iPhone，新版iOS操作系统的上市，随着维护的iPhone和IOS版本增多，如何确保 App适配新版iPhone及iOS操作系统？而这又是必须解决的问题，否则App将丧失新版iPhone新版iOS 系统上的用户，从而带来巨大的损失。<br>        Apple 提供的解决方案之一就是：引入了点(point)的概念。在 iPhone 3GS 中, 1个点对应1个像素，点和像素两者在数值上是一致的。在iPhone 4/4S中，虽然机型变化，其荧幕宽高像素点增加了，但是其宽高点坐标是不变的。所以在开发过程中可以使用点绝对坐标，用来确定视图的位置。同时提供两套图片: ~.png 和 <a href="mailto:~@2x.png" target="_blank" rel="noopener">~@2x.png</a>。 iOS 系统将根据 iPhone 的像素来自动决定使用哪一张图片。 </p>
<table>
<thead>
<tr>
<th>机型</th>
<th>屏幕尺寸</th>
<th>屏幕宽高（像素）</th>
<th>屏幕宽高（点）</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPhone 3GS</td>
<td>3.5</td>
<td>320x480</td>
<td>320 x 480</td>
<td>1x</td>
</tr>
<tr>
<td>iPhone 4</td>
<td>3.5</td>
<td>640 x 960</td>
<td>320 x 480</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 4S</td>
<td>3.5</td>
<td>640 x 960</td>
<td>320 x 480</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 5</td>
<td>4</td>
<td>640 x 1136</td>
<td>320 x 568</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 5C</td>
<td>4</td>
<td>640 x 1136</td>
<td>320 x 568</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 5S</td>
<td>4</td>
<td>640 x 1136</td>
<td>320 x 568</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 5SE</td>
<td>4</td>
<td>640 x 1136</td>
<td>320 x 568</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>4.7</td>
<td>750 x 1134</td>
<td>375 x 667</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 6 Plus</td>
<td>5.5</td>
<td>1080 x 1920</td>
<td>414 x 736</td>
<td>2.6x</td>
</tr>
<tr>
<td>iPhone 6S</td>
<td>4.7</td>
<td>750 x 1134</td>
<td>375 x 667</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 6S Plus</td>
<td>5.5</td>
<td>1080 x 1920</td>
<td>414 x 736</td>
<td>2.6x</td>
</tr>
<tr>
<td>iPhone 7</td>
<td>4.7</td>
<td>750 x 1134</td>
<td>375 x 667</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 7 Plus</td>
<td>5.5</td>
<td>1080 x 1920</td>
<td>414 x 736</td>
<td>2.6x</td>
</tr>
</tbody>
</table>
<p> 在iPhone5/5C/5S中，其荧幕，像素以及点，都已经发生变化。相比iPhone4/4S, 其荧幕宽度不变，高度增加88个点。在这种情况下，就不能再使用绝对坐标，否则将导致程序高度不够。如果App没有对其做适配处理，iOS 将对88个点均分为上下两部分，荧幕上下各出现44个点的黑边。在不同机型上，荧幕点坐标改变了，于是再也不能使用绝对坐标。为了彻底解决这个问题，iOS提出了一种新技术AutoLayout。使用AutoLayout技术，将不使用绝对坐标，而是指定View，button，TextField之间的相对位置，比如靠左多少，靠右多少，相距多少等。通过指定这一系列的约束条件，AutoLayout在荧幕上自动的画出对应布局。在iPhone5/5C/5S中，由于像素：点的比例仍为2，所以将直接使<a href="mailto:~@2x.png" target="_blank" rel="noopener">~@2x.png</a> 图片即可。如果没有提供<a href="mailto:~@2x.png" target="_blank" rel="noopener">~@2x.png</a>的图片，那么就直接使用~.png的图片覆盖同样的点。虽然点的数量一样，但是像素点却多了1倍，以致在这种情况下，图片显示会比较模糊。在iPhone6面世后，其荧幕大小坐标已经变化，宽，高都增加了。但是宽，高比不变，为9:16。而且其像素：点比仍然为2。在2x和3x的图片都不太合适。iOS的解决方案是：现有的银幕分辨率明显超过2x但没有达到3x，于是想象一个满足3x的银幕总可以吧?<br>        于是App在iPhone 6 Plus上运行的时候，iOS会骗App说，App现在运行在一个 3x的荧幕上，其像素为1242x2208，点为414 x 736，而且都比iPhone 6要大。于是程序设计师和UED也按照3x来设计。UED 提供 3x 的高清图片，程序设计师依据414 x 736 来编写App。但是借来的总是要还的。iOS 在拿到这个假想 1242x2208 的绘制结果，再缩小到实际 1080 x 1920 荧幕来画图（通过某种缩小算法)。于是在 iPhone 6 Plus荧幕上看到的永远是缩小的图像。通过3x模式,使得设计开发过程得到了大大的简化。</p>
<p>##CPU 指令集<br>| 机型 | ARM 架构|<br>| ——| —— |<br>| iPhone 3GS | ARM V6|<br>| iPhone 4 | ARM V7|<br>| iPhone 4S | ARM V7|<br>| iPhone 5 | ARM V7S|<br>| iPhone 5C | ARM V7S|<br>| iPhone 5S | ARM V8(64)|<br>| iPhone 6 | ARM V8(64)|<br>| iPhone 6 Plus | ARM V8(64)|<br>| iPhone 6S | ARM V8(64)|<br>| iPhone 6S Plus | ARM V8(64)|<br>| iPhone 5SE  | ARM V8(64)|<br>| iPhone 7 | ARM V8(64)|<br>| iPhone 7 Plus | ARM V8(64)|</p>
<p>指令集是向后兼容的。比如ARMV7S指令集下生成的二进制包，可以运行在iPhone 6上，只是有些优化不可用，效率没有那么高而已。反之，ARM V8生成的二进制包, 就不能在 ARM V7S的iPhone 5上。 在编译二进制包的时候，需要确认其所能支持的ARM架构。如果希望App在各版iPhone上都能够高效运行，则需要将Build Active Architecture Only改为NO，Valid architectures选择对应的指令集：ARM V7 ARM V7S ARM 8。为各个指令集编译对应的代码，因此最后的ipa包的体积基本翻了3倍。如果希望App体积保持最小, 则现阶段应该选Valid architectures为ARM V7，这样Build Active Architecture Only选YES或NO就无所谓了。在ARM V8上，最明显的一个区别就是支持64-bit。于是在iOS上的数据类型发生了变化。数据长度的改变给App带来的影响之一就是: 当把一个值从大的数据类型拷贝到小的数据类型，数据可能被截断，例如从NSInteger 转换到int。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/901318-d53902919c7842c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.png"><br>Architecture ：指你想支持的指令集。Valid architectures ：指即将编译的指令集。Build Active Architecture Only : 只是否只编译当前适用的指令集。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/901318-c0bfe38c8bc650fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.png"></p>
<p>##iOS 系统<br>每次iPhone机型的升级，往往同时伴随着新版iOS系统的发布。最开始的iPhone OSX，其创新的多点触控操作和极简的用户体验受到了用户的追捧。虽然初代的系统还存在各种各样的问题，比如无法复制粘贴等，但是它开启了移动设备操作系统的新时代。随着iOS 4增加了对Retina和多任务的支持，iOS 5带来了Siri 语音助手，iOS 6引入了全新的地图，iOS 7全新的扁平化图标界面设计，到iOS 8开始支持的Touch ID，iOS 9 Watch OS 2、App Thinning、3D Tought、分屏多任务，iOS系统在不断的更新(当然每次iOS系统的迭代更新，其对应的SDK也被推向开发人员)。发布上线的 App，必须考虑到对不同版本iOS系统的适配。因为在某一个特定时间点，并不是所有的用户都在最新版本的操作系统，比如有些用户在使用iOS 8，但总还是有一些用户停留在iOS 7,iOS 6甚至iOS 5。举例来说,相对 iOS 7 而言,iOS 8 中对内置相机做了改动—-自由调节进光量，在拍摄中，触摸屏幕对好焦点后，会在对焦框旁边出现进光量调节轴，增加或降低拍摄的曝光量，从而不必因为光的问题频繁找焦点测光了。值得注意的是:：App AliExpress.com使用了调用了iOS拍照的功能，且其在iOS 7上工作中正常。在安装该App的iPhone升级为iOS 8之后，需要验证App的拍照功能是否工作正常, 确认其没有受到 iOS 8 拍照功能改动的影响。与之类似,和 iOS 7相比，iOS 8还有一些新功能，比如开放支持第三方输入法；锁屏推送中直接操作，而并不需要打开信息应用；多人群聊，实时位置共享，还可以发送语音和视频消息。根据这些iOS 8新功能，评估其对App风险。再而一一测试App上对应的功能。只有这些点都被测试通过之后，才能够宣布该App已经适配了iOS 8。</p>
<table>
<thead>
<tr>
<th>iOS系统</th>
<th>iOS各版本市场占比</th>
<th>与前版本主要不同之处</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS 7</td>
<td>&lt; 8%</td>
<td>1. 重新设计的视觉界面,扁平化文件系统</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2. 全新的控制中心从下侧边缘滑出控制中心</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3. 全新的MultiTasking设计，App预览及App关闭方式</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4. 通知中心，锁屏下可以查看推送</td>
</tr>
<tr>
<td></td>
<td></td>
<td>5. Safari 升级，包括支持全荧幕浏览，左右切换等</td>
</tr>
<tr>
<td></td>
<td></td>
<td>6.其他多项新功能</td>
</tr>
<tr>
<td>iOS 8</td>
<td>15%</td>
<td>1. 相机延时拍照，进光量调节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2. QuickType及第三方输入法</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3. 交互式通知中心</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4. Safari升级，向外切换到书签，分享链接</td>
</tr>
<tr>
<td></td>
<td></td>
<td>5. 即时聊天，群聊，位置分享，分享视频等</td>
</tr>
<tr>
<td></td>
<td></td>
<td>6.  其他多项新功能</td>
</tr>
<tr>
<td>iOS 9</td>
<td>77%</td>
<td>1. 3D Tought</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2.应用内搜索</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3.  App Watch OS 2.0支持</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4. BitCode App瘦身</td>
</tr>
<tr>
<td></td>
<td></td>
<td>5.  App Transport Security（ATS)</td>
</tr>
<tr>
<td>iOS 9</td>
<td>77%</td>
<td>1. 3D Tought</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2.应用内搜索</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3.  App Watch OS 2.0支持</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4. BitCode App瘦身</td>
</tr>
<tr>
<td></td>
<td></td>
<td>5.  App Transport Security（ATS)</td>
</tr>
</tbody>
</table>
<p>##开发策略<br>了解iPhone设备，iOS系统的适配原理，有益于App的开发。<br>在App开发阶段，将适配性作为代码的规范之一。从而能够在源头改善代码质量，提高App质量，降低App适配风险。其指导性策略如下:<br>1、布局相关：不使用绝对坐标，建议使用第三方（Masonry）进行相对位置设置。<br>2、通过点的概念，而不使用像素，来统一思考不同机器上的适配，为适配创造良好的基础。 比如要在view里面画一个44x44个点的按钮，2x模式，就乘以2，3x模式就乘以3。<br>3、调用系统API之前，需要考虑iOS的版本。<br>4、特定的API在不同iOS版本中，其功能，参数，返回数据可能有所不同。这些数据在对应的SDK中可以找到详情。所以在使用这些API之前，需要对这些功能, 参数，返回数据进行特殊处理。<br>5、iOS的某些特定版本，自身也存在一些bug。这些bug的详情在Apple Inc.官网<a href="http://www.apple.com中iOS的release" target="_blank" rel="noopener">www.apple.com中iOS的release</a> document中有披露。在App设计中，要避免踩到iOS特定版本自身的 bug。</p>
<p>##测试策略<br>依据上述的iPhone机型市场占比可以对其适配性专项进行优先级排序。市场占比最多的iPhone 5S，iPhone 6的优先级别最高，依次为 iPhone 5／5C，iPhone 6 Plus等。优先级别最低为iPhone 4S。在这些级别中，主要注意机型之间不同尺寸荧幕所带来的差别，包括分辨率，像素的不同。在App安装到这些机型上面后，其UI应该拉升或者压缩到满荧幕，不得出现空白区域或者某些部分不能显示。UI所对应的功能，与硬件相隔离，而一一工作正常。在编译二进制包而选择指令集，其包在跨机型上工作正常，App对指令集兼容。</p>
<p>App 在不同尺寸/分辨率/像素的荧幕手机下，其UI拉升压缩满整屏幕，视觉显示正常，对应功能正常。<br>基于不同指令集下编译的包，安装在跨机型上工作正常。<br>       在iOS系统适配方面，根据各个iOS系统的改动功能点，和App上与之对应的相关功能, 一一评估其风险并验证。其中iOS 7和iOS 8之间的系统差异特别明显，需要特别关注。在App的适配测试中，需要同时考虑 iPhone和iOS系统两个维度，建议从代码层面深层次的分析问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/11/[IOS 防止Crash 组件WTSafeGuard ](https---github.com-hongruqi-SafeGuard)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Water的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/11/[IOS 防止Crash 组件WTSafeGuard ](https---github.com-hongruqi-SafeGuard)/" itemprop="url">iOS 降低线上版本Crash率</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-11T00:00:00+08:00">
                2016-07-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#iOS 降低线上版本Crash率 </p>
<h3 id="IOS-防止Crash-组件WTSafeGuard"><a href="#IOS-防止Crash-组件WTSafeGuard" class="headerlink" title="IOS 防止Crash 组件WTSafeGuard "></a><a href="https://github.com/hongruqi/SafeGuard" target="_blank" rel="noopener">IOS 防止Crash 组件WTSafeGuard </a></h3><p>##背景<br>由于Object-C本身的不安全性，导致很容易产生Crash。在这些Crash，很多我们可以利用自定义手段，进行避免。这样可以降低线上版本的Crash率，提升用户<br>体验。WTSafeGuard 避免APP Crash 组件，目前能做到的还很有限。</p>
<h3 id="UIKit-Called-on-Non-Main-Thread"><a href="#UIKit-Called-on-Non-Main-Thread" class="headerlink" title="UIKit Called on Non-Main Thread"></a>UIKit Called on Non-Main Thread</h3><p>UIKit不是线程安全的，执行UIKit操作如果不在主线程很可能造成程序Crash。所以我们对Hook，UIView 的setNeedsLayout，layoutIfNeeded，layoutSubviews，setNeedsUpdateConstraints方法。如果执行以上函数没有在主队列，通过强行将执行代码，在主队列执行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)wt_safe_setNeedsLayout</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_setNeedsLayout failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_setNeedsLayout];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_setNeedsLayout];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wt_safe_layoutIfNeeded</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_layoutIfNeeded failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_layoutIfNeeded];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_layoutIfNeeded];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wt_safe_layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_layoutSubviews failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_layoutSubviews];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_layoutSubviews];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wt_safe_setNeedsUpdateConstraints</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_setNeedsUpdateConstraints failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_setNeedsUpdateConstraints];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_setNeedsUpdateConstraints];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##避免 Foundation 类Carsh</p>
<p>###NSString<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)stringWithUTF8String:(<span class="keyword">const</span> <span class="keyword">char</span> *)bytes</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUTF8String:(<span class="keyword">const</span> <span class="keyword">char</span> *)nullTerminatedCString</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFormat:(<span class="built_in">NSString</span> *)format locale:(<span class="keyword">id</span>)locale arguments:(va_list)argList</span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">unichar</span>)characterAtIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">- (<span class="keyword">void</span>)getCharacters:(<span class="keyword">unichar</span> *)buffer range:(<span class="built_in">NSRange</span>)range</span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfCharacterFromSet:(<span class="built_in">NSCharacterSet</span>  *)searchSet </span><br><span class="line">                            options:(<span class="built_in">NSStringCompareOptions</span>)mask</span><br><span class="line">                              range:(<span class="built_in">NSRange</span>)searchRange</span><br><span class="line">                                    </span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString</span><br><span class="line">                options:(<span class="built_in">NSStringCompareOptions</span>)mask</span><br><span class="line">                  range:(<span class="built_in">NSRange</span>)searchRange</span><br><span class="line">                 locale:(<span class="built_in">NSLocale</span> *)locale</span><br><span class="line">- (<span class="built_in">NSString</span> *)substringFromIndex:(<span class="built_in">NSUInteger</span>)from</span><br><span class="line">- (<span class="built_in">NSString</span> *)substringWithRange:(<span class="built_in">NSRange</span>)range</span><br><span class="line">- (<span class="built_in">NSString</span> *)substringToIndex:(<span class="built_in">NSUInteger</span>)to</span><br><span class="line">- (<span class="keyword">void</span>)getLineStart:(<span class="built_in">NSUInteger</span> *)startPtr   </span><br><span class="line">                 end:(<span class="built_in">NSUInteger</span> *)lineEndPtr                                         </span><br><span class="line">                 contentsEnd:(<span class="built_in">NSUInteger</span> *)contentsEndPtr</span><br><span class="line">                   forRange:(<span class="built_in">NSRange</span>)range</span><br></pre></td></tr></table></figure></p>
<h3 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h3><p>hook 方法：对传入参数range 进行check，如果range有问题，直接返回nil</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSAttributedString</span> *)attributedSubstringFromRange:(<span class="built_in">NSRange</span>)range;</span><br></pre></td></tr></table></figure>
<h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDirectoryEnumerator</span>&lt;<span class="built_in">NSURL</span> *&gt; *)enumeratorAtURL:(<span class="built_in">NSURL</span> *)url includingPropertiesForKeys:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURLResourceKey</span>&gt; *)keys options:(<span class="built_in">NSDirectoryEnumerationOptions</span>)mask errorHandler:(<span class="keyword">nullable</span> <span class="built_in">BOOL</span> (^)(<span class="built_in">NSURL</span> *url, <span class="built_in">NSError</span> *error))handler</span><br></pre></td></tr></table></figure>
<p>###NSIndexPath<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getIndexes:(<span class="built_in">NSUInteger</span> *)indexes range:(<span class="built_in">NSRange</span>)positionRang</span><br></pre></td></tr></table></figure></p>
<p>###NSJSONSerialization<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSData</span> *)dataWithJSONObject:(<span class="keyword">id</span>)obj options:(<span class="built_in">NSJSONWritingOptions</span>)opt error:(<span class="built_in">NSError</span> **)error</span><br></pre></td></tr></table></figure></p>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><p>hook 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedKeySetForKeys:(<span class="built_in">NSArray</span>&lt;KeyType &lt;<span class="built_in">NSCopying</span>&gt;&gt; *)keys</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjects:(<span class="keyword">const</span> ObjectType _Nonnull [_Nullable])objects forKeys:(<span class="keyword">const</span> KeyType &lt;<span class="built_in">NSCopying</span>&gt; _Nonnull [_Nullable])keys</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjects:(<span class="keyword">const</span> ObjectType _Nonnull [_Nullable])objects forKeys:(<span class="keyword">const</span> KeyType &lt;<span class="built_in">NSCopying</span>&gt; _Nonnull [_Nullable])keys count:(<span class="built_in">NSUInteger</span>)cnt</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableDictionary"><a href="#NSMutableDictionary" class="headerlink" title="NSMutableDictionary"></a>NSMutableDictionary</h3><p>hook 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMutableDictionary</span>&lt;KeyType, ObjectType&gt; *)dictionaryWithSharedKeySet:(<span class="keyword">id</span>)keyset</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(ObjectType)anObject forKey:(KeyType &lt;<span class="built_in">NSCopying</span>&gt;)aKey;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(KeyType)aKey;</span><br></pre></td></tr></table></figure>
<p>###NSSet<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)WT_initWithObjects:(<span class="keyword">const</span> <span class="keyword">id</span> [])objects count:(<span class="built_in">NSUInteger</span>)cnt</span><br><span class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformSelector:(SEL)aSelector</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformSelector:(SEL)aSelector</span><br><span class="line">                        withObject:(<span class="keyword">id</span>)argument</span><br></pre></td></tr></table></figure></p>
<p>###NSMutableSet<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObject</span><br></pre></td></tr></table></figure></p>
<p>###NSMutableString<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">void</span>)appendString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">void</span>)deleteCharactersInRange:(<span class="built_in">NSRange</span>)range</span><br><span class="line">- (<span class="keyword">void</span>)insertString:(<span class="built_in">NSString</span> *)aString atIndex:(<span class="built_in">NSUInteger</span>)loc</span><br><span class="line">- (<span class="keyword">void</span>)replaceCharactersInRange:(<span class="built_in">NSRange</span>)range withString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">-  (<span class="built_in">NSUInteger</span>)replaceOccurrencesOfString:(<span class="built_in">NSString</span> *)target</span><br><span class="line">                                     withString:(<span class="built_in">NSString</span> *)replacement</span><br><span class="line">                                        options:(<span class="built_in">NSStringCompareOptions</span>)options</span><br><span class="line">                                          range:(<span class="built_in">NSRange</span>)searchRange</span><br></pre></td></tr></table></figure></p>
<p>###NSURL<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPath:(<span class="built_in">NSString</span> *)path isDirectory:(<span class="built_in">BOOL</span>)isDir</span><br><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPathComponents:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)components</span><br><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                      isDirectory:(<span class="built_in">BOOL</span>)isDir</span><br><span class="line">                    relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithString:(<span class="built_in">NSString</span> *)URLString relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br><span class="line">- (<span class="keyword">instancetype</span>)initFileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">- (<span class="keyword">instancetype</span>)initFileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                             relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br><span class="line">- (<span class="keyword">instancetype</span>)initFileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                               isDirectory:(<span class="built_in">BOOL</span>)isDir</span><br><span class="line">                             relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>KVO</li>
<li>容器越界（NSArray， NSDictionary,…）</li>
<li>unrecognized selector crash (这个很多时候是由于class使用错误导致)</li>
<li>NSTimer 导致crash</li>
</ol>
<hr>
<h3 id="KVO-Crash"><a href="#KVO-Crash" class="headerlink" title="KVO Crash"></a>KVO Crash</h3><p>项目中KVO crash 占比很高， 主要原因为，添加删除不对称导致。<br>解决方法为，添加Map进行缓存。<br>不过这个方案，目前还有缺陷。</p>
<h3 id="unrecognized-selector-crash"><a href="#unrecognized-selector-crash" class="headerlink" title="unrecognized selector crash"></a>unrecognized selector crash</h3><p>这个就比较简单了，直接上代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    [<span class="built_in">NSObject</span> jr_swizzleMethod:<span class="keyword">@selector</span>(forwardingTargetForSelector:) withMethod:<span class="keyword">@selector</span>(WT_safeForwardingTargetForSelector:) error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    - (<span class="keyword">id</span>)WT_safeForwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:aSelector] || signature) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> WT_safeForwardingTargetForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [WTSafeGuard createFakeForwardTargetObject:<span class="keyword">self</span> selector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2015/12/01/IOS 音频开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Water的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/12/01/IOS 音频开发/" itemprop="url">iOS 音频开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-12-01T00:00:00+08:00">
                2015-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-音频开发"><a href="#iOS-音频开发" class="headerlink" title="iOS 音频开发"></a>iOS 音频开发</h1><hr>
<ul>
<li>音频基础知识</li>
<li>音频文件计算大小</li>
<li>音频转码</li>
</ul>
<hr>
<h2 id="音频基础知识"><a href="#音频基础知识" class="headerlink" title="音频基础知识"></a>音频基础知识</h2><p>###组成<br>音频文件的组成：文件格式(或者音频容器)  + 数据格式(或者音频编码)。</p>
<p>###文件格式(或音频容器)是用于形容文件本身的格式。</p>
<p>我们可以通过多种不同的方法为真正的音频数据编码。例如CAF文件便是一种文件格式，它能够包含MP3格式，线性PCM以及其它数据格式的音频。</p>
<p>###数据格式(或音频编码)<br>我们将从音频编码开始阐述(而不是文件格式)，因为编码是最重要的环节。</p>
<p>###线性PCM：<br>这是表示线性脉冲编码调制，主要是描写用于将模拟声音数据转换成数字格式的技术。简单地说也就是未压缩的数据。因为数据是未压缩的，所以我们便可以最快速地播放出音频，而如果空间不是问题的话这便是iPhone音频的优先代码选择。</p>
<p>##音频文件计算大小 ##</p>
<hr>
<p>声卡对声音的处理质量可以用三个基本参数来衡量，即采样频率、采样位数和声道数。</p>
<p>####采样频率:<br>是指单位时间内的采样次数。采样频率越大，采样点之间的间隔就越小，数字化后得到的声音就越逼真，但相应的数据量就越大。声卡一般提供11.025kHz、22.05kHz和44.1kHz等不同的采样频率。</p>
<p>####采样位数：<br>是记录每次采样值数值大小的位数。采样位数通常有8bits或16bits两种，采样位数越大，所能记录声音的变化度就越细腻，相应的数据量就越大。</p>
<p>####声道数<br>是指处理的声音是单声道还是立体声。单声道在声音处理过程中只有单数据流，而立体声则需要左、右声道的两个数据流。显然，立体声的效果要好，但相应的数据量要比单声道的数据量加倍。</p>
<p>####声音数据量的计算公式为：<br>数据量（字节/秒）= (采样频率（Hz）× 采样位数（bit） × 声道数)/ 8</p>
<p><em>单声道的声道数为1，立体声的声道数为2。</em></p>
<p>【例1】请计算对于5分钟双声道、16位采样位数、44.1kHz采样频率声音的不压缩数据量是多少？<br>根据公式：数据量=（采样频率×采样位数×声道数×时间）/8<br>得，数据量(MB)=[44.1×1000×16×2×（5×60）] /（8×1024×1024）=50.47MB<br>计算时要注意几个单位的换算细节：<br>时间单位换算：1分=60秒<br>采样频率单位换算：1kHz=1000Hz<br>数据量单位换算：1MB=1024×1024=1048576B</p>
<p>【例2】请计算对于双声道立体声、采样频率为44.1kHz、采样位数为16位的激光唱盘（CD-A），用一个650MB的CD-ROM可存放多长时间的音乐？<br>已知音频文件大小的计算公式如下：<br>文件的字节数/每秒=采样频率（Hz）X采样位数（位）X声道数/8<br>根据上面的公式计算一秒钟时间内的不压缩数据量：(44.1×1000×16×2)/8=0.168MB/s<br>那么，一个650MB的CD-ROM可存放的时间为：（650/0.168）/（60×60）=1.07小时。</p>
<hr>
<p>##IOS 音频转码 ##</p>
<p>音频转码使用的框架为：AudioToolBox</p>
<p>###内存转码： ###<br>    使用函数： AudioConverterFillComplexBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">    - (void)handleAudioPackets:(const void *)inputData</span><br><span class="line">             numberOfBytes:(UInt32)numberOfBytes</span><br><span class="line">           numberOfPackets:(UInt32)numberOfPackets</span><br><span class="line">        packetDescriptions:(AudioStreamPacketDescription *)packetDescriptions</span><br><span class="line">&#123;</span><br><span class="line">    if (!_audioFileStream || !_parseAudioHeader || !_decodeConverterRef) return;</span><br><span class="line">    </span><br><span class="line">    AudioConvertInfo convertInfo = (AudioConvertInfo)&#123;</span><br><span class="line">        .done = NO,</span><br><span class="line">        .numberOfPackets = numberOfPackets,</span><br><span class="line">        .packetDescriptions = packetDescriptions,</span><br><span class="line">        .audioBuffer = (AudioBuffer)&#123;</span><br><span class="line">            .mData = (void *)inputData,</span><br><span class="line">            .mDataByteSize = numberOfBytes,</span><br><span class="line">            .mNumberChannels = _sourceAsbd.mChannelsPerFrame</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    AudioBufferList decodedData;</span><br><span class="line">    decodedData.mNumberBuffers = 1;</span><br><span class="line">    decodedData.mBuffers[0].mNumberChannels = _canonicalAsbd.mChannelsPerFrame;</span><br><span class="line">    decodedData.mBuffers[0].mDataByteSize = _decodeBufferSize;</span><br><span class="line">    decodedData.mBuffers[0].mData = _decodeBuffer;</span><br><span class="line">    </span><br><span class="line">    UInt32 ioOutputDataPackets1, ioOutputDataPackets2;</span><br><span class="line">    OSStatus decodingStatus, encodingStatus;</span><br><span class="line">    </span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        ioOutputDataPackets1 = numberOfPackets;</span><br><span class="line">        </span><br><span class="line">        decodingStatus = AudioConverterFillComplexBuffer(_decodeConverterRef, AudioConverterCallback, (void*)&amp;convertInfo, &amp;ioOutputDataPackets1, &amp;decodedData, NULL);</span><br><span class="line">        </span><br><span class="line">        if (decodingStatus == OS_STATUS_DONE || decodingStatus == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ioOutputDataPackets1 &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // Start encoding</span><br><span class="line">                </span><br><span class="line">                AudioConvertInfo encodeConvertInfo = (AudioConvertInfo)&#123;</span><br><span class="line">                    .done = NO,</span><br><span class="line">                    .numberOfPackets = ioOutputDataPackets1,</span><br><span class="line">                    .packetDescriptions = NULL,</span><br><span class="line">                    .audioBuffer = (AudioBuffer)&#123;</span><br><span class="line">                        .mData = decodedData.mBuffers[0].mData,</span><br><span class="line">                        .mDataByteSize = decodedData.mBuffers[0].mDataByteSize,</span><br><span class="line">                        .mNumberChannels = _canonicalAsbd.mChannelsPerFrame</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                </span><br><span class="line">                AudioBufferList encodedData;</span><br><span class="line">                encodedData.mNumberBuffers = 1;</span><br><span class="line">                encodedData.mBuffers[0].mNumberChannels = _destinationAsbd.mChannelsPerFrame;</span><br><span class="line">                encodedData.mBuffers[0].mDataByteSize = _encodeBufferSize;</span><br><span class="line">                encodedData.mBuffers[0].mData = _encodeBuffer;</span><br><span class="line">                </span><br><span class="line">                while (1)</span><br><span class="line">                &#123;</span><br><span class="line">                    ioOutputDataPackets2 = _encodePacketsPerBuffer;</span><br><span class="line">                    </span><br><span class="line">                    encodingStatus = AudioConverterFillComplexBuffer(_encodeConverterRef, AudioConverterCallback, (void*)&amp;encodeConvertInfo, &amp;ioOutputDataPackets2, &amp;encodedData, _encodePacketDescriptions);</span><br><span class="line">                    </span><br><span class="line">                    if (encodingStatus == OS_STATUS_DONE || encodingStatus == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //一个buffer 转码成功</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        [self failureOccurred];</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (encodingStatus == OS_STATUS_DONE)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // End encoding</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [self failureOccurred];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (decodingStatus == OS_STATUS_DONE)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件转码"><a href="#文件转码" class="headerlink" title="文件转码"></a>文件转码</h3><pre><code>使用函数 ExtAudioFileRead
</code></pre><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> startConvert(ExtAudioConverterSettings* settings)&#123;</span><br><span class="line">    <span class="comment">//Determine the proper buffer size and calculate number of packets per buffer</span></span><br><span class="line">    <span class="comment">//for CBR and VBR format</span></span><br><span class="line">    <span class="built_in">UInt32</span> sizePerBuffer = <span class="number">32</span>*<span class="number">1024</span>;<span class="comment">//32KB is a good starting point</span></span><br><span class="line">    <span class="built_in">UInt32</span> framesPerBuffer = sizePerBuffer/<span class="keyword">sizeof</span>(SInt16);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allocate destination buffer</span></span><br><span class="line">    SInt16 *outputBuffer = (SInt16 *)malloc(<span class="keyword">sizeof</span>(SInt16) * sizePerBuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        AudioBufferList outputBufferList;</span><br><span class="line">        outputBufferList.mNumberBuffers              = <span class="number">1</span>;</span><br><span class="line">        outputBufferList.mBuffers[<span class="number">0</span>].mNumberChannels = settings-&gt;outputFormat.mChannelsPerFrame;</span><br><span class="line">        outputBufferList.mBuffers[<span class="number">0</span>].mDataByteSize   = sizePerBuffer;</span><br><span class="line">        outputBufferList.mBuffers[<span class="number">0</span>].mData           = outputBuffer;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UInt32</span> framesCount = framesPerBuffer;</span><br><span class="line">        </span><br><span class="line">        CheckError(ExtAudioFileRead(settings-&gt;inputFile,</span><br><span class="line">                                    &amp;framesCount,</span><br><span class="line">                                    &amp;outputBufferList),</span><br><span class="line">                   <span class="string">"ExtAudioFileRead failed"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (framesCount==<span class="number">0</span>) &#123;</span><br><span class="line">            printf(<span class="string">"Done reading from input file\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CheckError(ExtAudioFileWrite(settings-&gt;outputFile,</span><br><span class="line">                                     framesCount,</span><br><span class="line">                                     &amp;outputBufferList),</span><br><span class="line">                   <span class="string">"ExtAudioFileWrite failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a><a href="http://download.csdn.net/download/qihongru1227/9326777" target="_blank" rel="noopener">代码下载</a></h3><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p><a href="https://developer.apple.com/library/ios/documentation/MusicAudio/Conceptual/CoreAudioOverview/SupportedAudioFormatsMacOSX/SupportedAudioFormatsMacOSX.html" target="_blank" rel="noopener">苹果官网</a></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="water">
          <p class="site-author-name" itemprop="name">water</p>
           
              <p class="site-description motion-element" itemprop="description">不积跬步，无以致千里；不积小流，无以成江海。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">water</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
