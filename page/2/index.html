<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">


























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false,"dimmer":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
<meta property="og:type" content="website">
<meta property="og:title" content="hongru&#39;s 博客">
<meta property="og:url" content="https://hongruqi.github.io/page/2/index.html">
<meta property="og:site_name" content="hongru&#39;s 博客">
<meta property="og:description" content="不积跬步，无以致千里；不积小流，无以成江海。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hongru&#39;s 博客">
<meta name="twitter:description" content="不积跬步，无以致千里；不积小流，无以成江海。">



  <link rel="alternate" href="/atom.xml" title="hongru's 博客" type="application/atom+xml">




  <link rel="canonical" href="https://hongruqi.github.io/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>hongru's 博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hongru's 博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">重剑无锋，大巧不工</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>About</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/23/iOS 保证线程同步方式 & 性能对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hongru's 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/07/23/iOS 保证线程同步方式 & 性能对比/" class="post-title-link" itemprop="url">iOS 保证线程同步方式 & 性能对比</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-07-23 00:00:00" itemprop="dateCreated datePublished" datetime="2016-07-23T00:00:00+08:00">2016-07-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-22 15:56:59" itemprop="dateModified" datetime="2019-02-22T15:56:59+08:00">2019-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-保证线程同步方式-amp-性能对比"><a href="#iOS-保证线程同步方式-amp-性能对比" class="headerlink" title="iOS 保证线程同步方式 &amp; 性能对比"></a>iOS 保证线程同步方式 &amp; 性能对比</h1><p>##背景<br>IOS中保持线程同步的常用技术：</p>
<ul>
<li>@synchronized </li>
<li>NSLock</li>
<li>NSRecursiveLock</li>
<li>dispatch_semaphore</li>
<li>NSCondition</li>
<li>pthread_mutex</li>
<li>OSSpinLock。<br>他们的实现机制各不相同，性能也各不一样。而我们平时用的最多的@synchronized是性能最差的。<blockquote>
<p>本人开发时候，第一选择为NSRecursiveLock.</p>
</blockquote>
</li>
</ul>
<p>下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p>
<h2 id="介绍与使用"><a href="#介绍与使用" class="headerlink" title="介绍与使用"></a>介绍与使用</h2><p>###<strong>@synchronized</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(obj) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>);</span><br><span class="line">         sleep(<span class="number">3</span>); </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>);</span><br><span class="line">     &#125; </span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    sleep(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">@synchronized</span>(obj) &#123; </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作2"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。<br>上面结果的执行结果为：<br>2016-07-23 09:40:24.051 ThreadTest[13438:385647] 需要线程同步的操作1 开始<br>2016-07-23 09:40:27.054 ThreadTest[13438:385647] 需要线程同步的操作1 结束<br>2016-07-23 09:40:27.054 ThreadTest[13438:385646] 需要线程同步的操作2</p>
<p>##dispatch_semaphore<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_semaphore_t signal = dispatch_semaphore_create(<span class="number">1</span>); </span><br><span class="line">dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(signal, overTime); </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>); </span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>);</span><br><span class="line">        dispatch_semaphore_signal(signal); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">        dispatch_semaphore_wait(signal, overTime); </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作2"</span>); </span><br><span class="line">        dispatch_semaphore_signal(signal); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p>
<ol>
<li><strong>dispatch_semaphore_create的声明为：</strong><br>　　dispatch_semaphore_t  dispatch_semaphore_create(long value);<br>　　传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。<br>　　值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</li>
<li><strong>dispatch_semaphore_signal的声明为：</strong><br>　　long dispatch_semaphore_signal(dispatch_semaphore_t dsema)<br>　　这个函数会使传入的信号量dsema的值加1；</li>
<li><strong>dispatch_semaphore_wait的声明为：</strong><br>　　long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；<br>　　这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。<br>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。<br>如上的代码，如果超时时间overTime设置成&gt;2，可完成同步操作。如果overTime&lt;2的话，在线程1还没有执行完成的情况下，此时超时了，将自动执行下面的代码。<br>上面代码的执行结果为：<br>2016-07-23 09:53:00.898 ThreadTest[13507:391586]  需要线程同步的操作 1  开始<br>2016-07-23 09:53:02.903 ThreadTest[13507:391586]  需要线程同步的操作 1  结束<br>2016-07-23 09:53:02.904 ThreadTest[13507:391578]  需要线程同步的操作 2<br>如果把超时时间设置为&lt;2s的时候，执行的结果就是：<br>2016-07-23 09:54:04.499 ThreadTest[13518:392236]  需要线程同步的操作 1 开始<br>2016-07-23 09:54:06.002 ThreadTest[13518:392247]  需要线程同步的操作 2<br>2016-07-23 09:54:06.505 ThreadTest[13518:392236]  需要线程同步的操作 1 结束</li>
</ol>
<p>##NSLock<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="comment">//[lock lock]; </span></span><br><span class="line">    [lock lockBeforeDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>); </span><br><span class="line">    sleep(<span class="number">2</span>); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>); </span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ([lock tryLock]) &#123;</span><br><span class="line">        <span class="comment">//尝试获取锁，如果获取不到返回NO，不会阻塞该线程 </span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"锁可用的操作"</span>); </span><br><span class="line">        [lock unlock]; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"锁不可用的操作"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDate</span> *date = [[<span class="built_in">NSDate</span> alloc] initWithTimeIntervalSinceNow:<span class="number">3</span>]; </span><br><span class="line">    <span class="keyword">if</span> ([lock lockBeforeDate:date]) &#123;</span><br><span class="line">          <span class="comment">//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"没有超时，获得锁"</span>); </span><br><span class="line">          [lock unlock]; </span><br><span class="line">     &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"超时，没有获得锁"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。<br>上面代码的执行结果为：<br> 2016-07-23 10:01:06.165 ThreadTest[13541:394814]  需要线程同步的操作 1  开始<br> 2016-07-23 10:01:07.169 ThreadTest[13541:394804]  锁不可用的操作<br> 2016-07-23 10:01:08.168 ThreadTest[13541:394814]  需要线程同步的操作 1  结束<br> 2016-07-23 10:01:08.168 ThreadTest[13541:394804]  没有超时，获得锁<br>源码定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSLocking</span></span></span><br><span class="line">- (<span class="keyword">void</span>)lock;</span><br><span class="line">- (<span class="keyword">void</span>)unlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">@private</span> <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>##<strong>NSRecursiveLock递归锁</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSLock *lock = [[NSLock alloc] init];</span></span><br><span class="line"><span class="built_in">NSRecursiveLock</span> *lock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> (^RecursiveMethod)(<span class="keyword">int</span>); </span><br><span class="line">    RecursiveMethod = ^(<span class="keyword">int</span> value) &#123; </span><br><span class="line">        [lock lock]; </span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"value = %d"</span>, value); </span><br><span class="line">            sleep(<span class="number">1</span>); </span><br><span class="line">            RecursiveMethod(value - <span class="number">1</span>); </span><br><span class="line">      &#125; </span><br><span class="line">        [lock unlock]; </span><br><span class="line">    &#125;;</span><br><span class="line">     RecursiveMethod(<span class="number">5</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。如果使用NSLock，每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：<br>2016-07-23 10:09:50.932 ThreadTest[13568:398209] value = 5<br>2016-07-23 10:09:51.933 ThreadTest[13568:398209]  -[NSLock lock]: deadlock (&lt;NSLock: 0x7ff58a60b190&gt; ‘(null)’)<br>2016-07-23 10:09:51.934 ThreadTest[13568:398209]   Break on _NSLockError() to debug.<br>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。<br>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。<br> 2016-07-23 10:13:08.465 ThreadTest[13593:400360] value = 5<br> 2016-07-23 10:13:09.468 ThreadTest[13593:400360] value = 4<br> 2016-07-23 10:13:10.472 ThreadTest[13593:400360] value = 3<br> 2016-07-23 10:13:11.474 ThreadTest[13593:400360] value = 2<br> 2016-07-23 10:13:12.478 ThreadTest[13593:400360] value = 1<br>如果需要其他功能，源码定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSRecursiveLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">@private</span> </span><br><span class="line">    <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>##<strong>NSConditionLock条件锁</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSConditionLock</span> *lock = [[<span class="built_in">NSConditionLock</span> alloc] init];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *products = [<span class="built_in">NSMutableArray</span> array]; </span><br><span class="line"><span class="built_in">NSInteger</span> HAS_DATA = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">NSInteger</span> NO_DATA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">        [lock lockWhenCondition:NO_DATA]; </span><br><span class="line">        [products addObject:[[<span class="built_in">NSObject</span> alloc] init]]; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"produce a product,总量:%zi"</span>,products.count); </span><br><span class="line">        [lock unlockWithCondition:HAS_DATA]; </span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"wait for product"</span>); </span><br><span class="line">         [lock lockWhenCondition:HAS_DATA]; </span><br><span class="line">         [products removeObjectAtIndex:<span class="number">0</span>]; </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"custome a product"</span>); </span><br><span class="line">         [lock unlockWithCondition:NO_DATA]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：<br>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。<br>上面代码执行结果如下：<br>2016-07-23 10:30:00.764 ThreadTest[13645:406942] wait for product<br>2016-07-23 10:30:00.764 ThreadTest[13645:406951] produce a product,  总量 :1<br>2016-07-23 10:30:00.765 ThreadTest[13645:406942] custome a product<br>2016-07-23 10:30:00.765 ThreadTest[13645:406942] wait for product<br>2016-07-23 10:30:01.767 ThreadTest[13645:406951] produce a product, 总量:1<br>2016-07-23 10:30:01.767 ThreadTest[13645:406942] custome a product<br>如果你需要其他功能，源码定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSConditionLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">@private</span> </span><br><span class="line">    <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCondition:(<span class="built_in">NSInteger</span>)condition <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> condition;</span><br><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="keyword">void</span>)unlockWithCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>##<strong>NSCondition</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSCondition</span> *condition = [[<span class="built_in">NSCondition</span> alloc] init]; </span><br><span class="line"><span class="built_in">NSMutableArray</span> *products = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">        [condition lock]; </span><br><span class="line">        <span class="keyword">if</span> ([products count] == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"wait for product"</span>); </span><br><span class="line">           [condition wait]; </span><br><span class="line">       &#125;</span><br><span class="line">      [products removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"custome a product"</span>); </span><br><span class="line">      [condition unlock]; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">         [condition lock]; </span><br><span class="line">        [products addObject:[[<span class="built_in">NSObject</span> alloc] init]]; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"produce a product,总量:%zi"</span>,products.count); </span><br><span class="line">        [condition signal]; </span><br><span class="line">        [condition unlock]; </span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>一种最基本的条件锁。手动控制线程wait和signal。<br>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问[condition unlock];与lock 同时使用[condition wait];让当前线程处于等待状态[condition signal];CPU发信号告诉线程不用在等待，可以继续执行。<br>上面代码执行结果如下：<br>2016-07-23 10:37:46.943 ThreadTest[13693:409659] wait for product<br>2016-07-23 10:37:46.944 ThreadTest[13693:409667] produce a product, 总量 :1<br>2016-07-23 10:37:46.944 ThreadTest[13693:409659] custome a product<br>2016-07-23 10:37:46.945 ThreadTest[13693:409659] wait for product<br>2016-07-23 10:37:47.947 ThreadTest[13693:409667] produce a product, 总量 :1<br>2016-07-23 10:37:47.947 ThreadTest[13693:409659] custome a product</p>
<p>##<strong>pthread_mutex</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__block pthread_mutex_t theLock; </span><br><span class="line">pthread_mutex_init(&amp;theLock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    pthread_mutex_lock(&amp;theLock); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>); </span><br><span class="line">    sleep(<span class="number">3</span>); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>); </span><br><span class="line">    pthread_mutex_unlock(&amp;theLock); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    sleep(<span class="number">1</span>); </span><br><span class="line">    pthread_mutex_lock(&amp;theLock); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作2"</span>); </span><br><span class="line">    pthread_mutex_unlock(&amp;theLock); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>c语言定义下多线程加锁方式。</p>
<ol>
<li>pthread_mutex_init(<strong>pthread_mutex_t</strong> <em> mutex,const pthread_mutexattr_t </em>attr);初始化锁变量mutex。attr为锁属性，NULL值为默认属性。</li>
<li>pthread_mutex_lock(<strong>pthread_mutex_t</strong> *mutex);加锁</li>
<li>pthread_mutex_tylock(<strong>pthread_mutex_t</strong> *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。</li>
<li>pthread_mutex_unlock(<strong>pthread_mutex_t</strong> *mutex);释放锁</li>
<li>pthread_mutex_destroy(<strong>pthread_mutex_t</strong> *mutex);使用完后释放</li>
</ol>
<p>代码执行操作结果如下：<br>2016-07-23 10:45:05.864 ThreadTest[13725:412938]  需要线程同步的操作 1  开始<br>2016-07-23 10:45:08.867 ThreadTest[13725:412938]  需要线程同步的操作 1  结束<br>2016-07-23 10:45:08.867 ThreadTest[13725:412931]  需要线程同步的操作 2</p>
<h2 id="pthread-mutex-recursive"><a href="#pthread-mutex-recursive" class="headerlink" title="pthread_mutex(recursive)"></a><strong>pthread_mutex(recursive)</strong></h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__block pthread_mutex_t theLock; </span><br><span class="line"><span class="comment">//pthread_mutex_init(&amp;theLock, NULL);</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr); </span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); </span><br><span class="line">pthread_mutex_init(&amp;theLock, &amp;attr); </span><br><span class="line">pthread_mutexattr_destroy(&amp;attr); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> (^RecursiveMethod)(<span class="keyword">int</span>); </span><br><span class="line">    RecursiveMethod = ^(<span class="keyword">int</span> value) &#123; </span><br><span class="line">         pthread_mutex_lock(&amp;theLock); </span><br><span class="line">         <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123; </span><br><span class="line">             <span class="built_in">NSLog</span>(<span class="string">@"value = %d"</span>, value); </span><br><span class="line">             sleep(<span class="number">1</span>); </span><br><span class="line">             RecursiveMethod(value - <span class="number">1</span>); </span><br><span class="line">     &#125;</span><br><span class="line">      pthread_mutex_unlock(&amp;theLock); </span><br><span class="line">   &#125;;</span><br><span class="line">      RecursiveMethod(<span class="number">5</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。<br>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p>
<p>##OSSpinLock<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__block OSSpinLock theLock = OS_SPINLOCK_INIT;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    OSSpinLockLock(&amp;theLock); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>); </span><br><span class="line">    sleep(<span class="number">3</span>); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>);</span><br><span class="line">    OSSpinLockUnlock(&amp;theLock);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">     OSSpinLockLock(&amp;theLock); </span><br><span class="line">     sleep(<span class="number">1</span>); </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作2"</span>); </span><br><span class="line">     OSSpinLockUnlock(&amp;theLock);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客<a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a>中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p>
<p>#性能对比<br>对以上各个锁进行1000000次的加锁解锁的空操作时间如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>1000000消耗时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>OSSpinLock</td>
<td>46.15 ms</td>
</tr>
<tr>
<td>dispatch_semaphore</td>
<td>56.50 ms</td>
</tr>
<tr>
<td>pthread_mutex</td>
<td>178.28 ms</td>
</tr>
<tr>
<td>NSCondition</td>
<td>193.38 ms</td>
</tr>
<tr>
<td>NSLock</td>
<td>175.02 ms</td>
</tr>
<tr>
<td>pthread_mutex(recursive):</td>
<td>172.56 ms</td>
</tr>
<tr>
<td>NSRecursiveLock</td>
<td>157.44 ms</td>
</tr>
<tr>
<td>NSConditionLock:</td>
<td>490.04 ms</td>
</tr>
<tr>
<td>@synchronized</td>
<td>371.17 ms</td>
</tr>
</tbody>
</table>
<p>总的来说：<br>OSSpinLock和dispatch_semaphore的效率远远高于其他。<br>@synchronized和NSConditionLock效率较差。<br>鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。<br>如果不考虑性能，只是图个方便的话，那就使用@synchronized。<br>使用NSRecursiveLock，可以避免死锁，同时性能也不错，建议代码中使用。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/22/iOS 手势详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hongru's 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/07/22/iOS 手势详解/" class="post-title-link" itemprop="url">iOS 手势详解</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-07-22 00:00:00" itemprop="dateCreated datePublished" datetime="2016-07-22T00:00:00+08:00">2016-07-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-22 15:55:46" itemprop="dateModified" datetime="2019-02-22T15:55:46+08:00">2019-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-手势详解"><a href="#iOS-手势详解" class="headerlink" title="iOS 手势详解"></a>iOS 手势详解</h1><h2 id="手势识别"><a href="#手势识别" class="headerlink" title="##手势识别"></a>##手势识别</h2><p>手势识别器将抽像度低的事件操作转化为更容易理解的动作，它们是附加在视图上的对象，并允许对这些动作进行回应。手势识别器解释这些触摸事件是否是一个特定的手势，比如轻扫，缩放，旋转。如果它们能正确识别，它们会发送一个动作给目标对象。这个对象是你指定的视图控制器，如下图所示。这样的设计模式强大简单，你可以动态指定响应动作，而且你可以添加一个手势识别给一个视图，而不用子类化视图。<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gestureRecognizer_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gestureRecognizer_2x.png" alt="一个附加在视图上的手势识别"></a></p>
<p>##使用手势识别简化事件操作<br>UIKit 框架提供了预先定义的一些常用手势定义。它提供的预定义手势，大大简化了你自己去写识别代码,而且用标准的识别可以确保你的APP可以正确识别用户所期望的内容。<br>如果你想自己定义一个不一样的手势，比如对勾或圈圈，你可以创建属于你自己的手势识别。如果设计和实现这些专属的手势识别，可以看这里 <a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW44" target="_blank" rel="noopener">创建一个定制的手势识别</a><br>内嵌的常用手势识别<br>下表是UIKit 框架自带的手势类别</p>
<table>
<thead>
<tr>
<th>手势</th>
<th>UIKit class</th>
</tr>
</thead>
<tbody>
<tr>
<td>点击 (Tapping (any number of taps))</td>
<td>UITapGestureRecognizer</td>
</tr>
<tr>
<td>捏合 (Pinching in and out (for zooming a view))</td>
<td>UIPinchGestureRecognizer</td>
</tr>
<tr>
<td>滑动或拖动 (Panning or dragging)</td>
<td>UIPanGestureRecognizer</td>
</tr>
<tr>
<td>轻扫 (Swiping (in any direction))</td>
<td>UISwipeGestureRecognizer</td>
</tr>
<tr>
<td>旋转 (Rotating (fingers moving in opposite directions))</td>
<td>UIRotationGestureRecognizer</td>
</tr>
<tr>
<td>长按 (Long press (also known as “touch and hold”))</td>
<td>UILongPressGestureRecognizer</td>
</tr>
</tbody>
</table>
<p>你必须遵循苹果的规范去正确响应用户的手势操作 , 见 <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/index.html#//apple_ref/doc/uid/TP40006556" target="_blank" rel="noopener">iOS Human Interface Guidelines</a></p>
<p>##手势附加在一个视图上<br>任何手势都和一个视图相关联，不过，一个视图可以有多个手势，因为一个视图可能会响应多个不同的手势。为了一个视图能识别特殊的手势，你必须附加手势识别到这个视图上。当用户触摸这个视图时，手势识别会在视图动作前收到触摸的消息，然后手势可以应答这个消息。</p>
<ul>
<li>手势触发动作信息<br>当手势识别器识别它特定的手势，它会发送一个动作消息给它的对象。要创建一个手势识别，我要实例化它并附加一个对象和动作</li>
<li>离散和连续的手势<br>手势是离散或者连续的。一个离散的手势，比如轻击，只发生一次。一个连续的手势，比如捏合，是在一段时间内发生。对于离散的手势，手势识别器只发送一个单一的动作消息给对象。而一个连续的手势会持续的发送动作消息给它的对象直到多点触摸结束，正如下图所示：<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/discrete_vs_continuous_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/discrete_vs_continuous_2x.png" alt="离散和连续的手势"></a></li>
</ul>
<p>##响应手势识别事件<br>要添加一个手势给你的APP有三件事情是你要去做的<br>创建和配置一个手势识别实例 这一步包括附值一个目标对象，动作，有时还会要指定特定的手势属性(比如 numberOfTapsRequired)<br>附加这个手势识别器给视图<br>实现响应这个动作的方法</p>
<p>使用 Interface Builder 附加手势<br>PS: 用的不多，大家有空自己看苹果官方文档吧</p>
<p>编码方式添加手势识别<br>你可以通过allocating 和 initializing 来实例化 UIGestureRecognizer 的子类，比如UIPinchGestureRecognizer.<br>如果你创建这个实例化对象后，你需要通过 addGestureRecognizer: 方法附加给一个 View. 下面是一个示例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">    <span class="comment">// Create and initialize a tap gesture </span></span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *tapRecognizer =</span><br><span class="line">    [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(respondToTapGesture:)];</span><br><span class="line">    <span class="comment">// Specify that the gesture must be a single tap</span></span><br><span class="line">    tapRecognizer.numberOfTapsRequired = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Add the tap gesture recognizer to the view </span></span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:tapRecognizer];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##响应离散的手势<br>当你创建了手势识别并添加了 action 方法后，你就可以用此方法去响应手势操作。下面的代码是一个响应视图点击并通过 locationInView: 方法定位显示图片的例子<br>原码在这里: <a href="https://developer.apple.com/library/ios/samplecode/SimpleGestureRecognizers/Introduction/Intro.html#//apple_ref/doc/uid/DTS40009460" target="_blank" rel="noopener">Simple Gesture Recognizers</a></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)showGestureForTapRecognizer:(<span class="built_in">UITapGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">     <span class="comment">// Get the location of the gesture </span></span><br><span class="line">    <span class="built_in">CGPoint</span> location = [recognizer locationInView:<span class="keyword">self</span>.view]; </span><br><span class="line">    <span class="comment">// Display an image view at that location </span></span><br><span class="line">    [<span class="keyword">self</span> drawImageForGestureRecognizer:recognizer atPoint:location];</span><br><span class="line">    <span class="comment">// Animate the image view so that it fades out</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.alpha = <span class="number">0.0</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个手势都有它特定的一些属性，比如下面的例子， showGestureForSwipeRecognizer: 方法使用 swipe 手势识别的 direction属性来判断用户滑动的方向是左还是右。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Respond to a swipe gesture</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)showGestureForSwipeRecognizer:(<span class="built_in">UISwipeGestureRecognizer</span> *)recognizer &#123; </span><br><span class="line">    <span class="comment">// Get the location of the gesture </span></span><br><span class="line">    <span class="built_in">CGPoint</span> location = [recognizer locationInView:<span class="keyword">self</span>.view]; </span><br><span class="line">    <span class="comment">// Display an image view at that location </span></span><br><span class="line">    [<span class="keyword">self</span> drawImageForGestureRecognizer:recognizer atPoint:location]; </span><br><span class="line">    <span class="comment">// If gesture is a left swipe, specify an end location </span></span><br><span class="line">   <span class="comment">// to the left of the current location </span></span><br><span class="line">   <span class="keyword">if</span> (recognizer.direction == <span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>) &#123;</span><br><span class="line">      location.x -= <span class="number">220.0</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      location.x += <span class="number">220.0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Animate the image view in the direction of the swipe as it fades out</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">         <span class="keyword">self</span>.imageView.alpha = <span class="number">0.0</span>; </span><br><span class="line">         <span class="keyword">self</span>.imageView.center = location; </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##响应一个连续的手势<br>连续手势允许你的app响应手势正在发生的过程，例如，你可以在用户捏合时放大或缩小，或允许用户在屏幕在拖动对象<br>下面的例子显示当用户旋转手势时，将显示一个旋转后的图片。当用户手势放开时，将淡出并将图片回到水平方向。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Respond to a rotation gesture</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)showGestureForRotationRecognizer:(<span class="built_in">UIRotationGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">    <span class="comment">// Get the location of the gesture </span></span><br><span class="line">    <span class="built_in">CGPoint</span> location = [recognizer locationInView:<span class="keyword">self</span>.view]; </span><br><span class="line">    <span class="comment">// Set the rotation angle of the image view to </span></span><br><span class="line">    <span class="comment">// match the rotation of the gesture </span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform =</span><br><span class="line">    <span class="built_in">CGAffineTransformMakeRotation</span>([recognizer rotation]);</span><br><span class="line">    <span class="keyword">self</span>.imageView.transform = transform;</span><br><span class="line">    <span class="comment">// Display an image view at that location </span></span><br><span class="line">    [<span class="keyword">self</span> drawImageForGestureRecognizer:recognizer atPoint:location];</span><br><span class="line">    <span class="comment">// If the gesture has ended or is canceled, begin the animation </span></span><br><span class="line">    <span class="comment">// back to horizontal and fade out </span></span><br><span class="line">    <span class="keyword">if</span> (([recognizer state] == <span class="built_in">UIGestureRecognizerStateEnded</span>||</span><br><span class="line">        ([recognizer state] == <span class="built_in">UIGestureRecognizerStateCancelled</span>)) &#123;</span><br><span class="line">         [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">               <span class="keyword">self</span>.imageView.alpha = <span class="number">0.0</span>; </span><br><span class="line">               <span class="keyword">self</span>.imageView.transform = <span class="built_in">CGAffineTransformIdentity</span>; </span><br><span class="line">        &#125;];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每次方法调用，在 drawImageForGestureRecognizer: 方法里都会被设置为不透明。当用户手势完成时，图片又会在 animateWithDuration: 方法里设置为透明。这个 showGestureForRotationRecognizer: 方法会持续检测手势状态。关于这个状态解释可以查看下面的 “手势状态机”。<br>如何定义手势识别交互转换<br>常常当你添加手势识别到你的app 后，如果你想要在与其它触摸事件之间做特定的交互时，你首先要理解一下更多关于手势识别工作的细节。<br>有限状态机中的手势识别<br>下图中，所有的手势开始于 Possible 状态 (UIGestureRecognizerStatePossible)，它们分析收到的多次触摸序列，然后决定转化为 fail 状态或其它状态.<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gr_state_transitions_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gr_state_transitions_2x.png" alt="手势识别状态机"></a><br>当一个离散的手势识别器识别它是这样的手势后，它会将它的状态从 Possible 变为 Recognized (UIGestureRecognizerStateRecognized) ，然后识别完成。<br>对于连续的手势第一次识别时，将状态从 Possible 变为 Began (UIGestureRecognizerStateBegan). 然后，它再将状态从 Began 变为 Changed (UIGestureRecognizerStateChanged), 然后在手势发生时持续的将状态从 Changed 变为 Changed。直到用户的手指从视图离开，手势状态转变为 Ended (UIGestureRecognizerStateEnded)，然后手势识别完成.<br>如果你不想长时间适配手势，也只可以将一个连续的手势也可以从 Changed 变为 Canceled (UIGestureRecognizerStateCancelled)。<br>所有的时候，每次手势状态的改变，手势识别器都会发送一个 action message 给它的目标，除非它的状态是 Failed 或 Canceled.所以一个离散的手势，当从 Possible 到 Recognized 时 只发送一次 action message . 而一个连续的手势在状态变化时会发送很多 action message。<br>当手势识别状态变为 Recognized (或 Ended)状态时，它会重置经的状态为 Possible. 这个转化不会触发 action message.<br>和其它手势交互<br>一个视图可以有多个手势识别附加给它，你可以使用视图的 gestureRecognizers 属性来看有多少手势识别器，你也可以动态的添加或删除手势识别器，通过 addGestureRecognizer: 和 removeGestureRecognizer: 方法。<br>当一个视图有多个手势识别附加给它时，你可能想去解决他们产生的识别冲突。默认的情况下接收到触摸后，它们是没办法设定定顺序的，不过你可以覆盖这些默认的行为:<br>指定一个手势在识别时应该分析其它的手势识别<br>允许两个手势识别同时操作<br>通过触摸分析避免手势识别</p>
<p>使用 UIGestureRecognizer 类方法，delegate methods 或 子类化覆盖方法来达到这样的效果<br>声明指定两个手势的识别顺序<br>想象一下你想识别两种手势 swipe 与 pan 。你想区别这两种手势所触发的 action. 默认情况时，你的 swipe 手势会被识别为 pan . 这是因为它的手势必要条件被解释为了 pan 手势。<br>所以你可以显示的指明它们之间的关系，通过调用 requireGestureRecognizerToFail: 方法如下面所示<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123; </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib</span></span><br><span class="line">    [<span class="keyword">self</span>.panRecognizer requireGestureRecognizerToFail:</span><br><span class="line">    <span class="keyword">self</span>.swipeRecognizer];&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法指明只有其它的手势失败时才会让它自己开始识别。<br>注意如果你有单击与双击手势识别时，不能设定单击需要在双击失败时进行，因为这不符合苹果设计规范，也许用户就只是想单击而已</p>
<p>##通过分析触摸来避免手势识别<br>你可以修改手势行为，通过添加一个 delegate 对象去体质手势识别。这个 UIGestureRecognizerDelegate 协议支持多种办法分析触摸避免识别。你可以识别 gestureRecognizer:shouldReceiveTouch: 方法或 gestureRecognizerShouldBegin: 方法，这两个方法都是 UIGestureRecognizerDelegate 协议里可选的<br>当手势触摸开始，如果你想立即决定是否识别本次触摸，使用 gestureRecognizer:shouldReceiveTouch: 方法，这个方法每次触摸都发被调用。返回 NO 避免识别，返回 YES 不会修改手势识别状态。<br>下面的例子使用 gestureRecognizer:shouldReceiveTouch: 代理方法避免收到触摸手势在定制的 subview 后识别<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">    <span class="comment">// Add the delegate to the tap gesture recognizer</span></span><br><span class="line">    <span class="keyword">self</span>.tapGestureRecognizer.delegate = <span class="keyword">self</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// Implement the UIGestureRecognizerDelegate method</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">       shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch &#123; </span><br><span class="line">     <span class="comment">// Determine if the touch is inside the custom subview</span></span><br><span class="line">     <span class="keyword">if</span> ([touch view] == <span class="keyword">self</span>.customSubview)&#123; </span><br><span class="line">     <span class="comment">// If it is, prevent all of the delegate's gesture recognizers</span></span><br><span class="line">     <span class="comment">// from receiving the touch </span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>gestureRecognizer:shouldReceiveTouch: 与 gestureRecognizerShouldBegin: 的区别是，shouldReceiveTouch 会拿到 touch 事件，决定是否开始识别，而 gestureRecognizerShouldBegin 是准备改变手势状态时，你可以通过识别的情况来决定是否转化。shouldReceiveTouch 会最先回调。</p>
<p>##允许同时响应手势识别<br>默认的情况时，同一时间两个手势不能同时被识别。但有一种情况下，比如你想用户在缩放视图时同时旋转同时进行。你需要改变他的默认行为了。 可以用 gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer: 这个 UIGestureRecognizerDelegate 协议里的方法。这个方法会在判定是否阻止一个方法在识别时，同时阻止另一个的识别。默认它会返回 NO. 返回 YES 的会你可以让两个手势同时识别。<br>注意：虽然返回 YES 可以让两个手势同时被识别，但设置为 NO 不一定它不会被同时识别，因为也许另一个手势的 delegate 里会设置为 YES</p>
<p>##指定两个手势之间的单向关系<br>如果你想控制两个手势的交互的单向关系，你可以覆盖 canPreventGestureRecognizer: 或 canBePreventedByGestureRecognizer: 子类方法，返回 NO (默认为 YES). 例如，你想旋转时防止收缩手势，但你不想收缩时防止旋转，你可以这样指定:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rotationGestureRecognizer canPreventGestureRecognizer:pinchGestureRecognizer];</span><br></pre></td></tr></table></figure></p>
<p>然后覆盖这个手势子类方法返回 NO. 更多的子类化手势定制可以看下面的: <a href="http://www.atatech.org/articles/22122" target="_blank" rel="noopener">创建自定义手势</a><br>与其它界面控件的交互<br>在 iOS 6 之后，默认的控件避免了重叠的手势行为。例如，你有一个按钮并也附加了单击动作，然后你又有一个单击的手势附加在了这个按钮的父视图上，然后用户点击了这个按钮，这个按钮方法会首先拦截到这个触摸事件而不去响应手势识别。这样的规则只在默认的控件行为上，包括:<br>在 UIBUutton, UISwitch, UIStepper, UISegmentedControl, 和 UIPageControl 上单击<br>在 UISlider 上滑动<br>在 UISwitch 上平移。</p>
<p>如果你想定制这些控件的默认行为，请尽量参照 iOS 人机交互指南.</p>
<p>##解释手势识别触摸原理<br>到目前为止，你已经了解到了怎样识别手势并如何响应他们，然而，如果你要创建一个自定义的手势识别，你还需要了解更多关于它的细节原理。<br>一个事件包括所有的点击序列<br>在 iOS 里，触摸表示手指出现在屏幕上或在上面运动。一个手势有一次或多次触摸，他们都被 UITouch 对象所表示。例如，一次捏合手势里有两个手指在屏幕上向相反的方向运动。<br>事件包括了一段时间里所有的触摸序列，触摸序列开始于一个手指的触摸，直到最后一个手指离开屏幕。作为一个手指移动，iOS 发送触摸对象给事件。多触摸事件被表示为 UIEventTypeTouches 类型的 UIEvent 对象.<br>每个触摸对象只跟踪一个手指，在一个多触摸序列中。这序列期间， UIKit 跟踪手指并更新它的触摸属性，这些属性包括触摸阶段，在视图的位置，上一次的位置，时间。<br>这个触摸阶段指明触摸开始，是否移动或停止等。看下图:<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/event_touch_time_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/event_touch_time_2x.png" alt="触摸序列与阶段"></a></p>
<p>##APP 收到触摸时调用的操作方法<br>在多点触摸序列中，当有新的或改变的触摸阶段时都会发送信息给这些回调方法:<br>touchesBegan:withEvent: 当一个或多个手指触摸到屏幕时touchesMoved:withEvent: 当手指开始移动时touchesEnded:withEvent: 当一个或多个手指离开屏幕时touchesCancelled:withEvent: 当触摸被系统取消时，比如来电话时<br>注意这些方法和手势识别状态无关，比如 UIGestureRecognizerStateBegan 和 UIGestureRecognizerStateEnded ，手势识别状态只表示它自己的识别状态，不是触摸的状态。</p>
<p>##将触摸发送到视图<br>当你想修改触摸的交付路径时，你需要理解它的默认行为。在一般情况下，当触摸发生，这个触摸对象会从 UIApplication 对象传递给 UIWindow 对象。在传递触摸对象给视图之前，它会先发送触摸对象到附加在触摸到的视图（或他的父视图）上的手势识别对象，<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/path_of_touches_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/path_of_touches_2x.png" alt="默认触摸的交付路径"></a></p>
<p>##手势识别首先得到识别触摸的机会<br>一个 window 延迟交付触摸对象给这个视图，所以是手势识别首先识别手势，在延误期间，如果手势能识别这个触摸手势，接下来这个 window 永远不会将触摸事件传递给视图.<br>例如你有一个离散的手势识别需要两个手指，下图显示了两个手指传入时将会的变化:<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/recognize_touch_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/recognize_touch_2x.png" alt="触摸信息序列"></a><br>注意最后当触摸被识别后，之前在视图上的触摸就会被取消，发送了 touchesCancelled:withEvent: 方法。</p>
<p>##影响交付触摸到视图<br>你可以通过一些 UIGestureRecognizer 属性修改默认的将会行为，如果你改变了它们默认的属性，你将得到下列的行为<br>delaysTouchesBegan (默认为 NO) ，默认 window 在 Began 和 Moved 阶段会发送触摸对象给视图和手势. 如果设置为 YES 的时候，window 会延迟交付给视图，这确保当手势识别成功后不再将交付给视图. 注意设置这个属性的时候要谨慎，他可能会让你的界面感觉无反应。</p>
<p>这样的设置提供了一个类似的行为在 UIScrollView 的 delaysContentTouches 属性中，在这样的场景下，当滚动开始不久后，scroll-view 里的子对象不会收到 touch 信息，这样不会让他看直起来闪烁。<br>delaysTouchesEnded (默认为YES) , 当它为 YES 时，如果手势想取消它时，确保视图不完成 action 。当手势识别在分析手势时， window 不会在 Ended 阶段交付触摸对象给视图。当手势识别它是手势时，触摸对象被取消。如果 识别失败，window 会交付它到视图，发送 touchesEnded:withEvent: 信息。设置它为 NO 时， 在发析时，也同时发送信息给视图。</p>
<p>考虑这样的情部，一个视图需要双击识别，用户双击这个视图，如果 属性设置为 YES, 这个视图会得到 touchesBegan:withEvent:, touchesBegan:withEvent:, touchesCancelled:withEvent:, 和 touchesCancelled:withEvent:。如果这个属性设置为 NO, 这个视图收到这样的序列 : touchesBegan:withEvent:, touchesEnded:withEvent:, touchesBegan:withEvent:, 和 touchesCancelled:withEvent:, which means that in touchesBegan:withEvent:，这个视图可以识别一个双击<br>如果手势识别判定一个触摸不是它手势的一部分，它可以直接传递给它的视图，要做到这一点，可以调用手势识别方法 ignoreTouch:forEvent: 。<br>定制手势识别<br>实现一个定制的手势，首先要创建 UIGestureRecognizer 的子类，然后 import 这个子类的头文件</p>
<p>#import<br>然后从 UIGestureRecognizerSubclass.h 头文件中拷贝下面的方法声明到你的子类里:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset;</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure></p>
<p>这些方法和触摸操作一样有明确的行为，在你覆盖它们前，你要先调用父类的实现，即使它是一个空的实现。<br>注意 state 这个属性在你引入 UIGestureRecognizerSubclass.h 头文件后，就从只读变为可读写的了。<br>实现自定义的触摸实别操作<br>核心是在于通过下面四个方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">touchesBegan:withEvent:,</span><br><span class="line">touchesMoved:withEvent:, </span><br><span class="line">touchesEnded:withEvent:, </span><br><span class="line">touchesCancelled:withEvent:</span><br></pre></td></tr></table></figure></p>
<p>去将抽像低的触摸行为变为可识别的高级行为。<br>下面这个例子中，仅有一个 view ，但很多 app 中有多个 view ， 通常，你应该转换为屏幕坐标，以正确识别手势。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIGestureRecognizerSubclass.h&gt;</span></span></span><br><span class="line"><span class="comment">// Implemented in your custom subclass</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event]; </span><br><span class="line">    <span class="keyword">if</span> ([touches count] != <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateFailed</span>; </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesMoved:touches withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state == <span class="built_in">UIGestureRecognizerStateFailed</span>)  <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">UIWindow</span> *win = [<span class="keyword">self</span>.view window]; </span><br><span class="line">    <span class="built_in">CGPoint</span> nowPoint = [touches.anyObject locationInView:win];</span><br><span class="line">    <span class="built_in">CGPoint</span> nowPoint = [touches.anyObject locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="built_in">CGPoint</span> prevPoint = [touches.anyObject previousLocationInView:<span class="keyword">self</span>.view]; </span><br><span class="line">    <span class="comment">// strokeUp is a property </span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">self</span>.strokeUp) &#123;</span><br><span class="line">   <span class="comment">// On downstroke, both x and y increase in positive direction </span></span><br><span class="line">    <span class="keyword">if</span> (nowPoint.x &gt;= prevPoint.x &amp;&amp; nowPoint.y &gt;= prevPoint.y) &#123;</span><br><span class="line">        <span class="keyword">self</span>.midPoint = nowPoint; </span><br><span class="line">        <span class="comment">// Upstroke has increasing x value but decreasing y value </span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowPoint.x &gt;= prevPoint.x &amp;&amp; nowPoint.y &lt;= prevPoint.y)&#123;</span><br><span class="line">         <span class="keyword">self</span>.strokeUp = <span class="literal">YES</span>; </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateFailed</span>;</span><br><span class="line">       &#125; </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">      [<span class="keyword">super</span> touchesEnded:touches withEvent:event];</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">self</span>.state == <span class="built_in">UIGestureRecognizerStatePossible</span>) &amp;&amp; <span class="keyword">self</span>.strokeUp) &#123; </span><br><span class="line">       <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateRecognized</span>; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">       [<span class="keyword">super</span> touchesCancelled:touches withEvent:event]; </span><br><span class="line">       <span class="keyword">self</span>.midPoint = <span class="built_in">CGPointZero</span>; </span><br><span class="line">       <span class="keyword">self</span>.strokeUp = <span class="literal">NO</span>; </span><br><span class="line">       <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateFailed</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于状态转化离散和持续手势是不一样的，正如上面的 “有限状态机中的手势识别” 所述一样，当你创建一个自定义手势识别，你必需明确指明它的相关状态是否为离散或连续。上面的那个例子，它的状态永远不会设置为 Began 或 Changed ，因为它是离散的。<br>更多的自定义手势资料可以查看 <a href="https://developer.apple.com/videos/wwdc/2012/?id=233" target="_blank" rel="noopener">WWDC 2012: Building Advanced Gesture Recognizers</a><br>重置手势状态<br>如果你的手势识别转变为 Recognized/Ended, Canceled, 或 Failed, 这个 UIGestureRecognizer 类会在状态变为 Possible 之前调用 reset 方法<br>实现 reset 方法以便重置你的一些内部状态，以便你可以为下一次的识别做准备。下面是一个例子:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset &#123; </span><br><span class="line">      [<span class="keyword">super</span> reset]; </span><br><span class="line">      <span class="keyword">self</span>.midPoint = <span class="built_in">CGPointZero</span>; </span><br><span class="line">      <span class="keyword">self</span>.strokeUp = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/21/UIWindow 整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hongru's 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/07/21/UIWindow 整理/" class="post-title-link" itemprop="url">UIWindow 整理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-07-21 00:00:00" itemprop="dateCreated datePublished" datetime="2016-07-21T00:00:00+08:00">2016-07-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-22 15:52:20" itemprop="dateModified" datetime="2019-02-22T15:52:20+08:00">2019-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UIWindow-整理"><a href="#UIWindow-整理" class="headerlink" title="UIWindow 整理"></a>UIWindow 整理</h1><p>##<strong>UIWindow概念</strong><br>UIWindw定义了一个负责管理，协调一个App的View是如何显示在设备屏幕上的窗口类，除非一个App可以显示在一个外部的设备屏幕上，那么一个App只拥有一个窗口。UIWindow本身没有标题栏，关闭操作栏等任何的装饰物，用户不会看见，移动或者是关闭它，这跟Mac OS上的window有很大的差别。      UIWindow的两大主要功能是提供了一块给View的显示区域，并且负责分发各种事件给View，比如传递触摸事件给各项View或者其它对象。而改变App的显示内容，可以改变UIWindow的rootView，而不需要去创建一个新的UIWindow。同时，它还负责与ViewController协同去处理设备旋转时的情况。      讲到Window还必须要提的两个概念是UIWindowLevel以及KeyWindow。UIWindowLevel是一个CGFloat值，现在UIKit定义了三种Level:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelNormal</span>; </span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelAlert</span>;</span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelStatusBar</span></span><br></pre></td></tr></table></figure></p>
<p>UIWindowLevel为2D的iOS世界引入了Z轴的概念，它相当于以屏幕为原地，以使用者为正方向的一根轴。值越小代表离使用者越远，越大代表越靠近使用者。高Level的Window会盖住低Level的window，若是两者Level一样则根据添加顺序来决定，这类似于我们添加子View(UIWindow本来也就是UIView的子类)。而上面三个值分别是0.0,2000.0,1000.0，而大部分在App上使用的都是UIWindowLevelNormal，这也是每个Window被创建出来时的默认值。    我们在创建一个新的window的时候，要让它显示出来必须要调用makeKeyAndVisible方法，让window显示出来，并让它成为一个KeyWindow。KeyWindow是UIApplication的一个开放属性，它是当前App的主window，用来接收键盘输入以及非触摸事件(触摸事件是传递给触摸事件发生的window，不一定是keyWindow)，或者是跟坐标值无关的事件都会被传递给keyWindow。并且在同一时刻，只有一个window会成为keyWindow。但是需要注意一件事情，成为keywindow与windowLevel无关，并不是windowLevel最高的window会成为keywindow.</p>
<p>##<strong>UIWindow在App启动时扮演的角色</strong><br><strong>(1)The Main Function</strong><br>  所有以C语言为基础的程序的入口都是main函数，iOS App也不例外。以下程序就是iOS App的main函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span> </span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])&#123; </span><br><span class="line">      <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>])); </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>唯一不同的是你不用去写main函数，这是Xcode自动创建的。这段代码也很简单，它唯一做的工作就是把控制权移交给UIKit framework，根据第三个参数principalClassName创建一个UIApplication对象，根据第四个参数创建一个AppDelegate对象。 </p>
<p><strong>(2)UIApplication</strong><br>     UIApplication是一个App的核心，它主要的职能是负责方便系统和App的交互，管理Event Loop进行各项事件的处理，以及向自己的Delegate，即AppDelegate进行一些关键事件的传递。一个App只有一个UIApplication单例对象，可以通过[UIApplication sharedApplication]来获得单例。它还能做一些应用级别的事，比如设置桌面上App图标右上角的红点数字，或者是使用openURL直接拨电话，发短信等。在此不做延伸。<br><img src="http://upload-images.jianshu.io/upload_images/901318-74734c584f6565e3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpeg"></p>
<p><strong> (3)UIWindow</strong></p>
<p>UIWindow是iOS启动之后，被创建的第一个视图控件。它有可能是通过Interface Builder被创建出来的，也有可能是我们在AppDelegate中自定义创建出来的。当它被创建，添加了rootView之后，一个App的界面最终被展示在用户面前。而如果是自定义创建window时，我们通常会使用window.rootViewController来为它添加rootView，值得注意的是，这句代码仅仅是给UIWindow添加了rootViewController的view，或者说这是一种更加便利的方式来为UIWindow添加rootView,而这个rootViewController属性并不是用来让controller与UIWindow之间进行通信的。除此之外，UIWindow还负责与UIApplication一起负责传递Event给View以及ViewController。</p>
<p>##拾遗<br><strong>(1)UITextEffectsWindow</strong><br> 这是iOS8引入的一个新window，是键盘所在的window。它的windowLevel是10，高于UIWindowLevelNormal。<br><strong>(2)UIRemoteKeyboardWindow</strong><br>iOS9之后,新增了一个类型为 UIRemoteKeyboardWindow 的窗口用来显示键盘按钮。目前对这个研究还不是很多，以后有了新发现再与大家分享。    </p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/20/iOS 性能提升总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hongru's 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/07/20/iOS 性能提升总结/" class="post-title-link" itemprop="url">iOS 性能提升总结</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-07-20 00:00:00" itemprop="dateCreated datePublished" datetime="2016-07-20T00:00:00+08:00">2016-07-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-22 15:50:59" itemprop="dateModified" datetime="2019-02-22T15:50:59+08:00">2019-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-性能提升总结"><a href="#iOS-性能提升总结" class="headerlink" title="iOS 性能提升总结"></a>iOS 性能提升总结</h1><p>##使用复用机制</p>
<p>在我们使用 UITableView 和 UICollectionView 时我们通常会遇到「复用 Cell」这个提法，所谓「复用 Cell」就是指当需要展示的数据条目较多时，只创建较少数量的 Cell 对象（一般是屏幕可显示的 Cell 数再加一）并通过复用它们的方式来展示数据的机制。这种机制不会为每一条数据都创建一个 Cell，所以可以节省内存，提升程序的效率和交互流畅性。<br>从 iOS 6 以后，我们在 UITableView 和 UICollectionView 中不光可以复用 Cell，还可以复用各个 Section 的 Header 和 Footer。<br>在 UITableView 做复用的时候，会用到的 API：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复用 Cell：</span></span><br><span class="line">- [<span class="built_in">UITableView</span> dequeueReusableCellWithIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> registerNib:forCellReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> registerClass:forCellReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> dequeueReusableCellWithIdentifier:forIndexPath:];<span class="comment">// 复用 Section 的 Header/Footer：</span></span><br><span class="line">- [<span class="built_in">UITableView</span> registerNib:forHeaderFooterViewReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> registerClass:forHeaderFooterViewReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> dequeueReusableHeaderFooterViewWithIdentifier:];</span><br></pre></td></tr></table></figure></p>
<p>复用机制是一个很好的机制，但是不正确的使用却会给我们的程序带来很多问题。下面拿 UITableView 复用 Cell 来举例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier =  <span class="string">@"UITableViewCell"</span>; </span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>;</span><br><span class="line">    cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123; </span><br><span class="line">         cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleSubtitle</span> reuseIdentifier:CellIdentifier]; </span><br><span class="line"><span class="comment">// 偶数行 Cell 的 textLabel 的文字颜色为红色。</span></span><br><span class="line">        <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">               [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> redColor]]; </span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cell.textLabel.text = <span class="string">@"Title"</span>;</span><br><span class="line"> <span class="comment">// 偶数行 Cell 的 detailTextLabel 显示 Detail 文字。</span></span><br><span class="line">      <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">       cell.detailTextLabel.text = <span class="string">@"Detail"</span>; </span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们本来是希望只有偶数行的 textLabel 的文字颜色为红色，并且显示 Detail 文字，但是当你滑动 TableView 的时候发现不对了，有些奇数行的 textLabel 的文字颜色为红色，而且还显示了 Detail 文字，很奇怪。其实造成这个问题的原因就是「复用」，当一个 Cell 被拿来复用时，它所有被设置的属性（包括样式和内容）都会被拿来复用，如果刚好某一个的 Cell 你没有显式地设置它的属性，那么它这些属性就直接复用别的 Cell 的了。就如上面的代码中，我们并没有显式地设置奇数行的 Cell 的 textLabel 的文字颜色以及 detailTextLabel 的文字，那么它就有可能复用别的 Cell 的这些属性了。此外，还有个问题，对偶数行 Cell 的 textLabel 的文字颜色的设置放在了初始一个 Cell 的 if 代码块里，这样在复用的时候，逻辑走不到这里去，那么也会出现复用问题。所以，上面的代码需要改成这样：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier = <span class="string">@"UITableViewCell"</span>; </span><br><span class="line">   <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>; </span><br><span class="line">   cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; </span><br><span class="line">   <span class="keyword">if</span> (!cell) &#123; </span><br><span class="line">       cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleSubtitle</span> reuseIdentifier:CellIdentifier];</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   cell.textLabel.text = <span class="string">@"Title"</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">       [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> redColor]]; </span><br><span class="line">       cell.detailTextLabel.text = <span class="string">@"Detail"</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">       [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> blackColor]];</span><br><span class="line">       cell.detailTextLabel.text = <span class="literal">nil</span>; </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总之在复用的时候需要记住：<br><strong>设置 Cell 的存在差异性的那些属性（包括样式和内容）时，有了 if 最好就要有 else，要显式的覆盖所有可能性。</strong><br><strong>设置 Cell 的存在差异性的那些属性时，代码要放在初始化代码块的外部。</strong></p>
<p>上面的代码中，我们展示了 - [UITableView dequeueReusableCellWithIdentifier:];<br> 的用法。下面看看另几个 API 的用法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITableView</span> *myTableView;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123; </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">        <span class="comment">// Setup table view. </span></span><br><span class="line">    <span class="keyword">self</span>.myTableView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.myTableView.dataSource = <span class="keyword">self</span>;</span><br><span class="line">   [<span class="keyword">self</span>.myTableView registerClass:[MyTableViewCell <span class="keyword">class</span>] forCellReuseIdentifier:<span class="string">@"MyTableViewCell"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier = <span class="string">@"MyTableViewCell"</span>; </span><br><span class="line">     <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>; </span><br><span class="line">     cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];</span><br><span class="line">     cell.textLabel.text = <span class="string">@"Title"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">           [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> redColor]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> blackColor]];</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，- [UITableView dequeueReusableCellWithIdentifier:forIndexPath:];<br> 必须搭配- [UITableView registerClass:forCellReuseIdentifier:];或者- [UITableView registerNib:forCellReuseIdentifier:];<br> 使用。当有可重用的 Cell 时，前者直接拿来复用，并调用 - [UITableViewCell prepareForReuse]<br> 方法；当没有时，前者会调用 Identifier 对应的那个注册的 UITableViewCell 类的 - [UITableViewCell initWithStyle:reuseIdentifier:]方法来初始化一个，这里省去了你自己初始化的步骤。当你自定义了一个 UITableViewCell 的子类时，你可以这样来用。</p>
<p>##优化 UITableView<br>UITableView 是我们最常用来展示数据的控件之一，并且通常需要 UITableView 在承载较多内容的同时保证交互的流畅性，对 UITableView 的性能优化是我们开发应用程序必备的技巧之一。<br>在前文「使用复用机制」一节，已经提到了 UITableView 的复用机制。现在就来看看 UITableView 在复用时最主要的两个回调方法：- [UITableView tableView:cellForRowAtIndexPath:]和- [UITableView tableView:heightForRowAtIndexPath:]。UITableView 是继承自 UIScrollView，所以在渲染的过程中它会先确定它的 contentSize 及每个 Cell 的位置，然后才会把复用的 Cell 放置到对应的位置。比如现在一共有 50 个 Cell，当前屏幕上显示 5 个。那么在第一次创建或 reloadData 的时候， UITableView 会先调用 50 次- [UITableView tableView:heightForRowAtIndexPath:]<br> 确定 contentSize 及每个 Cell 的位置，然后再调用 5 次 - [UITableView tableView:cellForRowAtIndexPath:]<br> 来渲染当前屏幕的 Cell。在滑动屏幕的时候，每当一个 Cell 进入屏幕时，都需要调用一次 - [UITableView tableView:cellForRowAtIndexPath:]和- [UITableView tableView:heightForRowAtIndexPath:]方法。<br>了解了 UITableView 的复用机制以及相关回调方法的调用次序，这里就对 UITableView 的性能优化方案做一个总结：</p>
<ul>
<li>通过正确的设置 reuseIdentifier 来重用 Cell。</li>
<li>尽量减少不必要的透明 View。</li>
<li>尽量避免渐变效果、图片拉伸和离屏渲染。</li>
<li>当不同的行的高度不一样时，尽量缓存它们的高度值。</li>
<li>如果 Cell 展示的内容来自网络，确保用异步加载的方式来获取数据，并且缓存服务器的 response。</li>
<li>使用 shadowPath 来设置阴影效果。</li>
<li>尽量减少 subview 的数量，对于 subview 较多并且样式多变的 Cell，可以考虑用异步绘制或重写 drawRect。</li>
<li>尽量优化 - [UITableView tableView:cellForRowAtIndexPath:]</li>
<li>方法中的处理逻辑，如果确实要做一些处理，可以考虑做一次，缓存结果。</li>
<li>选择合适的数据结构来承载数据，不同的数据结构对不同操作的开销是存在差异的。</li>
<li>对于 rowHeight、sectionFooterHeight、sectionHeaderHeight 尽量使用常量。</li>
</ul>
<p>##尽可能设置 View 为不透明<br>UIView 有一个 opaque属性，在你不需要透明效果时，你应该尽量设置它为 YES 可以提高绘图过程的效率。<br>在一个静态的视图里，这点可能影响不大，但是当在一个可以滚动的 Scroll View 中或是一个复杂的动画中，透明的效果可能会对程序的性能有较大的影响。</p>
<p>##避免臃肿的 XIB 文件<br>如果你压根不用 XIB，那就不需要看了。</p>
<p>在你需要重用某些自定义 View 或者因为历史兼容原因用到 XIB 的时候，你需要注意：当你加载一个 XIB 时，它的所有内容都会被加载，如果这个 XIB 里面有个 View 你不会马上就用到，你其实就是在浪费宝贵的内存。而加载 StoryBoard 时并不会把所有的 ViewController 都加载，只会按需加载。</p>
<p>##不要阻塞主线程<br>基本上 UIKit 会把它所有的工作都放在主线程执行，比如：绘制界面、管理手势、响应输入等等。当你把所有代码逻辑都放在主线程时，有可能因为耗时太长卡住主线程造成程序无法响应、流畅性太差等问题。造成这种问题的大多数场景是因为你的程序把 I/O 操作放在了主线程，比如从硬盘或者网络读写数据等等。</p>
<p>你可以通过异步的方式来进行这些操作，把他们放在别的线程中处理。比如处理网络请求时，你可以使用 NSURLConnection 的异步调用 API：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span> *)request queue:(<span class="built_in">NSOperationQueue</span> *)queue completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>*, <span class="built_in">NSData</span>*, <span class="built_in">NSError</span>*))handler;</span><br></pre></td></tr></table></figure></p>
<p>或者使用第三方的类库，比如 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>。<br>当你做一些耗时比较长的操作时，你可以使用 GCD、NSOperation、NSOperationQueue。比如 GCD 的常见使用方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">     <span class="comment">// switch to another thread and perform your expensive operation</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; </span><br><span class="line">            <span class="comment">// switch back to the main thread to update your UI</span></span><br><span class="line">     &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>关于 GCD 更多的知识，你可以看看这篇文章：<a href="http://www.atatech.org/articles/41244" target="_blank" rel="noopener">GCD</a>。</p>
<p>###图片尺寸匹配 UIImageView</p>
<p>当你从 App bundle 中加载图片到 UIImageView 中显示时，最好确保图片的尺寸能够和 UIImageView 的尺寸相匹配（当然，需要考虑 @2x @3x 的情况），否则会使得 UIImageView 在显示图片时需要做拉伸，这样会影响性能，尤其是在一个 UIScrollView 的容器里。</p>
<p>有时候，你的图片是从网络加载的，这时候你并不能控制图片的尺寸，不过你可以在图片下载下来后去手动 scale 一下它，当然，最好是在一个后台线程做这件事，然后在 UIImageView 中使用 resize 后的图片。<br>关于这一点SDWebImage进行了优化，如果你使用SDWebImage，它会帮你进行Scale优化。</p>
<p>##选择合适的容器<br>我们经常需要用到容器来转载多个对象，我们通常用到的包括：NSArray、NSDictionary、NSSet，它们的特性如下：</p>
<ul>
<li>Array：数组。有序的，通过 index 查找很快，通过 value 查找很慢，插入和删除较慢。</li>
<li>Dictionary：字典。存储键值对，通过键查找很快。</li>
<li>Set：集合。无序的，通过 value 查找很快，插入和删除较快。</li>
</ul>
<p>根据以上特性，在编程中需要选择适合的容器。更多内容请看：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Collections/Collections.html" target="_blank" rel="noopener">Collections Programming Topics</a></p>
<p>##启用 GZIP 数据压缩<br>现在越来越多的应用需要跟服务器进行数据交互，当交互的数据量较大时，网络传输的时延就会较长，通过启动数据压缩功能，尤其是对于文本信息，可以降低网络传输的数据量，从而减短网络交互的时间。</p>
<p>一个好消息是当你使用 NSURLConnection 或者基于此的一些网络交互类库（比如 AFNetworking）时 iOS 已经默认支持 GZIP 压缩。并且，很多服务器已经支持发送压缩数据。</p>
<p>通过在服务器和客户端程序中启用对网络交互数据的压缩，是一条提高应用程序性能的途径。</p>
<p>##View 的复用和懒加载机制<br>当你的程序中需要展示很多的 View 的时候，这就意味着需要更多的 CPU 处理时间和内存空间，这个情况对程序性能的影响在你使用 UIScrollView 来装载和呈现界面时会变得尤为显著。</p>
<p>处理这种情况的一种方案就是向 UITableView 和 UICollectionView 学习，不要一次性把所有的 subviews 都创建出来，而是在你需要他们的时候创建，并且用复用机制去复用他们。这样减少了内存分配的开销，节省了内存空间。</p>
<p>「懒加载机制」就是把创建对象的时机延后到不得不需要它们的时候。这个机制常常用在对一个类的属性的初始化上，比如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableView</span> *)myTableView &#123; </span><br><span class="line">    <span class="keyword">if</span> (!_myTableView) &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> viewBounds = <span class="keyword">self</span>.view.bounds;</span><br><span class="line">    _myTableView = [[<span class="built_in">UITableView</span> alloc] initWithFrame:viewBounds style:<span class="built_in">UITableViewStylePlain</span>];</span><br><span class="line">    _myTableView.showsHorizontalScrollIndicator = <span class="literal">NO</span>; </span><br><span class="line">    _myTableView.showsVerticalScrollIndicator = <span class="literal">NO</span>; </span><br><span class="line">    _myTableView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [_myTableView setSeparatorStyle:<span class="built_in">UITableViewCellSeparatorStyleNone</span>];</span><br><span class="line">    _myTableView.dataSource = <span class="keyword">self</span>; </span><br><span class="line">    _myTableView.delegate = <span class="keyword">self</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> _myTableView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有当我们第一次用到 self.myTableView 的时候采取初始化和创建它。<br>但是，存在这样一种场景：你点击一个按钮的时候，你需要显示一个 View，这时候你有两种实现方案：</p>
<ol>
<li>在当前界面第一次加载的时候就创建出这个 View，只是把它隐藏起来，当你需要它的时候，只用显示它就行了。</li>
<li>使用「懒加载机制」，在你需要这个 View 的时候才创建它，并展示它。<br>这两种方案都各有利弊。采用方案一，你在不需要这个 View 的时候显然白白地占用了更多的内存，但是当你点击按钮展示它的时候，你的程序能响应地相对较快，因为你只需要改变它的 hidden 属性。采用方案二，那么你得到的效果相反，你更准确的使用了内存，但是如果对这个 View 的初始化和创建比较耗时，那么响应性相对就没那么好了。</li>
</ol>
<p>所以当你考虑使用何种方案时，你需要根据现实的情况来参考，去权衡到底哪个因素才是影响性能的瓶颈，然后再做出选择。</p>
<p>##缓存</p>
<p>在开发我们的程序时，一个很重要的经验法则就是：对那些更新频度低，访问频度高的内容做缓存。<br>有哪些东西使我们可以缓存的呢？比如下面这些：</p>
<ul>
<li>服务器的响应信息（response）。</li>
<li>图片。</li>
<li>计算值。比如：UITableView 的 row heights。<br>NSURLConnection 可以根据 HTTP 头部的设置来决定把资源内容缓存在磁盘或者内存，你甚至可以设置让它只加载缓存里的内容：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMutableURLRequest</span> *)imageRequestWithURL:(<span class="built_in">NSURL</span> *)url &#123; </span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url]; </span><br><span class="line">    request.cachePolicy = <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>; </span><br><span class="line">    <span class="comment">// this will make sure the request always returns the cached image </span></span><br><span class="line">    request.HTTPShouldHandleCookies = <span class="literal">NO</span>;</span><br><span class="line">    request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">    [request addValue:<span class="string">@"image/*"</span> forHTTPHeaderField:<span class="string">@"Accept"</span>]; </span><br><span class="line">    ]<span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 HTTP 缓存的更多内容可以关注 NSURLCache。关于缓存其他非 HTTP 请求的内容，可以关注 NSCache。对于图片缓存，可以关注一个第三方库 <a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>。</p>
<p>##关于图形绘制<br>当我们为一个 UIButton 设置背景图片时，对于这个背景图片的处理，我们有很多种方案，你可以使用全尺寸图片直接设置，还可以用 resizable images，或者使用 CALayer、CoreGraphics 甚至 OpenGL 来绘制。<br>当然，不同的方案的编码复杂度不一样，性能也不一样。关于图形绘制的不同方案的性能问题，可以看看：<a href="https://robots.thoughtbot.com/designing-for-ios-graphics-performance" target="_blank" rel="noopener">Designing for iOS: Graphics Performance</a><br>简而言之，使用 pre-rendered 的图片会更快，因为这样就不需要在程序中去创建一个图像，并在上面绘制各种形状了（Offscreen Rendering，离屏渲染）。但是缺点是你必须把这些图片资源打包到代码包，从而需要增加程序包的体积。这就是为什么 resizable images 是一个很棒的选择：不需要全尺寸图，让 iOS 为你绘制图片中那些可以拉伸的部分，从而减小了图片体积；并且你不需要为不同大小的控件准备不同尺寸的图片。比如两个按钮的大小不一样，但是他们的背景图样式是一样的，你只需要准备一个对应样式的 resizable image，然后在设置这两个按钮的背景图的时候分别做拉伸就可以了。<br>但是一味的使用使用预置的图片也会有一些缺点，比如你做一些简单的动画的时候各个帧都用图片叠加，这样就可能要使用大量图片。<br>总之，你需要去在图形绘制的性能和应用程序包的大小上做权衡，找到最合适的性能优化方案。</p>
<p>##处理 Memory Warnings</p>
<p>关于内存警告，苹果的官方文档是这样说的：</p>
<blockquote>
<p>If your app receives this warning, it must free up as much memory as possible. The best way to do this is to remove strong references to caches, image objects, and other data objects that can be recreated later.</p>
</blockquote>
<p>我们可以通过这些方式来获得内存警告：<br>在 AppDelegate 中实现 - [AppDelegate applicationDidReceiveMemoryWarning:]代理方法。<br>在 UIViewController 中重载 didReceiveMemoryWarning方法。<br>监听 UIApplicationDidReceiveMemoryWarningNotification通知。</p>
<p>当通过这些方式监听到内存警告时，你需要马上释放掉不需要的内存从而避免程序被系统杀掉。<br>比如，在一个 UIViewController 中，你可以清除那些当前不显示的 View，同时可以清除这些 View 对应的内存中的数据，而有图片缓存机制的话也可以在这时候释放掉不显示在屏幕上的图片资源。<br>但是需要注意的是，你这时清除的数据，必须是可以在重新获取到的，否则可能因为必要数据为空，造成程序出错。在开发的时候，可以使用 iOS Simulator 的 Simulate memory warning的功能来测试你处理内存警告的代码。</p>
<p>##复用高开销的对象<br>在 Objective-C 中有些对象的初始化过程很缓慢，比如：NSDateFormatter和 NSCalendar，但是有些时候，你也不得不使用它们。为了这样的高开销的对象成为影响程序性能的重要因素，我们可以复用它们。<br>比如，我们在一个类里添加一个 NSDateFormatter 的对象，并使用懒加载机制来使用它，整个类只用到一个这样的对象，并只初始化一次：<br>保证应用快速启动的指导原则：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your .h or inside a class extension</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDateFormatter</span> *dateFormatter;</span><br><span class="line"><span class="comment">// inside the implementation (.m)</span></span><br><span class="line"><span class="comment">// When you need, just use self.dateFormatter</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123; </span><br><span class="line">     <span class="keyword">if</span> (! _dateFormatter) &#123; </span><br><span class="line">     _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">     [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>]; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> _dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是上面的代码在多线程环境下会有问题，所以我们可以改进如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no property is required anymore. The following code goes inside the implementation (.m)</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *dateFormatter; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">   <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">      _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init]; </span><br><span class="line">      [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>];</span><br><span class="line">   &#125;);</span><br><span class="line"> <span class="keyword">return</span> dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就线程安全了。（关于多线程 GCD 的知识，可以看看这篇文章：<a href="http://www.samirchen.com/ios-gcd/" target="_blank" rel="noopener">GCD</a>）<br>需要注意的是：设置 NSDateFormatter 的 date format 跟创建一个新的 NSDateFormatter 对象一样慢，因此当你的程序中要用到多种格式的 date format，而每种又会用到多次的时候，你可以尝试为每种 date format 创建一个可复用的 NSDateFormatter 对象来提供程序的性能。</p>
<p>##减少应用启动时间<br>快速启动应用对于用户来说可以留下很好的印象。尤其是第一次使用时。尽量将启动过程中的处理分拆成各个异步处理流，比如：网络请求、数据库访问、数据解析等等。<br>避免臃肿的 XIB 文件，因为它们会在你的主线程中进行加载。重申：Storyboard 没这个问题，放心使用。<br>注意：在测试程序启动性能的时候，最好用与 Xcode 断开连接的设备进行测试。因为 watchdog 在使用 Xcode 进行调试的时候是不会启动的。</p>
<p>##选择正确的数据格式</p>
<p>我们的 iOS 应用程序与服务器进行交互时，通常采用的数据格式就是 JSON 和 XML 两种。那么在选择哪一种时，需要考虑到它们的优缺点。<br>JSON 文件的优点是：</p>
<ul>
<li>能够更快的被解析。</li>
<li>在承载相同的数据时，通常体积比 XML 更小，这意味着传输的数据量更小。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>需要整个 JSON 数据全部加载完成后才能开始解析。</li>
</ul>
<p>而 XML 文件的优缺点则刚好反过来。 XML 的一个优点就是它可以使用 <a href="https://en.wikipedia.org/wiki/Simple_API_for_XML" target="_blank" rel="noopener">SAX</a> 来解析数据，从而可以边加载边解析，不用等所有数据都读取完成了才解析。这样在处理很大的数据集的时提高性能和降低内存消耗。<br>所以，你需要根据具体的应用场景来权衡使用何种数据格式。</p>
<p>##合理的设置背景图片<br>我们通常有两种方式来设置一个 View 的背景图片：</p>
<ul>
<li>通过 - [UIColor colorWithPatternImage:]方法来设置 View 的 background color。</li>
<li>通过给 View 添加一个 UIImageView 来设置其背景图片。<br>当你有一个全尺寸图片作为背景图时，你最好用 UIImageView 来，因为 - [UIColor colorWithPatternImage:]<br>是用来可重复填充的小的样式图片。这时对于全尺寸的图片，用 UIImageView 会节省大量的内存。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You could also achieve the same result in Interface Builder</span></span><br><span class="line"><span class="built_in">UIImageView</span> *backgroundView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background"</span>]];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:backgroundView];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是，当你计划采用一个小块的模板样式图片，就像贴瓷砖那样来重复填充整个背景时，你应该用- [UIColor colorWithPatternImage:]<br> 这个方法，因为这时它能够绘制的更快，并且不会用到太多的内存。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"backgroundPattern"</span>]];</span><br></pre></td></tr></table></figure></p>
<p>##优化 WebView<br>UIWebView 在我们的应用程序中非常有用，它可以便捷的展示 Web 的内容，甚至做到你用标准的 UIKit 控件较难做到的视觉效果。但是，你应该注意到你在应用程序里使用的 UIWebView 组件不会比苹果的 Safari 更快。这是首先于 Webkit 的 Nitro Engine 引擎。所以，为了得到更好的性能，你需要优化你的网页内容。</p>
<p>优化第一步就是避免过量使用 Javascript，例如避免使用较大的 Javascript 框架，比如 jQuery。一般使用原生的 Javascript 而不是依赖于 Javascript 框架可以获得更好的性能。</p>
<p>优化第二步，如果可能的话，可以异步加载那些不影响页面行为的 Javascript 脚本，比如一些数据统计脚本。</p>
<p>优化第三步，总是关注你在页面中所使用的图片，根据具体的场景来显示正确尺寸的图片，同时也可以使用上面提到的「使用 Sprites Sheets」的方案来在某些地方减少内存消耗和提高速度。</p>
<p>##减少离屏渲染</p>
<p>什么是「离屏渲染」？离屏渲染，即 Off-Screen Rendering。与之相对的是 On-Screen Rendering，即在当前屏幕渲染，意思是渲染操作是用于在当前屏幕显示的缓冲区进行。那么离屏渲染则是指图层在被显示之前是在当前屏幕缓冲区以外开辟的一个缓冲区进行渲染操作。<br>离屏渲染需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕，而上下文环境的切换是一项高开销的动作。<br>通常图层的以下属性将会触发离屏渲染：</p>
<ul>
<li>阴影（UIView.layer.shadowOffset/shadowRadius/…）</li>
<li>圆角（当 UIView.layer.cornerRadius 和 UIView.layer.maskToBounds 一起使用时）</li>
<li>图层蒙板<br>在 iOS 开发中要给一个 View 添加阴影效果，有很简单快捷的做法：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:...];</span><br><span class="line"><span class="comment">// Setup the shadow ...</span></span><br><span class="line">imageView.layer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">5.0</span>f, <span class="number">5.0</span>f);</span><br><span class="line">imageView.layer.shadowRadius = <span class="number">5.0</span>f;</span><br><span class="line">imageView.layer.shadowOpacity = <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>但是上面这样的做法有一个坏处是：将触发 Core Animation 做离屏渲染造成开销。<br>那要做到阴影图层效果，又想减少离屏渲染、提高性能的话要怎么做呢？一个好的建议是：设置 ShadowPath 属性。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initFrame:...];</span><br><span class="line"><span class="comment">// Setup the shadow ...</span></span><br><span class="line">imageView.layer.shadowPath = [[<span class="built_in">UIBezierPath</span> bezierPathWithRect:</span><br><span class="line"><span class="built_in">CGRectMake</span>(imageView.bounds.origin.x+<span class="number">5</span>, imageView.bounds.origin.y+<span class="number">5</span>,imageView.bounds.size.width, imageView.bounds.size.height)] <span class="built_in">CGPath</span>];</span><br><span class="line">imageView.layer.shadowOpacity = <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果图层是一个简单几何图形如矩形或者圆角矩形（假设不包含任何透明部分或者子图层），通过设置 ShadowPath 属性来创建出一个对应形状的阴影路径就比较容易，而且 Core Animation 绘制这个阴影也相当简单，不会触发离屏渲染，这对性能来说很有帮助。如果你的图层是一个更复杂的图形，生成正确的阴影路径可能就比较难了，这样子的话你可以考虑用绘图软件预先生成一个阴影背景图。</p>
<p>##光栅化<br>CALayer 有一个属性是 shouldRasterize<br> 通过设置这个属性为 YES 可以将图层绘制到一个屏幕外的图像，然后这个图像将会被缓存起来并绘制到实际图层的 contents 和子图层，如果很很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧来更加高效。但是光栅化原始图像需要时间，而且会消耗额外的内存。这是需要根据实际场景权衡的地方。<br>当我们使用得当时，光栅化可以提供很大的性能优势，但是一定要避免在内容不断变动的图层上使用，否则它缓存方面的好处就会消失，而且会让性能变的更糟。<br>为了检测你是否正确地使用了光栅化方式，可以用 Instrument 的 Core Animation Template 查看一下Color Hits Green and Misses Red<br> 项目，看看是否已光栅化图像被频繁地刷新（这样就说明图层并不是光栅化的好选择，或则你无意间触发了不必要的改变导致了重绘行为）。<br>如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为合适的值。在我们使用 UITableView 和 UICollectionView 时经常会遇到各个 Cell 的样式是一样的，这时候我们可以使用这个属性提高性能：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell.layer.shouldRasterize = <span class="literal">YES</span>;</span><br><span class="line">cell.layer.rasterizationScale = [[<span class="built_in">UIScreen</span> mainScreen] scale];</span><br></pre></td></tr></table></figure></p>
<p>但是，如果你的 Cell 是样式不一样，比如高度不定，排版多变，那就要慎重了。</p>
<p>##选择合适的数据存储方式<br>在 iOS 中可以用来进行数据持有化的方案包括：</p>
<ul>
<li>NSUserDefaults。只适合用来存小数据。</li>
<li>XML、JSON、Plist 等文件。JSON 和 XML 文件的差异在「选择正确的数据格式」已经说过了。</li>
<li>使用 NSCoding 来存档。NSCoding 同样是对文件进行读写，所以它也会面临必须加载整个文件才能继续的问题。</li>
<li>使用 SQLite 数据库。可以配合 <a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a> 使用。数据的相对文件来说还是好处很多的，比如可以按需取数据、不用暴力查找等等。</li>
<li>使用 CoreData。也是数据库技术，跟 SQLite 的性能差异比较小。但是 CoreData 是一个对象图谱模型，显得更面向对象；SQLite 就是常规的 DBMS。</li>
</ul>
<h2 id="使用-Autorelease-Pool"><a href="#使用-Autorelease-Pool" class="headerlink" title="使用 Autorelease Pool"></a>使用 Autorelease Pool</h2><p>NSAutoreleasePool 是用来管理一个自动释放内存池的机制。在我们的应用程序中通常都是 UIKit 隐式的自动使用 Autorelease Pool，但是有时候我们也可以显式的来用它。</p>
<p>比如当你需要在代码中创建许多临时对象时，你会发现内存消耗激增直到这些对象被释放，一个问题是这些内存只会到 UIKit 销毁了它对应的 Autorelease Pool 后才会被释放，这就意味着这些内存不必要地会空占一些时间。这时候就是我们显式的使用 Autorelease Pool 的时候了，一个示例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;for (NSURL *url in urls) &#123; </span></span><br><span class="line">      <span class="keyword">@autoreleasepool</span> &#123; </span><br><span class="line">             <span class="built_in">NSError</span> *error;</span><br><span class="line">             <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span>  stringWithContentsOfURL:url</span><br><span class="line">                                                                encoding:<span class="built_in">NSUTF8StringEncoding</span></span><br><span class="line">                                                                   error:&amp;error];</span><br><span class="line"> <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span> </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码在每一轮迭代中都会释放掉临时对象，从而缓解内存压力，提高性能。</p>
<p>##imageNamed 和 imageWithContentsOfFile<br>在 iOS 应用中加载图片通常有 - [UIImage imageNamed:]<br> 和 -[UIImage imageWithContentsOfFile:]<br> 两种方式。它们的不同在于前者会对图片进行缓存，而后者只是简单的从文件加载文件。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myImage"</span>]; <span class="comment">// caching</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWithContentsOfFile:<span class="string">@"myImage"</span>]; <span class="comment">// no caching</span></span><br></pre></td></tr></table></figure></p>
<p>在整个程序运行的过程中，当你需要加载一张较大的图片，并且只会使用它一次，那么你就没必要缓存这个图片，这时你可以使用 -[UIImage imageWithContentsOfFile:]<br>，这样系统也不会浪费内存来做缓存了。当然，如果你会多次使用到一张图时，用 - [UIImage imageNamed:]<br> 就会高效很多，因为这样就不用每次都从硬盘上加载图片了。</p>
<p>##避免使用 NSDateFormatter</p>
<p>在前文中，我们已经讲到了通过复用或者单例来提高 NSDateFormatter 这个高开销对象的使用效率。但是如果你要追求更快的速度，你可以直接使用 C 语言替代 NSDateFormatter 来解析 date，你可以看看这篇文章：<a href="http://blog.soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments" target="_blank" rel="noopener">link</a>，其中展示了解析 ISO-8601 date string 的代码，你可以根据你的需求改写。完成的代码见：<a href="https://github.com/samsoffes/sstoolkit/blob/master/SSToolkit/NSDate%2BSSToolkitAdditions.m" target="_blank" rel="noopener">SSToolkit/NSDate+SSToolkitAdditions.m</a>。<br>当然，如果你能够控制你接受到的 date 的参数的格式，你一定要尽量选择 Unix timestamps<br> 格式，这样你可以使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDate</span>*)dateFromUnixTimestamp:(<span class="built_in">NSTimeInterval</span>)timestamp &#123; </span><br><span class="line">           <span class="keyword">return</span> [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:timestamp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样你可以轻松的将时间戳转化为 NSDate 对象，并且效率甚至高于上面提到的 C 函数。<br>需要注意的是，很多 web API 返回的时间戳是以<strong>毫秒</strong>为单位的，因为这更利于 Javascript 去处理，但是上面代码用到的方法中 NSTimeInterval 的单位是<strong>秒</strong>，所以当你传参的时候，记得先除以 1000。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/16/iOS 适配 & 开发策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hongru's 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/07/16/iOS 适配 & 开发策略/" class="post-title-link" itemprop="url">iOS 适配 & 开发策略</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-07-16 00:00:00" itemprop="dateCreated datePublished" datetime="2016-07-16T00:00:00+08:00">2016-07-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-22 15:45:37" itemprop="dateModified" datetime="2019-02-22T15:45:37+08:00">2019-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-适配-amp-开发策略"><a href="#iOS-适配-amp-开发策略" class="headerlink" title="iOS 适配 &amp; 开发策略"></a>iOS 适配 &amp; 开发策略</h1><h2 id="屏幕尺寸适配"><a href="#屏幕尺寸适配" class="headerlink" title="屏幕尺寸适配"></a>屏幕尺寸适配</h2><hr>
<p> 2007 年，初代 iPhone发布，其拥有 3.5寸屏幕，运行 iPhone OS X。在后续几年中Apple 陆续发布了 iPhone 3GS，iPhone 4，iPhone 4S，iPhone 5C，iPhone 5S，iPhone 6，iPhone 6 Plus，iPhone 6S、iPhone 6S Plus，iPhoneSE ，iPhone7，iPhone7 Plus, 2017年9月将发布iphone 8。其运行的操作系统也从 iOS 4、iOS 5、iOS 6、iOS 7 、iOS 8， iOS 9，iOS10，iOS11。随着新版 iPhone，新版iOS操作系统的上市，随着维护的iPhone和IOS版本增多，如何确保 App适配新版iPhone及iOS操作系统？而这又是必须解决的问题，否则App将丧失新版iPhone新版iOS 系统上的用户，从而带来巨大的损失。<br>        Apple 提供的解决方案之一就是：引入了点(point)的概念。在 iPhone 3GS 中, 1个点对应1个像素，点和像素两者在数值上是一致的。在iPhone 4/4S中，虽然机型变化，其荧幕宽高像素点增加了，但是其宽高点坐标是不变的。所以在开发过程中可以使用点绝对坐标，用来确定视图的位置。同时提供两套图片: ~.png 和 <a href="mailto:~@2x.png" target="_blank" rel="noopener">~@2x.png</a>。 iOS 系统将根据 iPhone 的像素来自动决定使用哪一张图片。 </p>
<table>
<thead>
<tr>
<th>机型</th>
<th>屏幕尺寸</th>
<th>屏幕宽高（像素）</th>
<th>屏幕宽高（点）</th>
<th>模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>iPhone 3GS</td>
<td>3.5</td>
<td>320x480</td>
<td>320 x 480</td>
<td>1x</td>
</tr>
<tr>
<td>iPhone 4</td>
<td>3.5</td>
<td>640 x 960</td>
<td>320 x 480</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 4S</td>
<td>3.5</td>
<td>640 x 960</td>
<td>320 x 480</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 5</td>
<td>4</td>
<td>640 x 1136</td>
<td>320 x 568</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 5C</td>
<td>4</td>
<td>640 x 1136</td>
<td>320 x 568</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 5S</td>
<td>4</td>
<td>640 x 1136</td>
<td>320 x 568</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 5SE</td>
<td>4</td>
<td>640 x 1136</td>
<td>320 x 568</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 6</td>
<td>4.7</td>
<td>750 x 1134</td>
<td>375 x 667</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 6 Plus</td>
<td>5.5</td>
<td>1080 x 1920</td>
<td>414 x 736</td>
<td>2.6x</td>
</tr>
<tr>
<td>iPhone 6S</td>
<td>4.7</td>
<td>750 x 1134</td>
<td>375 x 667</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 6S Plus</td>
<td>5.5</td>
<td>1080 x 1920</td>
<td>414 x 736</td>
<td>2.6x</td>
</tr>
<tr>
<td>iPhone 7</td>
<td>4.7</td>
<td>750 x 1134</td>
<td>375 x 667</td>
<td>2x</td>
</tr>
<tr>
<td>iPhone 7 Plus</td>
<td>5.5</td>
<td>1080 x 1920</td>
<td>414 x 736</td>
<td>2.6x</td>
</tr>
</tbody>
</table>
<p> 在iPhone5/5C/5S中，其荧幕，像素以及点，都已经发生变化。相比iPhone4/4S, 其荧幕宽度不变，高度增加88个点。在这种情况下，就不能再使用绝对坐标，否则将导致程序高度不够。如果App没有对其做适配处理，iOS 将对88个点均分为上下两部分，荧幕上下各出现44个点的黑边。在不同机型上，荧幕点坐标改变了，于是再也不能使用绝对坐标。为了彻底解决这个问题，iOS提出了一种新技术AutoLayout。使用AutoLayout技术，将不使用绝对坐标，而是指定View，button，TextField之间的相对位置，比如靠左多少，靠右多少，相距多少等。通过指定这一系列的约束条件，AutoLayout在荧幕上自动的画出对应布局。在iPhone5/5C/5S中，由于像素：点的比例仍为2，所以将直接使<a href="mailto:~@2x.png" target="_blank" rel="noopener">~@2x.png</a> 图片即可。如果没有提供<a href="mailto:~@2x.png" target="_blank" rel="noopener">~@2x.png</a>的图片，那么就直接使用~.png的图片覆盖同样的点。虽然点的数量一样，但是像素点却多了1倍，以致在这种情况下，图片显示会比较模糊。在iPhone6面世后，其荧幕大小坐标已经变化，宽，高都增加了。但是宽，高比不变，为9:16。而且其像素：点比仍然为2。在2x和3x的图片都不太合适。iOS的解决方案是：现有的银幕分辨率明显超过2x但没有达到3x，于是想象一个满足3x的银幕总可以吧?<br>        于是App在iPhone 6 Plus上运行的时候，iOS会骗App说，App现在运行在一个 3x的荧幕上，其像素为1242x2208，点为414 x 736，而且都比iPhone 6要大。于是程序设计师和UED也按照3x来设计。UED 提供 3x 的高清图片，程序设计师依据414 x 736 来编写App。但是借来的总是要还的。iOS 在拿到这个假想 1242x2208 的绘制结果，再缩小到实际 1080 x 1920 荧幕来画图（通过某种缩小算法)。于是在 iPhone 6 Plus荧幕上看到的永远是缩小的图像。通过3x模式,使得设计开发过程得到了大大的简化。</p>
<p>##CPU 指令集<br>| 机型 | ARM 架构|<br>| ——| —— |<br>| iPhone 3GS | ARM V6|<br>| iPhone 4 | ARM V7|<br>| iPhone 4S | ARM V7|<br>| iPhone 5 | ARM V7S|<br>| iPhone 5C | ARM V7S|<br>| iPhone 5S | ARM V8(64)|<br>| iPhone 6 | ARM V8(64)|<br>| iPhone 6 Plus | ARM V8(64)|<br>| iPhone 6S | ARM V8(64)|<br>| iPhone 6S Plus | ARM V8(64)|<br>| iPhone 5SE  | ARM V8(64)|<br>| iPhone 7 | ARM V8(64)|<br>| iPhone 7 Plus | ARM V8(64)|</p>
<p>指令集是向后兼容的。比如ARMV7S指令集下生成的二进制包，可以运行在iPhone 6上，只是有些优化不可用，效率没有那么高而已。反之，ARM V8生成的二进制包, 就不能在 ARM V7S的iPhone 5上。 在编译二进制包的时候，需要确认其所能支持的ARM架构。如果希望App在各版iPhone上都能够高效运行，则需要将Build Active Architecture Only改为NO，Valid architectures选择对应的指令集：ARM V7 ARM V7S ARM 8。为各个指令集编译对应的代码，因此最后的ipa包的体积基本翻了3倍。如果希望App体积保持最小, 则现阶段应该选Valid architectures为ARM V7，这样Build Active Architecture Only选YES或NO就无所谓了。在ARM V8上，最明显的一个区别就是支持64-bit。于是在iOS上的数据类型发生了变化。数据长度的改变给App带来的影响之一就是: 当把一个值从大的数据类型拷贝到小的数据类型，数据可能被截断，例如从NSInteger 转换到int。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/901318-d53902919c7842c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.png"><br>Architecture ：指你想支持的指令集。Valid architectures ：指即将编译的指令集。Build Active Architecture Only : 只是否只编译当前适用的指令集。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/901318-c0bfe38c8bc650fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.png"></p>
<p>##iOS 系统<br>每次iPhone机型的升级，往往同时伴随着新版iOS系统的发布。最开始的iPhone OSX，其创新的多点触控操作和极简的用户体验受到了用户的追捧。虽然初代的系统还存在各种各样的问题，比如无法复制粘贴等，但是它开启了移动设备操作系统的新时代。随着iOS 4增加了对Retina和多任务的支持，iOS 5带来了Siri 语音助手，iOS 6引入了全新的地图，iOS 7全新的扁平化图标界面设计，到iOS 8开始支持的Touch ID，iOS 9 Watch OS 2、App Thinning、3D Tought、分屏多任务，iOS系统在不断的更新(当然每次iOS系统的迭代更新，其对应的SDK也被推向开发人员)。发布上线的 App，必须考虑到对不同版本iOS系统的适配。因为在某一个特定时间点，并不是所有的用户都在最新版本的操作系统，比如有些用户在使用iOS 8，但总还是有一些用户停留在iOS 7,iOS 6甚至iOS 5。举例来说,相对 iOS 7 而言,iOS 8 中对内置相机做了改动—-自由调节进光量，在拍摄中，触摸屏幕对好焦点后，会在对焦框旁边出现进光量调节轴，增加或降低拍摄的曝光量，从而不必因为光的问题频繁找焦点测光了。值得注意的是:：App AliExpress.com使用了调用了iOS拍照的功能，且其在iOS 7上工作中正常。在安装该App的iPhone升级为iOS 8之后，需要验证App的拍照功能是否工作正常, 确认其没有受到 iOS 8 拍照功能改动的影响。与之类似,和 iOS 7相比，iOS 8还有一些新功能，比如开放支持第三方输入法；锁屏推送中直接操作，而并不需要打开信息应用；多人群聊，实时位置共享，还可以发送语音和视频消息。根据这些iOS 8新功能，评估其对App风险。再而一一测试App上对应的功能。只有这些点都被测试通过之后，才能够宣布该App已经适配了iOS 8。</p>
<table>
<thead>
<tr>
<th>iOS系统</th>
<th>iOS各版本市场占比</th>
<th>与前版本主要不同之处</th>
</tr>
</thead>
<tbody>
<tr>
<td>iOS 7</td>
<td>&lt; 8%</td>
<td>1. 重新设计的视觉界面,扁平化文件系统</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2. 全新的控制中心从下侧边缘滑出控制中心</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3. 全新的MultiTasking设计，App预览及App关闭方式</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4. 通知中心，锁屏下可以查看推送</td>
</tr>
<tr>
<td></td>
<td></td>
<td>5. Safari 升级，包括支持全荧幕浏览，左右切换等</td>
</tr>
<tr>
<td></td>
<td></td>
<td>6.其他多项新功能</td>
</tr>
<tr>
<td>iOS 8</td>
<td>15%</td>
<td>1. 相机延时拍照，进光量调节</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2. QuickType及第三方输入法</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3. 交互式通知中心</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4. Safari升级，向外切换到书签，分享链接</td>
</tr>
<tr>
<td></td>
<td></td>
<td>5. 即时聊天，群聊，位置分享，分享视频等</td>
</tr>
<tr>
<td></td>
<td></td>
<td>6.  其他多项新功能</td>
</tr>
<tr>
<td>iOS 9</td>
<td>77%</td>
<td>1. 3D Tought</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2.应用内搜索</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3.  App Watch OS 2.0支持</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4. BitCode App瘦身</td>
</tr>
<tr>
<td></td>
<td></td>
<td>5.  App Transport Security（ATS)</td>
</tr>
<tr>
<td>iOS 9</td>
<td>77%</td>
<td>1. 3D Tought</td>
</tr>
<tr>
<td></td>
<td></td>
<td>2.应用内搜索</td>
</tr>
<tr>
<td></td>
<td></td>
<td>3.  App Watch OS 2.0支持</td>
</tr>
<tr>
<td></td>
<td></td>
<td>4. BitCode App瘦身</td>
</tr>
<tr>
<td></td>
<td></td>
<td>5.  App Transport Security（ATS)</td>
</tr>
</tbody>
</table>
<p>##开发策略<br>了解iPhone设备，iOS系统的适配原理，有益于App的开发。<br>在App开发阶段，将适配性作为代码的规范之一。从而能够在源头改善代码质量，提高App质量，降低App适配风险。其指导性策略如下:<br>1、布局相关：不使用绝对坐标，建议使用第三方（Masonry）进行相对位置设置。<br>2、通过点的概念，而不使用像素，来统一思考不同机器上的适配，为适配创造良好的基础。 比如要在view里面画一个44x44个点的按钮，2x模式，就乘以2，3x模式就乘以3。<br>3、调用系统API之前，需要考虑iOS的版本。<br>4、特定的API在不同iOS版本中，其功能，参数，返回数据可能有所不同。这些数据在对应的SDK中可以找到详情。所以在使用这些API之前，需要对这些功能, 参数，返回数据进行特殊处理。<br>5、iOS的某些特定版本，自身也存在一些bug。这些bug的详情在Apple Inc.官网<a href="http://www.apple.com中iOS的release" target="_blank" rel="noopener">www.apple.com中iOS的release</a> document中有披露。在App设计中，要避免踩到iOS特定版本自身的 bug。</p>
<p>##测试策略<br>依据上述的iPhone机型市场占比可以对其适配性专项进行优先级排序。市场占比最多的iPhone 5S，iPhone 6的优先级别最高，依次为 iPhone 5／5C，iPhone 6 Plus等。优先级别最低为iPhone 4S。在这些级别中，主要注意机型之间不同尺寸荧幕所带来的差别，包括分辨率，像素的不同。在App安装到这些机型上面后，其UI应该拉升或者压缩到满荧幕，不得出现空白区域或者某些部分不能显示。UI所对应的功能，与硬件相隔离，而一一工作正常。在编译二进制包而选择指令集，其包在跨机型上工作正常，App对指令集兼容。</p>
<p>App 在不同尺寸/分辨率/像素的荧幕手机下，其UI拉升压缩满整屏幕，视觉显示正常，对应功能正常。<br>基于不同指令集下编译的包，安装在跨机型上工作正常。<br>       在iOS系统适配方面，根据各个iOS系统的改动功能点，和App上与之对应的相关功能, 一一评估其风险并验证。其中iOS 7和iOS 8之间的系统差异特别明显，需要特别关注。在App的适配测试中，需要同时考虑 iPhone和iOS系统两个维度，建议从代码层面深层次的分析问题。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/16/Bonjour！实现零配置网络联网的解决方案/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hongru's 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/07/16/Bonjour！实现零配置网络联网的解决方案/" class="post-title-link" itemprop="url">Bonjour！实现零配置网络联网的解决方案</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-07-16 00:00:00" itemprop="dateCreated datePublished" datetime="2016-07-16T00:00:00+08:00">2016-07-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-22 15:49:26" itemprop="dateModified" datetime="2019-02-22T15:49:26+08:00">2019-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Bonjour！实现零配置网络联网的解决方案"><a href="#Bonjour！实现零配置网络联网的解决方案" class="headerlink" title="Bonjour！实现零配置网络联网的解决方案"></a>Bonjour！实现零配置网络联网的解决方案</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>简单介绍一下项目对本地网络连接的需求：车机连接移动设备。</p>
<p>那我们如何进行连接呢。</p>
<ol>
<li><p>首先我们想到的最简单的方法就是通过IP连接。</p>
</li>
<li><p>UDP广播。</p>
</li>
</ol>
<p>利用UDP广播我们能向同一本地网络所有设备发送一条消息,接收到信息后我们能够解析出发送方的端口和IP。</p>
<p>问题：</p>
<ol>
<li>耗电问题。不断的UDP Broadcast 会耗费大量电源。</li>
<li>网络阻塞问题。因为UDP广播会对同一本地网络的所有Host都发送信息。过于密集的发送,有可能会造成网络的堵塞。</li>
<li>稳定性,UDP Socket可能会因为各种情况而中断。</li>
</ol>
<h3 id="什么是-Bonjour"><a href="#什么是-Bonjour" class="headerlink" title="什么是 Bonjour ?"></a>什么是 Bonjour ?</h3><p><strong>bonjour</strong> 是苹果公司发布的一个基于 <strong>ZEROCONF</strong> 工作组 <strong>(IETF</strong>下属小组) 的工作,用于实现零配置网络联网的解决方案。<strong>Bonjour</strong>是基于<strong>IP</strong>层协议的。</p>
<p>Bonjour是Apple推出的零配置网络协议，主要的目的是在缺少中心服务器的情况下解决网络设备的IP获取，名称解析和服务发现等关键问题。</p>
<h3 id="Bonjour可以做什么"><a href="#Bonjour可以做什么" class="headerlink" title="Bonjour可以做什么"></a>Bonjour可以做什么</h3><hr>
<p> Bonjour可以完成的工作主要是在缺少中心服务器的情况下解决IP获取，名称解析和服务发现这三个问题。</p>
<ul>
<li>IP获取<br>在传统网络环境下，设备的IP地址通过两种方式获取，一种是静态配置，通过手工方式为设备指定一个IP地址，一种是动态配置，设备通过路由器的DHCP服务获得动态的IP地址。<br>在无中心服务器的网络环境下，没有中心服务器提供DHCP服务，用户手工配置IP地址也很不方便，这就需要一种新的方式来帮助设备获取IP地址，就是希望设备可以主动为自己指定一个可用的IP地址。<br>在IPV6环境下，IPV6协议本身就提供了设备自指定IP地址的能力，所以实现很简单，直接使用IPV6的协议支持就可以了。<br>在IPV4环境下，Bonjour使用了随机指定IP地址的方法，首先为设备随机指定一个属于本地网段的IP地址，然后检查该地址在本地是否有冲突，如果有冲突就随机生成另一个新的IP地址，直到找到可用IP地址为止。<br>我在做测试的时候没有测试这部分，都是使用的DHCP的动态地址。以后有时间测试了这个部分后再和大家分享测试结果。</li>
<li><strong><em>**</em></strong>名称解析<strong><em>**</em></strong><br>在传统网络环境下，名称和IP地址的对应关系是通过DNS服务解析的。当一个设备需要访问一个域名，如“<a href="http://www.abc.com”，设备将“www.abc.com”发给DNS服务器，服务器返回该域名对应的IP地址，设备再使用返回的IP地址对目标服务器进行访问。" target="_blank" rel="noopener">www.abc.com”，设备将“www.abc.com”发给DNS服务器，服务器返回该域名对应的IP地址，设备再使用返回的IP地址对目标服务器进行访问。</a><br>在没有中心服务器的网络环境中，没有DNS服务器提供域名解析服务，名称解析变成一个严重问题。针对这一问题，业界的解决方案是mDNS，中文叫“组播DNS”，在标准文档RFC6762中定义。<br>“组播DNS”的原理很简单，当一个设备需要解析一个名称时，如“abc.local”，这个设备通过UDP协议向本地网络中的所有设备广播一个消息，问谁是“abc.local”，本地网络中如果有一个设备认为自己是“abc.local”，它就给出响应，说出自己的IP地址。<br>因为“组播DNS”基于UDP协议，采用广播消息的方式，所以不需要一个中心服务器提供DNS解析服务就可以完成本地的名称解析。<br>Bonjour也是基于mDNS协议的，不过Bonjour在mDNS协议上作了扩展，加强了设备响应“组播DNS”请求的能力。在Bonjour协议下，应用只需要对某个名称进行注册，就可以将响应“组播DNS”请求的工作交由底层处理。也就是说在Bonjour协议下，应用不需要侦听本地网络的“组播DNS”请求并进行响应，这些工作由底层系统完成。<br>为了区分全球域名和本地域名，mDNS协议使用“.local.”作为本地域名的根域名。</li>
<li><strong><em>**</em></strong>服务搜索（自动在网络搜索服务）<strong><em>**</em></strong><br>当一个提供服务的设备获取IP地址，并自我指定一个域名后，其实还是不能满足用户的需求。因为用户需要的是某种服务，如打印服务，web服务，用户并不关心这些服务对应的服务器名称和它的IP地址。<br>为了让用户更容易发现本地网络中的各种服务，Bonjour为设备提供了服务发现的能力。<br>Bonjour提供的“服务发现”能力基于一个简单直接的规定，就是提供服务的设备在按以下标准对服务进行注册：“名称.服务类型.传输协议类型.local.”，比如：“DamonWebServer._http._tcp.local.”，又比如“DummiesWebServer._http._tcp.local.”。<br>这样，当一个设备使用希望查找http服务的时候，Bonjour会去查找本地网络中注册过的包含”_http”的服务，然后将结果返回给用户选择。这时用户面对的是“DamonWebServer”和”DummiesWebServer”，用户可以不去关心到底这两个web服务到底在那台设备上，该设备的IP地址是什么。<br>###如何使用Bonjour</li>
</ul>
<hr>
<p> 对于最终用户来讲，Bonjour基本上是透明的，他们不需要了解如何去使用Bonjour，往往都是应用开发者去考虑如何使用Bonjour。<br> 对于应用开发者来讲，他们需要考虑有两部分，一是如何作为Bonjour客户端去发现使用本地服务，二是如何作为服务端如何注册Bonjour服务</p>
<ul>
<li>如何作为Bonjour客户端去发现本地服务<br>iOS开发可以使用NSNetService框架中的NSNetServiceBrowser类去发现本地服务。<br>基本过程如下：<br>首先创建NSNetServiceBrowser实例：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    serviceBrowser = [[NSNetServiceBrowser alloc] init]<span class="comment">;</span></span><br><span class="line">    serviceBrowser.delegate = self<span class="comment">;</span></span><br><span class="line">    [serviceBrowser searchForServicesOfType:@<span class="string">"_http._tcp."</span> inDomain:@<span class="string">"local."</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)<span class="string">netServiceBrowser:</span>(NSNetServiceBrowser *)netServiceBrowser <span class="string">didFindService:</span>(NSNetService *)netService <span class="string">moreComing:</span>(BOOL)moreServicesComing &#123;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如何作为服务端注册Bonjour服务<br>要注册成为Bonjour服务，开发者可以直接创建NSNetService实例，<br>并通过initwithDomain:type:name:port:方法进行初始化，指定服务的域，类型，名称和端口，样例代码如下：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in"> service </span>= [[NSNetService alloc] initWithDomain:@<span class="string">"local."</span> type:@<span class="string">"_http._tcp."</span> name:@<span class="string">"DamonWebServer"</span> port:port];</span><br></pre></td></tr></table></figure>
<p>NSNetService创建成功后，可以通过setDelegate指定代理，同时通过publish方法发布注册服务：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">        [service setDelegate:self]</span><span class="comment">;</span></span><br><span class="line"><span class="section">        [service publish]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 其中指定的代理需要遵从“NSNetServiceDelegate”协议，可以对服务发布成功，发布失败等事件。</p>
<p> 正常来讲，如果需要发布一个服务，需要在发布服务之前准备好服务并启动它。不过NSNetService的publish方法并不依赖它所发布的服务，不管服务是否准备好，是否启动，NSNetService的publish都可以成功将服务发布出去，只不过服务发布出去后其它使用这个服务的客户端会发现这个发布出来的服务是个无效服务。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2016/07/11/[IOS 防止Crash 组件WTSafeGuard ](https---github.com-hongruqi-SafeGuard)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hongru's 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2016/07/11/[IOS 防止Crash 组件WTSafeGuard ](https---github.com-hongruqi-SafeGuard)/" class="post-title-link" itemprop="url">iOS 降低线上版本Crash率</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2016-07-11 00:00:00" itemprop="dateCreated datePublished" datetime="2016-07-11T00:00:00+08:00">2016-07-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-22 15:58:32" itemprop="dateModified" datetime="2019-02-22T15:58:32+08:00">2019-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#iOS 降低线上版本Crash率 </p>
<h3 id="IOS-防止Crash-组件WTSafeGuard"><a href="#IOS-防止Crash-组件WTSafeGuard" class="headerlink" title="IOS 防止Crash 组件WTSafeGuard "></a><a href="https://github.com/hongruqi/SafeGuard" target="_blank" rel="noopener">IOS 防止Crash 组件WTSafeGuard </a></h3><p>##背景<br>由于Object-C本身的不安全性，导致很容易产生Crash。在这些Crash，很多我们可以利用自定义手段，进行避免。这样可以降低线上版本的Crash率，提升用户<br>体验。WTSafeGuard 避免APP Crash 组件，目前能做到的还很有限。</p>
<h3 id="UIKit-Called-on-Non-Main-Thread"><a href="#UIKit-Called-on-Non-Main-Thread" class="headerlink" title="UIKit Called on Non-Main Thread"></a>UIKit Called on Non-Main Thread</h3><p>UIKit不是线程安全的，执行UIKit操作如果不在主线程很可能造成程序Crash。所以我们对Hook，UIView 的setNeedsLayout，layoutIfNeeded，layoutSubviews，setNeedsUpdateConstraints方法。如果执行以上函数没有在主队列，通过强行将执行代码，在主队列执行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)wt_safe_setNeedsLayout</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_setNeedsLayout failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_setNeedsLayout];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_setNeedsLayout];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wt_safe_layoutIfNeeded</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_layoutIfNeeded failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_layoutIfNeeded];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_layoutIfNeeded];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wt_safe_layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_layoutSubviews failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_layoutSubviews];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_layoutSubviews];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wt_safe_setNeedsUpdateConstraints</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_setNeedsUpdateConstraints failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_setNeedsUpdateConstraints];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_setNeedsUpdateConstraints];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##避免 Foundation 类Carsh</p>
<p>###NSString<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)stringWithUTF8String:(<span class="keyword">const</span> <span class="keyword">char</span> *)bytes</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUTF8String:(<span class="keyword">const</span> <span class="keyword">char</span> *)nullTerminatedCString</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFormat:(<span class="built_in">NSString</span> *)format locale:(<span class="keyword">id</span>)locale arguments:(va_list)argList</span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">unichar</span>)characterAtIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">- (<span class="keyword">void</span>)getCharacters:(<span class="keyword">unichar</span> *)buffer range:(<span class="built_in">NSRange</span>)range</span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfCharacterFromSet:(<span class="built_in">NSCharacterSet</span>  *)searchSet </span><br><span class="line">                            options:(<span class="built_in">NSStringCompareOptions</span>)mask</span><br><span class="line">                              range:(<span class="built_in">NSRange</span>)searchRange</span><br><span class="line">                                    </span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString</span><br><span class="line">                options:(<span class="built_in">NSStringCompareOptions</span>)mask</span><br><span class="line">                  range:(<span class="built_in">NSRange</span>)searchRange</span><br><span class="line">                 locale:(<span class="built_in">NSLocale</span> *)locale</span><br><span class="line">- (<span class="built_in">NSString</span> *)substringFromIndex:(<span class="built_in">NSUInteger</span>)from</span><br><span class="line">- (<span class="built_in">NSString</span> *)substringWithRange:(<span class="built_in">NSRange</span>)range</span><br><span class="line">- (<span class="built_in">NSString</span> *)substringToIndex:(<span class="built_in">NSUInteger</span>)to</span><br><span class="line">- (<span class="keyword">void</span>)getLineStart:(<span class="built_in">NSUInteger</span> *)startPtr   </span><br><span class="line">                 end:(<span class="built_in">NSUInteger</span> *)lineEndPtr                                         </span><br><span class="line">                 contentsEnd:(<span class="built_in">NSUInteger</span> *)contentsEndPtr</span><br><span class="line">                   forRange:(<span class="built_in">NSRange</span>)range</span><br></pre></td></tr></table></figure></p>
<h3 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h3><p>hook 方法：对传入参数range 进行check，如果range有问题，直接返回nil</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSAttributedString</span> *)attributedSubstringFromRange:(<span class="built_in">NSRange</span>)range;</span><br></pre></td></tr></table></figure>
<h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDirectoryEnumerator</span>&lt;<span class="built_in">NSURL</span> *&gt; *)enumeratorAtURL:(<span class="built_in">NSURL</span> *)url includingPropertiesForKeys:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURLResourceKey</span>&gt; *)keys options:(<span class="built_in">NSDirectoryEnumerationOptions</span>)mask errorHandler:(<span class="keyword">nullable</span> <span class="built_in">BOOL</span> (^)(<span class="built_in">NSURL</span> *url, <span class="built_in">NSError</span> *error))handler</span><br></pre></td></tr></table></figure>
<p>###NSIndexPath<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getIndexes:(<span class="built_in">NSUInteger</span> *)indexes range:(<span class="built_in">NSRange</span>)positionRang</span><br></pre></td></tr></table></figure></p>
<p>###NSJSONSerialization<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSData</span> *)dataWithJSONObject:(<span class="keyword">id</span>)obj options:(<span class="built_in">NSJSONWritingOptions</span>)opt error:(<span class="built_in">NSError</span> **)error</span><br></pre></td></tr></table></figure></p>
<h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><p>hook 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedKeySetForKeys:(<span class="built_in">NSArray</span>&lt;KeyType &lt;<span class="built_in">NSCopying</span>&gt;&gt; *)keys</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjects:(<span class="keyword">const</span> ObjectType _Nonnull [_Nullable])objects forKeys:(<span class="keyword">const</span> KeyType &lt;<span class="built_in">NSCopying</span>&gt; _Nonnull [_Nullable])keys</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjects:(<span class="keyword">const</span> ObjectType _Nonnull [_Nullable])objects forKeys:(<span class="keyword">const</span> KeyType &lt;<span class="built_in">NSCopying</span>&gt; _Nonnull [_Nullable])keys count:(<span class="built_in">NSUInteger</span>)cnt</span><br></pre></td></tr></table></figure>
<h3 id="NSMutableDictionary"><a href="#NSMutableDictionary" class="headerlink" title="NSMutableDictionary"></a>NSMutableDictionary</h3><p>hook 方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMutableDictionary</span>&lt;KeyType, ObjectType&gt; *)dictionaryWithSharedKeySet:(<span class="keyword">id</span>)keyset</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(ObjectType)anObject forKey:(KeyType &lt;<span class="built_in">NSCopying</span>&gt;)aKey;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(KeyType)aKey;</span><br></pre></td></tr></table></figure>
<p>###NSSet<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)WT_initWithObjects:(<span class="keyword">const</span> <span class="keyword">id</span> [])objects count:(<span class="built_in">NSUInteger</span>)cnt</span><br><span class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformSelector:(SEL)aSelector</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformSelector:(SEL)aSelector</span><br><span class="line">                        withObject:(<span class="keyword">id</span>)argument</span><br></pre></td></tr></table></figure></p>
<p>###NSMutableSet<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObject</span><br></pre></td></tr></table></figure></p>
<p>###NSMutableString<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">void</span>)appendString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">void</span>)deleteCharactersInRange:(<span class="built_in">NSRange</span>)range</span><br><span class="line">- (<span class="keyword">void</span>)insertString:(<span class="built_in">NSString</span> *)aString atIndex:(<span class="built_in">NSUInteger</span>)loc</span><br><span class="line">- (<span class="keyword">void</span>)replaceCharactersInRange:(<span class="built_in">NSRange</span>)range withString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">-  (<span class="built_in">NSUInteger</span>)replaceOccurrencesOfString:(<span class="built_in">NSString</span> *)target</span><br><span class="line">                                     withString:(<span class="built_in">NSString</span> *)replacement</span><br><span class="line">                                        options:(<span class="built_in">NSStringCompareOptions</span>)options</span><br><span class="line">                                          range:(<span class="built_in">NSRange</span>)searchRange</span><br></pre></td></tr></table></figure></p>
<p>###NSURL<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPath:(<span class="built_in">NSString</span> *)path isDirectory:(<span class="built_in">BOOL</span>)isDir</span><br><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPathComponents:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)components</span><br><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                      isDirectory:(<span class="built_in">BOOL</span>)isDir</span><br><span class="line">                    relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithString:(<span class="built_in">NSString</span> *)URLString relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br><span class="line">- (<span class="keyword">instancetype</span>)initFileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">- (<span class="keyword">instancetype</span>)initFileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                             relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br><span class="line">- (<span class="keyword">instancetype</span>)initFileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                               isDirectory:(<span class="built_in">BOOL</span>)isDir</span><br><span class="line">                             relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>KVO</li>
<li>容器越界（NSArray， NSDictionary,…）</li>
<li>unrecognized selector crash (这个很多时候是由于class使用错误导致)</li>
<li>NSTimer 导致crash</li>
</ol>
<hr>
<h3 id="KVO-Crash"><a href="#KVO-Crash" class="headerlink" title="KVO Crash"></a>KVO Crash</h3><p>项目中KVO crash 占比很高， 主要原因为，添加删除不对称导致。<br>解决方法为，添加Map进行缓存。<br>不过这个方案，目前还有缺陷。</p>
<h3 id="unrecognized-selector-crash"><a href="#unrecognized-selector-crash" class="headerlink" title="unrecognized selector crash"></a>unrecognized selector crash</h3><p>这个就比较简单了，直接上代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    [<span class="built_in">NSObject</span> jr_swizzleMethod:<span class="keyword">@selector</span>(forwardingTargetForSelector:) withMethod:<span class="keyword">@selector</span>(WT_safeForwardingTargetForSelector:) error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    - (<span class="keyword">id</span>)WT_safeForwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:aSelector] || signature) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> WT_safeForwardingTargetForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [WTSafeGuard createFakeForwardTargetObject:<span class="keyword">self</span> selector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://hongruqi.github.io/2015/12/01/IOS 音频开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="water">
      <meta itemprop="description" content="不积跬步，无以致千里；不积小流，无以成江海。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hongru's 博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2015/12/01/IOS 音频开发/" class="post-title-link" itemprop="url">iOS 音频开发</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2015-12-01 00:00:00" itemprop="dateCreated datePublished" datetime="2015-12-01T00:00:00+08:00">2015-12-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2019-02-22 15:43:14" itemprop="dateModified" datetime="2019-02-22T15:43:14+08:00">2019-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/iOS/" itemprop="url" rel="index"><span itemprop="name">iOS</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="iOS-音频开发"><a href="#iOS-音频开发" class="headerlink" title="iOS 音频开发"></a>iOS 音频开发</h1><hr>
<ul>
<li>音频基础知识</li>
<li>音频文件计算大小</li>
<li>音频转码</li>
</ul>
<hr>
<h2 id="音频基础知识"><a href="#音频基础知识" class="headerlink" title="音频基础知识"></a>音频基础知识</h2><p>###组成<br>音频文件的组成：文件格式(或者音频容器)  + 数据格式(或者音频编码)。</p>
<p>###文件格式(或音频容器)是用于形容文件本身的格式。</p>
<p>我们可以通过多种不同的方法为真正的音频数据编码。例如CAF文件便是一种文件格式，它能够包含MP3格式，线性PCM以及其它数据格式的音频。</p>
<p>###数据格式(或音频编码)<br>我们将从音频编码开始阐述(而不是文件格式)，因为编码是最重要的环节。</p>
<p>###线性PCM：<br>这是表示线性脉冲编码调制，主要是描写用于将模拟声音数据转换成数字格式的技术。简单地说也就是未压缩的数据。因为数据是未压缩的，所以我们便可以最快速地播放出音频，而如果空间不是问题的话这便是iPhone音频的优先代码选择。</p>
<p>##音频文件计算大小 ##</p>
<hr>
<p>声卡对声音的处理质量可以用三个基本参数来衡量，即采样频率、采样位数和声道数。</p>
<p>####采样频率:<br>是指单位时间内的采样次数。采样频率越大，采样点之间的间隔就越小，数字化后得到的声音就越逼真，但相应的数据量就越大。声卡一般提供11.025kHz、22.05kHz和44.1kHz等不同的采样频率。</p>
<p>####采样位数：<br>是记录每次采样值数值大小的位数。采样位数通常有8bits或16bits两种，采样位数越大，所能记录声音的变化度就越细腻，相应的数据量就越大。</p>
<p>####声道数<br>是指处理的声音是单声道还是立体声。单声道在声音处理过程中只有单数据流，而立体声则需要左、右声道的两个数据流。显然，立体声的效果要好，但相应的数据量要比单声道的数据量加倍。</p>
<p>####声音数据量的计算公式为：<br>数据量（字节/秒）= (采样频率（Hz）× 采样位数（bit） × 声道数)/ 8</p>
<p><em>单声道的声道数为1，立体声的声道数为2。</em></p>
<p>【例1】请计算对于5分钟双声道、16位采样位数、44.1kHz采样频率声音的不压缩数据量是多少？<br>根据公式：数据量=（采样频率×采样位数×声道数×时间）/8<br>得，数据量(MB)=[44.1×1000×16×2×（5×60）] /（8×1024×1024）=50.47MB<br>计算时要注意几个单位的换算细节：<br>时间单位换算：1分=60秒<br>采样频率单位换算：1kHz=1000Hz<br>数据量单位换算：1MB=1024×1024=1048576B</p>
<p>【例2】请计算对于双声道立体声、采样频率为44.1kHz、采样位数为16位的激光唱盘（CD-A），用一个650MB的CD-ROM可存放多长时间的音乐？<br>已知音频文件大小的计算公式如下：<br>文件的字节数/每秒=采样频率（Hz）X采样位数（位）X声道数/8<br>根据上面的公式计算一秒钟时间内的不压缩数据量：(44.1×1000×16×2)/8=0.168MB/s<br>那么，一个650MB的CD-ROM可存放的时间为：（650/0.168）/（60×60）=1.07小时。</p>
<hr>
<p>##IOS 音频转码 ##</p>
<p>音频转码使用的框架为：AudioToolBox</p>
<p>###内存转码： ###<br>    使用函数： AudioConverterFillComplexBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">    - (void)handleAudioPackets:(const void *)inputData</span><br><span class="line">             numberOfBytes:(UInt32)numberOfBytes</span><br><span class="line">           numberOfPackets:(UInt32)numberOfPackets</span><br><span class="line">        packetDescriptions:(AudioStreamPacketDescription *)packetDescriptions</span><br><span class="line">&#123;</span><br><span class="line">    if (!_audioFileStream || !_parseAudioHeader || !_decodeConverterRef) return;</span><br><span class="line">    </span><br><span class="line">    AudioConvertInfo convertInfo = (AudioConvertInfo)&#123;</span><br><span class="line">        .done = NO,</span><br><span class="line">        .numberOfPackets = numberOfPackets,</span><br><span class="line">        .packetDescriptions = packetDescriptions,</span><br><span class="line">        .audioBuffer = (AudioBuffer)&#123;</span><br><span class="line">            .mData = (void *)inputData,</span><br><span class="line">            .mDataByteSize = numberOfBytes,</span><br><span class="line">            .mNumberChannels = _sourceAsbd.mChannelsPerFrame</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    AudioBufferList decodedData;</span><br><span class="line">    decodedData.mNumberBuffers = 1;</span><br><span class="line">    decodedData.mBuffers[0].mNumberChannels = _canonicalAsbd.mChannelsPerFrame;</span><br><span class="line">    decodedData.mBuffers[0].mDataByteSize = _decodeBufferSize;</span><br><span class="line">    decodedData.mBuffers[0].mData = _decodeBuffer;</span><br><span class="line">    </span><br><span class="line">    UInt32 ioOutputDataPackets1, ioOutputDataPackets2;</span><br><span class="line">    OSStatus decodingStatus, encodingStatus;</span><br><span class="line">    </span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        ioOutputDataPackets1 = numberOfPackets;</span><br><span class="line">        </span><br><span class="line">        decodingStatus = AudioConverterFillComplexBuffer(_decodeConverterRef, AudioConverterCallback, (void*)&amp;convertInfo, &amp;ioOutputDataPackets1, &amp;decodedData, NULL);</span><br><span class="line">        </span><br><span class="line">        if (decodingStatus == OS_STATUS_DONE || decodingStatus == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ioOutputDataPackets1 &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // Start encoding</span><br><span class="line">                </span><br><span class="line">                AudioConvertInfo encodeConvertInfo = (AudioConvertInfo)&#123;</span><br><span class="line">                    .done = NO,</span><br><span class="line">                    .numberOfPackets = ioOutputDataPackets1,</span><br><span class="line">                    .packetDescriptions = NULL,</span><br><span class="line">                    .audioBuffer = (AudioBuffer)&#123;</span><br><span class="line">                        .mData = decodedData.mBuffers[0].mData,</span><br><span class="line">                        .mDataByteSize = decodedData.mBuffers[0].mDataByteSize,</span><br><span class="line">                        .mNumberChannels = _canonicalAsbd.mChannelsPerFrame</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                </span><br><span class="line">                AudioBufferList encodedData;</span><br><span class="line">                encodedData.mNumberBuffers = 1;</span><br><span class="line">                encodedData.mBuffers[0].mNumberChannels = _destinationAsbd.mChannelsPerFrame;</span><br><span class="line">                encodedData.mBuffers[0].mDataByteSize = _encodeBufferSize;</span><br><span class="line">                encodedData.mBuffers[0].mData = _encodeBuffer;</span><br><span class="line">                </span><br><span class="line">                while (1)</span><br><span class="line">                &#123;</span><br><span class="line">                    ioOutputDataPackets2 = _encodePacketsPerBuffer;</span><br><span class="line">                    </span><br><span class="line">                    encodingStatus = AudioConverterFillComplexBuffer(_encodeConverterRef, AudioConverterCallback, (void*)&amp;encodeConvertInfo, &amp;ioOutputDataPackets2, &amp;encodedData, _encodePacketDescriptions);</span><br><span class="line">                    </span><br><span class="line">                    if (encodingStatus == OS_STATUS_DONE || encodingStatus == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //一个buffer 转码成功</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        [self failureOccurred];</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (encodingStatus == OS_STATUS_DONE)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // End encoding</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [self failureOccurred];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (decodingStatus == OS_STATUS_DONE)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="文件转码"><a href="#文件转码" class="headerlink" title="文件转码"></a>文件转码</h3><pre><code>使用函数 ExtAudioFileRead
</code></pre><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> startConvert(ExtAudioConverterSettings* settings)&#123;</span><br><span class="line">    <span class="comment">//Determine the proper buffer size and calculate number of packets per buffer</span></span><br><span class="line">    <span class="comment">//for CBR and VBR format</span></span><br><span class="line">    <span class="built_in">UInt32</span> sizePerBuffer = <span class="number">32</span>*<span class="number">1024</span>;<span class="comment">//32KB is a good starting point</span></span><br><span class="line">    <span class="built_in">UInt32</span> framesPerBuffer = sizePerBuffer/<span class="keyword">sizeof</span>(SInt16);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allocate destination buffer</span></span><br><span class="line">    SInt16 *outputBuffer = (SInt16 *)malloc(<span class="keyword">sizeof</span>(SInt16) * sizePerBuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        AudioBufferList outputBufferList;</span><br><span class="line">        outputBufferList.mNumberBuffers              = <span class="number">1</span>;</span><br><span class="line">        outputBufferList.mBuffers[<span class="number">0</span>].mNumberChannels = settings-&gt;outputFormat.mChannelsPerFrame;</span><br><span class="line">        outputBufferList.mBuffers[<span class="number">0</span>].mDataByteSize   = sizePerBuffer;</span><br><span class="line">        outputBufferList.mBuffers[<span class="number">0</span>].mData           = outputBuffer;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UInt32</span> framesCount = framesPerBuffer;</span><br><span class="line">        </span><br><span class="line">        CheckError(ExtAudioFileRead(settings-&gt;inputFile,</span><br><span class="line">                                    &amp;framesCount,</span><br><span class="line">                                    &amp;outputBufferList),</span><br><span class="line">                   <span class="string">"ExtAudioFileRead failed"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (framesCount==<span class="number">0</span>) &#123;</span><br><span class="line">            printf(<span class="string">"Done reading from input file\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CheckError(ExtAudioFileWrite(settings-&gt;outputFile,</span><br><span class="line">                                     framesCount,</span><br><span class="line">                                     &amp;outputBufferList),</span><br><span class="line">                   <span class="string">"ExtAudioFileWrite failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a><a href="http://download.csdn.net/download/qihongru1227/9326777" target="_blank" rel="noopener">代码下载</a></h3><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p><a href="https://developer.apple.com/library/ios/documentation/MusicAudio/Conceptual/CoreAudioOverview/SupportedAudioFormatsMacOSX/SupportedAudioFormatsMacOSX.html" target="_blank" rel="noopener">苹果官网</a></p>
<hr>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">water</p>
              <p class="site-description motion-element" itemprop="description">不积跬步，无以致千里；不积小流，无以成江海。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">18</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">water</span>

  

  
</div>


  <div class="powered-by">Powered by <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.0.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.0"></script>

  <script src="/js/src/motion.js?v=7.0.0"></script>



  
  


  <script src="/js/src/schemes/muse.js?v=7.0.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=7.0.0"></script>


  
  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
