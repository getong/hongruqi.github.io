<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hongru&#39;s 博客</title>
  
  <subtitle>重剑无锋，大巧不工</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hongruqi.github.io/"/>
  <updated>2019-02-23T06:27:38.281Z</updated>
  <id>https://hongruqi.github.io/</id>
  
  <author>
    <name>water</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://hongruqi.github.io/2019/02/22/%E9%AB%98%E6%95%88%20Dart-%20Style/"/>
    <id>https://hongruqi.github.io/2019/02/22/高效 Dart- Style/</id>
    <published>2019-02-22T07:31:40.742Z</published>
    <updated>2019-02-23T06:27:38.281Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:高效 Dart<br>date:2019-01-19</p><h2 id="categories-Flutter"><a href="#categories-Flutter" class="headerlink" title="categories:Flutter"></a>categories:Flutter</h2><h1 id="高效-Dart"><a href="#高效-Dart" class="headerlink" title="高效 Dart"></a>高效 Dart</h1><p>良好的代码风格至关重要。一致的命名规则，顺序结构和格式化有助于代码看起来相同。它利用了我们视觉系统的模式匹配能力。如果我们在整个Dart生态系统中使用一致的风格，那么我们所有人都可以更轻松地学习和修改彼此的代码。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>使用UpperCamelCase 命名类型.</li><li>使用lowercase_with_underscores命名库和源文件.</li><li>使用lowercase_with_underscores命名导入前缀.</li><li>使用lowerCamelCase 命名其他标识符.</li><li>推荐使用lowerCamelCase 命名常量.</li><li>使用首字母大写和缩略词长度超过两个字母.</li><li>不要使用字母前缀.</li></ul><h3 id="导入库顺序"><a href="#导入库顺序" class="headerlink" title="导入库顺序"></a>导入库顺序</h3><ul><li>“dart:”放在文件最上面.</li><li>“package:”放在相关库前面.</li><li>推荐“third-party” “package:”放在其他库前面.</li><li>在所有导入后，指定单独的部分.</li><li>其他部分，按照字母顺序进行排序.</li></ul><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><ul><li>使用dartfmt 格式化代码.</li><li>考虑更改代码使其更容易格式化.</li><li>避免每行超过80个字符.</li><li>使用{}进行流程控制.</li></ul><h2 id="标识符-1"><a href="#标识符-1" class="headerlink" title="标识符"></a>标识符</h2><p>Dart中的标志符，有三种风格。</p><ul><li><p>UpperCamelCase 每个单词的首字母大写，包括第一个单词.</p></li><li><p>lowerCamelCase 第一个单词首字母小写（即使是缩略词），其他单词的首字母大写.</p></li><li><p>lowercase_with_underscores 只使用小写字母，即使是首字母，缩略词，也只是用 _ 分隔.</p></li></ul><h3 id="使用UpperCamelCase-命名类型"><a href="#使用UpperCamelCase-命名类型" class="headerlink" title="使用UpperCamelCase 命名类型"></a>使用UpperCamelCase 命名类型</h3><p>类, 枚举, typedefs, 和 类型参数应该大写每个单词的首字母, 并使用分隔符.</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/23/167d9b91128620bb?w=1898&amp;h=292&amp;f=png&amp;s=48019" alt="1"></p><p>甚至包括元数据注释<br><img src="https://user-gold-cdn.xitu.io/2018/12/23/167d9ba9c9b5bfc7?w=1898&amp;h=460&amp;f=png&amp;s=53087" alt="2"></p><p>如果注释类的构造函数不带参数，则可能需要为其创建单独的lowerCamelCase常量。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167de4525683f921?w=1896&amp;h=248&amp;f=png&amp;s=28435" alt></p><h3 id="使用lowercase-with-underscores命名库和源文件"><a href="#使用lowercase-with-underscores命名库和源文件" class="headerlink" title="使用lowercase_with_underscores命名库和源文件"></a>使用lowercase_with_underscores命名库和源文件</h3><p>某些文件系统不区分大小写，因此许多项目要求文件名全部为小写。 使用分隔字符可以确保可读性。使用下划线作为分隔符可确Dart标识符有效，如果Dart稍后支持符号导入，可以避免兼容问题。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167de4642534cc71?w=1896&amp;h=256&amp;f=png&amp;s=41718" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167de46709a3c008?w=1896&amp;h=250&amp;f=png&amp;s=41641" alt></p><blockquote><p>Note: 如果使用标准规则命名库，你可以在库文件省略说明</p></blockquote><h3 id="使用lowercase-with-underscores命名导入前缀"><a href="#使用lowercase-with-underscores命名导入前缀" class="headerlink" title="使用lowercase_with_underscores命名导入前缀"></a>使用lowercase_with_underscores命名导入前缀</h3><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167de562af8158b8?w=1896&amp;h=256&amp;f=png&amp;s=58347" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167de5645d44a46f?w=1896&amp;h=246&amp;f=png&amp;s=57461" alt></p><h3 id="使用lowerCamelCase-命名其他标识符"><a href="#使用lowerCamelCase-命名其他标识符" class="headerlink" title="使用lowerCamelCase 命名其他标识符"></a>使用lowerCamelCase 命名其他标识符</h3><p>类成员，顶级定义，变量，参数和命名参数应该大写除第一个单词之外的每个单词的第一个字母，并且不使用分隔符。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167deb0453cd6966?w=1894&amp;h=380&amp;f=png&amp;s=45744" alt></p><h3 id="推荐使用lowerCamelCase-命名常量"><a href="#推荐使用lowerCamelCase-命名常量" class="headerlink" title="推荐使用lowerCamelCase 命名常量"></a>推荐使用lowerCamelCase 命名常量</h3><p>在新代码中，使用lowerCamelCase作为常量变量，包括枚举值。 在使用SCREAMING_CAPS的现有代码中，您可以继续使用全部大写以保持一致。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167deb1db767f463?w=1894&amp;h=378&amp;f=png&amp;s=66289" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167deb22fc3f732f?w=1896&amp;h=374&amp;f=png&amp;s=64710" alt></p><blockquote><p>Note: 我们最初使用Java的SCREAMING_CAPS样式来表示常量。 但我们改变了，因为：<br>-SCREAMING_CAPS在许多情况下都很糟糕，特别是像CSS颜色这样的枚举值.<br>。<br>在枚举类型上自动定义的values属性是const和lowercase。</p><ul><li>常量通常最终更改为非常量变量，这将需要更改名称.</li><li>在枚举类型上自动定义变量属性是常量和 lowercase.</li></ul></blockquote><h3 id="使用首字母大写和缩略词长度超过两个字母"><a href="#使用首字母大写和缩略词长度超过两个字母" class="headerlink" title="使用首字母大写和缩略词长度超过两个字母"></a>使用首字母大写和缩略词长度超过两个字母</h3><p>大写的首字母缩略词可能难以阅读，而多个相邻的首字母缩略词可能会导致模糊的名称。 例如，如果名称以HTTPSFTP开头，则无法判断它是指HTTPS FTP还是HTTP SFTP。<br>为了避免这种情况，首字母缩略词和缩写词像普通词一样大写，除了两个字母的首字母缩略词。 （像ID和Mr.这样的两个字母的缩写仍然像文字一样大写。）</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dec025d71b941?w=1898&amp;h=334&amp;f=png&amp;s=38021" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dec060da536b2?w=1896&amp;h=334&amp;f=png&amp;s=35438" alt></p><h3 id="不要使用字母前缀"><a href="#不要使用字母前缀" class="headerlink" title="不要使用字母前缀"></a>不要使用字母前缀</h3><p>匈牙利命名法和其他方案出现在BCPL时，当时的编译器不能做太多，帮助您理解代码。 因为Dart可以告诉您声明的类型，作用域，可变性和其他属性，所以没有必要在标识符名称中对这些属性进行编码。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dec15c5f5bd32?w=1896&amp;h=122&amp;f=png&amp;s=16186" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dec1784987d6a?w=1894&amp;h=124&amp;f=png&amp;s=15647" alt></p><h2 id="包导入顺序"><a href="#包导入顺序" class="headerlink" title="包导入顺序"></a>包导入顺序</h2><p>为了使文件的序言保持整洁，我们有规定的出现顺序。每个“部分”用空行分隔。</p><h3 id="“dart-”放在文件最上面"><a href="#“dart-”放在文件最上面" class="headerlink" title="“dart:”放在文件最上面"></a>“dart:”放在文件最上面</h3><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167ded58f661117e?w=1896&amp;h=292&amp;f=png&amp;s=49042" alt></p><h3 id="“package-”放在相关库前面"><a href="#“package-”放在相关库前面" class="headerlink" title="“package:”放在相关库前面"></a>“package:”放在相关库前面</h3><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167ded6be2c21fac?w=1898&amp;h=252&amp;f=png&amp;s=40377" alt></p><h3 id="推荐“third-party”-“package-”放在其他库前面"><a href="#推荐“third-party”-“package-”放在其他库前面" class="headerlink" title="推荐“third-party” “package:”放在其他库前面"></a>推荐“third-party” “package:”放在其他库前面</h3><p>如果您导入许多自己的包和其他第三方包，请您在外部软件包之后加上空行进行分隔。</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dedc052360506?w=1904&amp;h=248&amp;f=png&amp;s=47019" alt></p><h3 id="在所有导入后，指定单独的部分"><a href="#在所有导入后，指定单独的部分" class="headerlink" title="在所有导入后，指定单独的部分"></a>在所有导入后，指定单独的部分</h3><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dedcb291696e2?w=1898&amp;h=248&amp;f=png&amp;s=38084" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dedcd858a8a83?w=1900&amp;h=210&amp;f=png&amp;s=36161" alt></p><h3 id="其他部分，按照字母顺序进行排序"><a href="#其他部分，按照字母顺序进行排序" class="headerlink" title="其他部分，按照字母顺序进行排序."></a>其他部分，按照字母顺序进行排序.</h3><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dee25adc13f6c?w=1900&amp;h=294&amp;f=png&amp;s=49443" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dee276be003d0?w=1904&amp;h=296&amp;f=png&amp;s=49072" alt></p><h2 id="格式化-1"><a href="#格式化-1" class="headerlink" title="格式化"></a>格式化</h2><p>像许多语言一样，Dart忽略空格。 但是，人类没有。具有一致的空样式有助于确保人类读者与编译器以相同方式查看代码。</p><h3 id="使用dartfmt-格式化代码"><a href="#使用dartfmt-格式化代码" class="headerlink" title="使用dartfmt 格式化代码"></a>使用dartfmt 格式化代码</h3><p>格式化是一项繁琐的工作，在重构过程中特别耗时。 幸运的是，你不必担心它。 我们提供了一个名为dartfmt的复杂自动代码格式化程序，它可以为您完成。 我们提供了使用文档，但是Dart的官方空白处理规则是dartfmt产生的。</p><p>其余格式化指南，适用于dartfmt无法为您修复的一些内容。</p><hr><p>title: Effective Dart: Style<br>date: 2018-12-24 </p><h2 id="categories-Flutter-1"><a href="#categories-Flutter-1" class="headerlink" title="categories: Flutter"></a>categories: Flutter</h2><h1 id="Effective-Dart-Style"><a href="#Effective-Dart-Style" class="headerlink" title="Effective Dart: Style"></a>Effective Dart: Style</h1><h3 id="考虑更改代码使其更容易格式化"><a href="#考虑更改代码使其更容易格式化" class="headerlink" title="考虑更改代码使其更容易格式化"></a>考虑更改代码使其更容易格式化</h3><p>格式化程序会对你写的代码竭尽全力，但它不是神。 如果您的代码具有特别长的标识符，深层嵌套的表达式，混合不同类型的运算符等问题，这样即使格式化，输出代码仍然难以阅读。</p><p>发生这种情况时，应该重新组织或简化您的代码。 考虑缩短局部变量名称或将表达式提升到新的局部变量中。 换句话说，如果您手动格式化代码并尝试使其更具可读性，请进行相同类型的修改。 当写代码时将dartfmt视为一种合作关系，有时可以迭代地生成漂亮的代码。</p><h3 id="避免每行超过80个字符"><a href="#避免每行超过80个字符" class="headerlink" title="避免每行超过80个字符"></a>避免每行超过80个字符</h3><p>可读性研究表明，长行文字难以阅读，因为当你移动到下一行的开头时，你的眼睛必须走得更远。 这就是为什么报纸和杂志使用多列文本。</p><p>如果你真的发现自己想要超过80个字符的行，我们的经验是你的代码可能过于冗长并且可能更紧凑。 主要问题通常是VeryLongCamelCaseClassNames。 问问自己，“该类型名称中的每个单词是否告诉我一些关键信息或防止名称冲突？”如果不是，请考虑省略它。</p><p>请注意，dartfmt会为您完成99％，但最后1％需要您完成。 它不会将长字符串文字拆分为80列，因此您必须手动执行此操作。</p><p>我们对URI和文件路径进行了额外处理。当这些出现在注释或字符串中时（通常在导入和导出中），即使超出行限制，它们也可能保留在一行中。这样可以更轻松地搜索指定路径的源文件。</p><h3 id="使用-进行流程控制"><a href="#使用-进行流程控制" class="headerlink" title="使用{}进行流程控制"></a>使用{}进行流程控制</h3><p>避免悬空问题<br><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dee3394f44da8?w=1900&amp;h=296&amp;f=png&amp;s=46387" alt></p><p>有一个例外：一个没有else子句的if语句，其中整个if语句和执行语句适合一行。 在这种情况下，如果您愿意，可以不用括号：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dee377b31e2aa?w=1898&amp;h=130&amp;f=png&amp;s=22434" alt></p><p>如果正文包裹到下一行，请使用大括号：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dee3ee05316fa?w=1906&amp;h=208&amp;f=png&amp;s=40920" alt></p><p><img src="https://user-gold-cdn.xitu.io/2018/12/24/167dee418eb1c70a?w=1904&amp;h=170&amp;f=png&amp;s=35921" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title:高效 Dart&lt;br&gt;date:2019-01-19&lt;/p&gt;
&lt;h2 id=&quot;categories-Flutter&quot;&gt;&lt;a href=&quot;#categories-Flutter&quot; class=&quot;headerlink&quot; title=&quot;categories:
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Uber 新架构 RIBs 的前世今生</title>
    <link href="https://hongruqi.github.io/2019/02/22/Uber%20RIBs%20%E6%9E%B6%E6%9E%84/"/>
    <id>https://hongruqi.github.io/2019/02/22/Uber RIBs 架构/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-23T06:01:19.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uber-新架构-RIBs-的前世今生"><a href="#Uber-新架构-RIBs-的前世今生" class="headerlink" title="Uber 新架构 RIBs 的前世今生"></a>Uber 新架构 RIBs 的前世今生</h1><p><a href="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/new_rider_app.jpg" target="_blank" rel="noopener"><img src="https://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/new_rider_app.jpg" alt title="new_rider_app"></a></p><h3 id="为什么-Uber-要重构移动端"><a href="#为什么-Uber-要重构移动端" class="headerlink" title="为什么 Uber 要重构移动端"></a>为什么 Uber 要重构移动端</h3><p>Uber 基于一个简单的概念：一键出行。 从最初优享到现在提供的一系列产品，每天在数百个城市协调数百万次乘车。 为了应对和支持2017年及以后的发展，我们迫切的需要重新设计我们的移动端架构。</p><p>但从哪里开始？ 我们决定重新开始。于是我们决定完全重构并重新<a href="https://medium.com/uber-design/designing-the-new-uber-app-16afcc1d3c2e#.wio2h7epr" target="_blank" rel="noopener">设计</a>我们的<a href="https://ride.uber.com/en_US/" target="_blank" rel="noopener">乘客端</a>。 由于不用被之前的设计和代码限制，在重构上我们有很大的发挥空间。<a href="https://newsroom.uber.com/newriderapp/" target="_blank" rel="noopener">结果就是你今天看到的这个时尚的新应用</a>, 它在iOS和Android上实现了新的移动架构。接下来的文章将介绍我们的新移动端架构 Riblets，让你了解为什么我们需要创建这种新架构模式，以及它如何帮助我们达成目标。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>虽然共享出行仍然是 Uber 背后的驱动理念，但我们的产品已发展成为功能复杂的APP，我们原有的移动架构无法与之匹配。 随着乘客端App的新功能扩展，工程挑战和技术债务不断累积。增加了诸如<a href="https://newsroom.uber.com/us-california/its-a-beautiful-pool-day-in-the-neighborhood/" target="_blank" rel="noopener">拼车</a> ，<a href="https://www.uber.com/info/scheduled-rides/" target="_blank" rel="noopener">预约乘车</a> 和促销车辆视图等功能，导致工程的复杂性逐步升高。 我们的行程模块变得越来越大，难以测试。 加入小变化有可能影响到应用程序的其他部分，使得功能尝试增加额外调试任务，从而抑制了我们快速迭代和功能实验。 为了给所有 Uber 用户的高质量体验，我们需要一种方法，重新找回起点的简单，同时考虑今天的处境和未来的目标。</p><p>对于乘客和 Uber 工程师来说，新的应用程序必须简单。 为了适用于不同的群体，我们的两个主要目标是：持续增加有效的核心用户体验，并且允许在系列产品需求序列中做大胆实验。</p><h4 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h4><p>从工程方面来说，我们正在努力使 Uber 的行程主流程的可靠性达到 99.99％。 实现99.99％的可靠性意味着我们每年只能有一个累计小时的停机时间，一周的停机时间为一分钟，每10,000次运行只有一次失败。</p><p>为了实现这一目标，新架构定义并实现了核心和可选代码的框架。 核心代码包括注册，获取，完成或取消行程所需的一切代码。 对核心代码的更改和添加需要经过严格的审核流程。 可选代码可以降低审查力度，可以在不停止核心业务的情况下关闭。 这种代码隔离机制使我们能够尝试新功能，并在异常情况下自动关闭它们，而不会干扰乘车体验。</p><h4 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h4><p>我们需要一个平台，一百个不同的项目团队和数千名工程师可以快速构建高质量的功能，并在乘客端上进行创新，而不会影响核心用户体验。 因此，我们提供了新的移动端架构，具有跨平台兼容性，确保iOS和Android工程师都可以在统一的基础上工作。</p><p>从历史上看，在 iOS 和 Android 上发布最好的应用程序涉及不同的架构、库设计和分析方法。 但是，新架构致力于在两个平台上使用相同的最佳模式和实践。 这给了我们学习两个平台的机会。 由于一个平台的经验教训可以预先解决另一个平台上的问题，从而避免了同样的错误在两个平台重复出现。 因此，iOS 和 Android 工程师可以更轻松地进行协作，并且可以并行处理新功能。</p><p>虽然在某些情况下，平台之间可以也应该是不同的(例如 UI 实现)，但是 iOS 和 Android 移动平台都是从一致性出发。平台共享:</p><ul><li>核心架构</li><li>类名</li><li>业务逻辑单元之间的继承关系</li><li>业务逻辑如何划分</li><li>插件点 (名字, 存在,结构等)</li><li>响应式编程链</li><li>统一平台组件</li></ul><p>为了实现平台之间的这种通用蓝图，我们的新移动架构需要清晰的组织和分离业务逻辑，视图逻辑，数据流和路由。这种架构有助于降低复杂性，简化可测试性，从而提高工程效率和用户可靠性。 我们在其他架构模式上进行了创新以实现此目标。</p><h3 id="从-MVC-到-Riblets"><a href="#从-MVC-到-Riblets" class="headerlink" title="从 MVC 到 Riblets"></a>从 MVC 到 Riblets</h3><p>考虑到我们的两个目标，我们调查了旧架构可以改进的地方，并研究了可行的方案。Uber 旧的代码遵循[MVC 模式]（<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html）。我们调查了其他模式，特别是[VIPER]（https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework），我们最终用它来创建" target="_blank" rel="noopener">https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/MVC.html）。我们调查了其他模式，特别是[VIPER]（https://mutualmobile.com/posts/meet-viper-fast-agile-non-lethal-ios-architecture-framework），我们最终用它来创建</a> Riblets。Riblets 的核心创新是业务逻辑驱动，而不是视图逻辑驱动。 如果您不熟悉 MVC 和 VIPER，请阅读一些[关于现代 iOS 架构模式的文章]（<a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.ba5863nnx），然后回过头来看看在" target="_blank" rel="noopener">https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52#.ba5863nnx），然后回过头来看看在</a> Uber 采用它们的利弊。</p><h4 id="MVC-Model-View-Controller"><a href="#MVC-Model-View-Controller" class="headerlink" title="MVC (Model-View-Controller)"></a>MVC (Model-View-Controller)</h4><p>乘客端应是在大约四年前由少数几个工程师创建的。 虽然 MVC 模式在当时是有意义的，但随着程序的规模越来越大，也就越来越难以管理。 随着业务的增长和团队的扩大， MVC 的弊端越发明显。具体来说，有两大问题：</p><p>首先，成熟的 MVC 架构经常面临<a href="https://www.smashingmagazine.com/2016/05/better-architecture-for-ios-apps-model-view-controller-pattern/" target="_blank" rel="noopener">重量级视图控制器</a>的困境。例如，RequestViewController 刚开始有 300 行代码，由于处理了太多的功能（业务逻辑，数据操作，数据验证，网络逻辑，路由逻辑等），现在超过 3,000 行。它变得难以阅读和维护。</p><p>其次，MVC 架构的更新过程是不易维护和测试的。我们进行了大量实验，为用户推出了新功能。 这些实验归结为 if-else 语句。 每当将 if-else 语句构建在一个具有许多功能函数的类上时，导致几乎无法推理，更不用说测试了。 此外，由于像RequestViewController 和 TripViewController 代码巨大并且快速增长，因此对应用程序进行更新变得更加空难。 想象一下，进行更改并测试嵌套 if-else 实验的每种可能组合将是多么的困难。由于我们需要实验来继续添加新功能并增加 Uber 的业务，因此这种架构不具备可扩展性。</p><h4 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h4><p>在考虑 MVC 的替代方案时，我们受到 VIPER 架构的启发。<a href="https://mutualmobile.com/in-the-news/architecting-ios-apps-viper" target="_blank" rel="noopener">适用于</a> iOS 应用程序的<a href="https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html" target="_blank" rel="noopener">简洁架构</a>。VIPER 为 MVC 提供了一些关键优化。首先，它提供了更多的抽象。Presenter 桥接视图逻辑和业务逻辑。Interactor 处理纯粹的数据操作和数据验证，包括向服务层发起调用，例如登录或者发单。最后，Router 启动跳转，例如将用户从首页带到确认页。其次，使用 VIPER 方法，Presenter 和 Interactor 是普通对象，因此我们可以进行简单的单元测试。</p><p>但我们也发现了 VIPER 的一些缺点。它是 iOS 独有架构，意味着我们必须为 Android 做出权衡。由于整个应用程序被固定在视图树上，也就意味着状态由视图驱动。 Interactor 必须通过 Presenter 操作应用程序的业务逻辑，因此需要暴露业务逻辑给 Presenter。至此，通过紧密耦合的视图树和业务树，很难实现仅包含业务逻辑或仅包含视图逻辑的业务节点，无法达到解藕的目的。</p><p>虽然 VIPER 对使用的 MVC 模式进行了重大改进，但它并没有完全满足，清晰的模块化定义，和高可扩展性。所以我们在兼顾 VIPER 优势，同时规避其架构模式缺点的基础上，实现了我们自己的架构： Riblets。</p><h3 id="Riblets-Uber-乘客端架构"><a href="#Riblets-Uber-乘客端架构" class="headerlink" title="Riblets: Uber 乘客端架构"></a>Riblets: Uber 乘客端架构</h3><p>在我们的新架构模式中，业务逻辑被分解为小的，可独立测试的单元，每个单元目的明确，遵循单一责任原则。 我们使用 Riblets 作为这些模块化部件，整个应用程序结构为 Riblets 树。</p><h4 id="Riblets-组件"><a href="#Riblets-组件" class="headerlink" title="Riblets 组件"></a>Riblets 组件</h4><p>通过 Riblets，我们将职责分配给六个不同的组件，进一步抽象业务和视图逻辑：</p><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblets.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblets.png" alt></a></p><p>Riblets 与 VIPER 和 MVC 的区别是什么？路由由业务逻辑而非视图逻辑引导。这意味着应用程序由信息流和决策流驱动，而不是 Presenter。在Uber，并非每个业务逻辑都与用户看到的视图相关。不是将业务逻辑集中到 MVC 中的 ViewController 或通过 VIPER 中的 Presenter 操作应用程序状态。我们可以为每个业务逻辑提供不同的 Riblets，这些 Ribltes 可以组合出不同意义的逻辑分组。 Riblet 模式被设计为​​跨平台的，达到统一 Android 和 iOS 架构的目的。</p><p>每个 Riblet 由 <strong>R</strong>outer，<strong>I</strong>nteractor 和 <strong>B</strong>uilder 及其 Component 和可选的 Presenters 和 Views 组成。Router 和 Interactor 处理业务逻辑，而 Presenter 和 View 处理视图逻辑。</p><p>让我们使用车型切换 Riblet 作为示例，确定每个 Riblet 单元负责的内容。</p><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/product_selction.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/product_selction.png" alt></a></p><p>新乘客端APP，车型切换功能。</p><h4 id="Builder"><a href="#Builder" class="headerlink" title="Builder"></a>Builder</h4><p>Builder 实例化所有主要 Riblet 单元并定义依赖关系。 在车型切换 Riblet 中，此单元定义城市流（特定城市的数据流）依赖关系。</p><h4 id="Component"><a href="#Component" class="headerlink" title="Component"></a>Component</h4><p>Component 获取并实例化 Riblet 的依赖项。 这包括服务，数据流以及其他不是主要 Riblet 单元的内容。 车型切换组件获取并实例化城市流依赖关系，将其与对应的网络事件进行关联，并将其注入到 Interactor。</p><h4 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h4><p>Routers 通过添加和删除 子Riblets 形成应用程序树，同时驱动组件内 Interactor 的生命周期。 这些决定由外部 Interactor 传递。路由器包含两个业务逻辑：</p><ol><li>添加和删除组件</li><li>子组件间状态切换</li></ol><p>车型切换 Riblet 没有任何子 Riblets。 其父 Riblet 的 Router， 确认 Riblet 负责添加车型切换的 Router 并将其 Views 添加到 View 层次结构中。 然后，一旦选择了车型，车型切换 Router 将停用其 Interactor。</p><h4 id="Interactors"><a href="#Interactors" class="headerlink" title="Interactors"></a>Interactors</h4><p>Interactors 执行业务逻辑：</p><ul><li>调用服务来启动操作，比如请求搭车</li><li>调用服务来获取数据</li><li>决定要转换到下一个的状态。 例如，如果根 Interactor 监听到用户的身份验证令牌过期，它会向其 Router 发送切换到 “欢迎” 状态的请求。</li></ul><p>车型切换 Interactor 包含城市流数据，包括该城市服务的车型，定价信息，预估行程时间和车辆视图。 它将此信息传递给 Presenter。 如果用户从拼车切换到优享，则 Interactor 会从 Presenter 接收此信息。 然后它会收集相关数据传给 View，这样它就可以显示 uberX 车辆和预估行程时间。 简而言之，Interactor 执行随后 View 中显示的所有业务逻辑。</p><h4 id="View-Controller"><a href="#View-Controller" class="headerlink" title="View (Controller)"></a>View (Controller)</h4><p>视图构建和更新UI，包括实例化和布局 UI 组件，处理用户交互，UI 组件数据填充和动画。 车型切换 Riblet 的 View 显示它从 Presenter 接收的数据（车型选项，定价，ETA，地图上的车辆视图）并反馈用户操作（即车型切换）。</p><h4 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h4><p>Presenters 管理 Interactors 和 Views 之间的通信。 从 Interactors 到 Views，Presenter 将业务模型转换为 View 可以显示的模型。 对于车型切换，这包括定价数据和车辆视图。 从 Views 到 Interactors，Presenters 将用户交互事件（例如，点击按钮选择车型）转换为 Interactors 中的相应操作。</p><h3 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h3><p>Riblets 只有一个 Router 和 Interactor，但可以有多个 View 部分。仅处理业务逻辑且没有用户界面元素的 Riblet 没有视图部分。 因此，Riblets 可以是单视图（一个 Presenter 和一个 View），多视图（一个 Presenter 和多个 Views，或多个 Presenter 和 Views），或者是无视图（没有 Presenter 和 View）。 这允许业务逻辑树的结构和深度与视图树不同，视图树将具有更平坦的层次结构。 这有助于简化页面切换。</p><p>例如，乘车 Riblet 是一个无视图的 Riblet，用于检查用户是否有有效的行程。如果已经开始行程，它添加行程 Riblet，将行程显示在地图上。如果没有，它将添加请求 Riblet，请求 Riblet 将在屏幕显示，允许用户请求行程。像乘车 Riblet 这样没有视图逻辑的 Riblet，通过分解业务逻辑驱动应用程序，在支持这种新体系结构的模块化方面，发挥了重要作用。</p><h3 id="Riblets-构建应用程序"><a href="#Riblets-构建应用程序" class="headerlink" title="Riblets 构建应用程序"></a>Riblets 构建应用程序</h3><p>Riblets 组成了应用程序树，并且经常需要进行通信以便更新信息或将用户带到下一阶段。 在我们讨论他们如何通信之前，让我们首先了解数据在一个 Riblet 中是如何流动的。</p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>Interactors 拥有状态的作用范围和业务逻辑。该单元进行服务调用获取数据。 在新架构中，数据是单方向流动的。 它从 Service 到 Model Stream，然后从 Model Stream 到 Interactor。 来自服务器的交互，调度和推送通知可以要求 Service 对 Model Stream 进行更改。Model Stream 生成不可变模型。 这强制要求 Interactors 类必须使用服务层来更改应用程序的状态。</p><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/data_flow.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/data_flow.png" alt></a></p><p>示例流程：</p><ul><li><p><strong>从后端服务到视图:</strong> 服务调用（如状态）从后端获取数据。 将数据放置在不可变 Model Stream 上。 Interactor 监听新数通知并将其传递给 Presenter。 Presenter 格式化数据并将其发送给 View。</p></li><li><p><strong>从视图到后端:</strong> 用户点击按钮（如登录），然后 View 将交互传递给 Presenter。 Presenter 在 Interactor 上调用登录方法，该方法调用 Service 进行登录。 返回的令牌由 Service 在数据流上发布。 Interactor 监听数据流，收到通知后 Interactor 切换 Riblet 到首页 Riblet。</p></li></ul><h4 id="Riblets-间通信"><a href="#Riblets-间通信" class="headerlink" title="Riblets 间通信"></a>Riblets 间通信</h4><p><a href="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblet_comms.png" target="_blank" rel="noopener"><img src="http://1fykyq3mdn5r21tpna3wkdyi-wpengine.netdna-ssl.com/wp-content/uploads/2016/12/riblet_comms.png" alt></a></p><p>当 Interactor 做出业务逻辑决策时，它可能需要通知另一个 Riblet（例如，完成）并发送数据。为实现此目的，做出业务逻辑决策的 Interactor 调用另一个 Riblet 的 Interactor 。</p><p>通常，如果通信是 Riblet 树上，从子 Riblet 传递到父 Riblet 的 Interactor，则该接口被定义为侦听器。侦听器几乎总是由父 Riblet 的 Interactor 实现。如果通信向下传递给子 Riblet，则应将接口定义为代理，并由子 Riblet 的 Interactor 实现。代理仅用于 Riblet 单元之间的同步通信，例如父 Interactor 与子 Interactor 之间的同步。</p><p>特别是对于向下通信，作为代理的替代方法, 父 Riblet 可以选择将可观察的数据流暴露给子 Riblet 的 Interactor。然后，父 Riblet 的 Interactor 可以通过此流将数据发送到子 Riblet 的 Interactor。在大多数用于发送数据的向下通信中，这应该是首选的通信方法。</p><p>例如，车型切换 Interactor 确定已选择车型时，它会调用其侦听器以传递所选的车辆视图 ID。侦听器由确认 Interactor实现。然后，确认 Interactor 存储车辆视图 ID，以便可以在服务请求中发送，调用其 Router 分离车型切换 Riblet。</p><p>通过以上方式构建 Riblets 内部和 Riblets 之间的数据流通信，我们能够确保在正确的页面正确的时间出现正确的数据。因为 Riblets 基于业务逻辑形成应用程序树，所以我们可以通过业务逻辑（而不是视图逻辑）来路由通信。这对我们的业务意义重大，并最终有助于代码隔离，防止应用程序开发变得过于复杂。</p><h3 id="回到起点"><a href="#回到起点" class="headerlink" title="回到起点"></a>回到起点</h3><p>当我们重新开始乘客端时，希望提高乘客体验的可靠性和为未来的应用程序开发建立标准规范。创建新架构对于实现这两个目标至关重要。</p><h4 id="如何提高乘车体验的可靠性"><a href="#如何提高乘车体验的可靠性" class="headerlink" title="如何提高乘车体验的可靠性 ?"></a>如何提高乘车体验的可靠性 ?</h4><p>Riblets 有明确的职责划分，因此测试更加简单。每个 Riblet 都是可独立测试的。通过更充分的测试，当推出更新时，我们可以对应用的可靠性更有信心。由于每个 Riblet 只负责一个任务，因此很容易将 Riblet 及其依赖项分离到核心代码和可选代码中。通过对核心代码进行更严格的审查，我们可以对核心流程的可用性更有信心。</p><p>我们提供了核心流程全局回滚到可用状态的能力。所有可选代码都具备开关能力，如果部分功能有问题，可以将其关闭。在最糟糕的情况下，我们可以关闭全部可选代码，保留默认的核心流程。由于我们在核心代码上有超高的标准，可以确保我们的核心流程始终有效。</p><h4 id="如何为开发建立标准规范"><a href="#如何为开发建立标准规范" class="headerlink" title="如何为开发建立标准规范 ?"></a>如何为开发建立标准规范 ?</h4><p>Riblets 帮助我们尽可能缩小和分离功能。清晰的分离业务和视图逻辑，将有助于防止我们的代码库变得过于复杂并使其易于工作。由于新架构与平台无关，因此 iOS 和 Android 工程师可以轻松了解对方如何开发，从一方的错误中吸取教训，并共同推动 Uber 向前发展。由于 Riblets 帮助我们将可选代码与核心代码分开，因此实验将不太容易对核心体验产生附带影响。我们将能够在 Riblet 架构中将新功能作为插件进行尝试，而不必担心它们可能会意外地将 uberX 和 uberPOOL 体验置于bug 的风险之中。</p><p>由于 Riblets 加强了抽象和责任分离，并且有明确的数据流和通信路径，因此持续开发变得很容易。这种架构将在未来几年内为我们服务。</p><h3 id="星辰大海"><a href="#星辰大海" class="headerlink" title="星辰大海"></a>星辰大海</h3><p>我们的新架构使我们为未来的发展做好了准备。最新的重构意味着完全重做乘客端的代码，重新实现以前存在的内容，执行用户研究，案例研究，A/B 测试以及编写新功能。最重要的是，我们希望进行全球推广，以便更快地将新应用程序交付给用户，因此我们从设计，功能，本地化，设备和测试角度考虑了全球变化。 虽然已经投放市场，但我们新架构下的工作才刚刚开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Uber-新架构-RIBs-的前世今生&quot;&gt;&lt;a href=&quot;#Uber-新架构-RIBs-的前世今生&quot; class=&quot;headerlink&quot; title=&quot;Uber 新架构 RIBs 的前世今生&quot;&gt;&lt;/a&gt;Uber 新架构 RIBs 的前世今生&lt;/h1&gt;&lt;p&gt;&lt;a
      
    
    </summary>
    
      <category term="翻译" scheme="https://hongruqi.github.io/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter 深入理解 State</title>
    <link href="https://hongruqi.github.io/2019/01/26/Flutter%20%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20State/"/>
    <id>https://hongruqi.github.io/2019/01/26/Flutter 深入理解 State/</id>
    <published>2019-01-25T16:00:00.000Z</published>
    <updated>2019-02-22T07:30:05.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter-深入理解-State"><a href="#Flutter-深入理解-State" class="headerlink" title="Flutter 深入理解 State"></a>Flutter 深入理解 State</h1><p>本文主要介绍 <em>Flutter</em> 应用程序中 <code>Widget</code>，<code>State</code>，<code>Context</code> 和 <code>InheritedWidget</code> 等重要概念。 尤其注意的是 <code>InheritedWidget</code>，它是最重要且介绍较少的 <code>Widget</code> 之一。</p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每个 <code>Flutter</code> 开发人员都需要完全理解 <code>Widget</code>，<code>State</code> 和 <code>Context</code> 概念。</p><p>虽然，有很多文档可以查询，但想要清晰地解释这些概念，还是有一定难度。</p><p>本文会对这些概念进行剖析，力图使你能够进一步了解这些概念：</p><ul><li>有状态和无状态 <code>Widegt</code> 的区别</li><li><code>Context</code> 是什么</li><li><code>State</code> 是什么以及如何使用它</li><li><code>Context</code> 与其 <code>State</code> 对象之间的关系</li><li><code>InheritedWidget</code> 以及在 <code>Widgets</code> 树中传递信息的方式</li><li><code>rebuild</code> 概念</li></ul><h2 id="第一部分：概念"><a href="#第一部分：概念" class="headerlink" title="第一部分：概念"></a>第一部分：概念</h2><h3 id="Widget"><a href="#Widget" class="headerlink" title="Widget"></a>Widget</h3><p>在 <code>Flutter</code> 中，一切都是 <code>Widget</code>。</p><p>将 <code>Widget</code> 视为可视化组件（或可视化交互的组件）。</p><p>当您需要构建直接或间接布局关系时，您正在使用 <code>Widget</code>。</p><h3 id="Widget-树"><a href="#Widget-树" class="headerlink" title="Widget 树"></a>Widget 树</h3><p><code>Widget</code> 是以树结构组织起来的。</p><p>包含其他 <code>Widget</code> 的 <code>Widget</code> 称为父 <code>Widget</code>（或 <code>Widget</code> 容器）。包含在父 <code>Widget</code> 中的 <code>Widget</code> 称为子 <code>Widget</code>。</p><p>以 <code>Flutter</code> 自动生成的应用程序来进行说明。 构建代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">override</span></span><br><span class="line"><span class="function">Widget <span class="title">build</span>(<span class="params">BuildContext</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Scaffold(</span><br><span class="line">      appBar: <span class="keyword">new</span> AppBar(</span><br><span class="line">        title: <span class="keyword">new</span> Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: <span class="keyword">new</span> Center(</span><br><span class="line">        child: <span class="keyword">new</span> Column(</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            <span class="keyword">new</span> Text(</span><br><span class="line">              <span class="string">'You have pushed the button this many times:'</span>,</span><br><span class="line">            ),</span><br><span class="line">            <span class="keyword">new</span> Text(</span><br><span class="line">              <span class="string">'$_counter'</span>,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="keyword">new</span> FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: <span class="string">'Increment'</span>,</span><br><span class="line">        child: <span class="keyword">new</span> Icon(Icons.<span class="keyword">add</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将获得以下 <code>Widget</code> 树（仅限代码中存在的 <code>Widget</code> 列表）：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16874d0cec93c2ef?w=1518&amp;h=1180&amp;f=png&amp;s=280148" alt></p><h3 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context 上下文"></a>Context 上下文</h3><p>另一个重要的概念是 <code>Context</code>。</p><p><code>Context</code> 是构建所有 <code>Widgets</code> 树结构中的 <code>Widget</code> 的位置引用。</p><blockquote><p>简而言之，将 <code>Context</code> 视为 <code>Widgets</code> 树的一部分。</p></blockquote><p>一个 <code>Context</code> 仅属于一个 <code>Widget</code>。同样具有父子关系，如果 <code>Widget A</code> 具有子 <code>Widgets</code>，则 <code>Widget A</code>  的 <code>Context</code> 将成为子 <code>Widget</code> 的 <code>Context</code> 的父 <code>Context</code>。</p><p>很明显，<code>Context</code> 是关联在一起，组成一个 <code>Context</code> 树（父子关系）。</p><p>现在，我们使用上图说明 <code>Context</code> 的概念，每种颜色代表一个 <code>Context</code>（除了 <code>MyApp</code>，它是不同的）：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/22/16874e6d531d0d19?w=1692&amp;h=1294&amp;f=png&amp;s=684662" alt></p><blockquote><p><code>Context</code> 可见性：某些属性只能在其自己的 <code>Context</code> 中或在其父 <code>Context</code> 中可见。</p></blockquote><p>使用这种语法，我们可以从子 <code>Context</code> 追根溯源，很容易找到一个祖先（或者父）<code>Widget</code>。</p><blockquote><p>举例，考虑 <code>Scaffold &gt; Center &gt; Column &gt; Text：context.ancestorWidgetOfExactType（Scaffold）=&gt;</code> 通过从 <code>Text Context</code> 向上查找到顶部 <code>Scaffold</code>。</p></blockquote><p>从父 <code>Context</code> 中，也可以找到后代（=子） <code>Widget</code>，但不建议这样做（我们稍后会讨论）。</p><h3 id="两种-Widgets"><a href="#两种-Widgets" class="headerlink" title="两种 Widgets"></a>两种 Widgets</h3><h3 id="无状态-StatelessWidget"><a href="#无状态-StatelessWidget" class="headerlink" title="无状态 StatelessWidget"></a>无状态 StatelessWidget</h3><p>这些可视组件，只依赖它们自己的配置信息，并不依赖于任何外部信息。这些配置信息在构建时由其父组件提供。</p><p>换句话说，这些 <code>Widgets</code> 一旦创建就不关心任何变化。</p><p>这些 <code>Widgets</code> 被称为无状态 <code>Widgets</code>。</p><p>这些 <code>Widgets</code> 的典型示例是 <code>Text，Row，Column，Container ......</code> 在构建时，我们只是将一些参数传递给它们。</p><p>参数可以是文本，尺寸甚至其他 <code>Widgets</code>。 唯一重要的是这个配置信息一旦应用，在下一个构建过程之前不会改变。</p><blockquote><p>无状态 <code>Widget</code> 只能在加载或者构建 <code>Widget</code> 时绘制一次，这意味着无法基于任何事件或用户操作重绘该 <code>Widget</code>。</p></blockquote><h3 id="StatelessWidget-生命周期"><a href="#StatelessWidget-生命周期" class="headerlink" title="StatelessWidget 生命周期"></a>StatelessWidget 生命周期</h3><p>无状态 <code>Widget</code> 相关的代码的典型结构如下。</p><p>如您所见，我们可以将一些额外的参数传递给它的构造函数。 但是，请记住，这些参数不会在以后阶段发生变化，只能按原样使用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAppStatelessWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">MyAppStatelessWidget</span>(&#123;</span><br><span class="line"><span class="type">Key</span> key,</span><br><span class="line"><span class="keyword">this</span>.parameter,</span><br><span class="line">&#125;): <span class="keyword">super</span>(key:key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> parameter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="type">Widget</span> build(<span class="type">BuildContext</span> context)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StatelessWidget</code> 的另一个方法 <code>createElement</code> 也可以被复写，但你几乎不会这样做。 唯一需要被复写的是 · <code>build</code> 函数。</p><p>这种无状态 <code>Widget</code> 的生命周期很简单：</p><ul><li>初始化</li><li>通过 <code>build</code> 进行渲染</li></ul><h3 id="有状态-StatefulWidget"><a href="#有状态-StatefulWidget" class="headerlink" title="有状态 StatefulWidget"></a>有状态 StatefulWidget</h3><p>某些 <code>Widge</code> 需要处理一些在 <code>Widget</code> 生命周期内会发生变化的内部数据。</p><p>这些 <code>Widget</code> 保存的数据集在 <code>Widget</code> 的生命周期中可能会有所不同，这样的数据集被称为为 <code>State</code>。</p><p>这样的 <code>Widget</code> 被称为有状态 <code>Widget</code>。</p><p>此类 <code>Widget</code> 的示例可以是复选框列表，也可以是根据条件禁用的 <code>Button</code>。</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><code>State</code> 定义 <code>StatefulWidget</code> 实例的 <code>行为</code> 部分。</p><p>它包含 <code>Widget</code> <strong>交互</strong> 的信息：</p><ul><li><strong>行为</strong></li><li><strong>布局</strong></li></ul><blockquote><p>施加于 State 的任何更改都会强制 <code>Widget</code> 重建。</p></blockquote><h3 id="State-与-Context-之间的关系"><a href="#State-与-Context-之间的关系" class="headerlink" title="State 与 Context 之间的关系"></a>State 与 Context 之间的关系</h3><p>对于有状态 <code>Widgets</code>，<code>State</code> 与 <code>Context</code> 相关联。 此关联是永久性的，<code>State</code> 对象永远不会更改其 <code>Context</code>。</p><p>即使可以在 <code>Widgets</code> 树内移动 <code>Widget</code> <code>Context</code> ，<code>State</code> 仍将与该 <code>Context</code> 相关联。</p><p>当 <code>State</code> 与 <code>Context</code> 关联时，<code>State</code> 被视为已挂载。</p><blockquote><p><strong>至关重要：</strong></p></blockquote><blockquote><p>由于<code>State</code> 对象与 <code>Context</code> 相关联，这意味着 <code>State</code> 对象不能（直接）通过另一个 <code>Context</code> 访问！ （我们将在稍后讨论这个问题）。</p></blockquote><h3 id="有状态-Widget-生命周期"><a href="#有状态-Widget-生命周期" class="headerlink" title="有状态 Widget 生命周期"></a>有状态 Widget 生命周期</h3><p>基本概念已经介绍过了，是时候深入了解了。</p><p>由于本文的主要意图是用 “变量” 数据来解释 <code>State</code> 的概念，因此会故意跳过某些与 <code>Stateful Widget</code> 可复写方法相关的任何解释，这些方法与此没有特别的关系。 这些可复写的方法是 <code>didUpdateWidget</code>，<code>deactivate</code>，<code>reassemble</code>。 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefulWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="type">MyStatefulWidget</span>(&#123;<span class="type">Key</span> key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyStatefulWidgetState</span> <span class="keyword">extends</span> <span class="title">State&lt;MyStatefulWidget&gt;</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void initState() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement initState</span></span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void didChangeDependencies() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement didChangeDependencies</span></span><br><span class="line">    <span class="keyword">super</span>.didChangeDependencies();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> implement dispose</span></span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Scaffold</span>(</span><br><span class="line">      appBar: <span class="type">AppBar</span>(</span><br><span class="line"></span><br><span class="line">        title: <span class="type">Text</span>(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: <span class="type">Center</span>(</span><br><span class="line">        child: <span class="type">Column</span>(</span><br><span class="line">          mainAxisAlignment: <span class="type">MainAxisAlignment</span>.center,</span><br><span class="line">          children: &lt;<span class="type">Widget</span>&gt;[</span><br><span class="line">            <span class="type">Text</span>(</span><br><span class="line">              <span class="symbol">'You</span> have pushed the button <span class="keyword">this</span> many times:',</span><br><span class="line">            ),</span><br><span class="line">            <span class="type">Text</span>(</span><br><span class="line">              '',</span><br><span class="line">              style: <span class="type">Theme</span>.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="type">FloatingActionButton</span>(</span><br><span class="line">        onPressed: ()&#123;&#125;,</span><br><span class="line">        tooltip: <span class="symbol">'Incremen</span>t',</span><br><span class="line">        child: <span class="type">Icon</span>(<span class="type">Icons</span>.add),</span><br><span class="line">      ), <span class="comment">// This trailing comma makes auto-formatting nicer for build methods.</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面时序图显示了创建有状态 <code>Widget</code> 相关的操作。 在图的右侧，标注了 <code>State</code> 对象的内部状态。 同时您可以看 <code>Context</code> 与 <code>State</code> 关联的时刻，从而变为有效的（挂载）。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/24/1687e6d4abb66b83?w=715&amp;h=676&amp;f=png&amp;s=60959" alt></p><h3 id="initState"><a href="#initState" class="headerlink" title="initState()"></a>initState()</h3><p><code>initState()</code> 方法是在创建 <code>State</code> 对象后要调用的第一个方法（在构造函数之后）。需要执行自定义初始化内容时，需要复写此方法。 通常初始化，动画，逻辑控制等。如果重写此方法，需要先调用 <code>super.initState()</code> 方法。</p><p>在这个方法中，Context 可用但你还不能真正使用它，因为框架还没有完全将 <code>State</code> 与它相关联。</p><p>一旦 <code>initState()</code> 方法执行完成，<code>State</code> 对象完成初始化并且 <code>Context</code> 可用。</p><p>在<code>State</code> 对象的生命周期内，不会再调用 <code>initState()</code> 方法。即 <code>initState()</code> 只被调用一次。</p><h3 id="didChangeDependencies"><a href="#didChangeDependencies" class="headerlink" title="didChangeDependencies()"></a>didChangeDependencies()</h3><p><code>didChangeDependencies()</code> 方法是要调用的第二个方法。</p><p>在此阶段，由于 <code>Context</code> 可用，您可以使用它。</p><p>如果您的 <code>Widget</code> 链接到 <code>InheritedWidget</code>，并且需要初始化某些侦听器（基于 <code>Context</code>），则需要复写此方法。</p><p>请注意，如果您的 <code>Widget</code> 关联到 <code>InheritedWidget</code>，则每次重建此 <code>Widget</code> 时都会调用此方法。</p><p>如果重写此方法，则应首先调用 <code>super.didChangeDependencies()</code>。</p><h3 id="build"><a href="#build" class="headerlink" title="build()"></a>build()</h3><p><code>build(BuildContext context)</code> 方法在 <code>didChangeDependencies()</code>（和<code>didUpdateWidget</code>）之后调用。</p><p>这是您构建 <code>Widgets</code>（可能还有任何子树）的地方。</p><p>每次 <code>State</code> 对象更改时（或者当 <code>InheritedWidget</code> 需要通知 “已注册” 的 <code>Widget</code> 时）都会调用此方法！</p><p>如果要主动重建，您可以调用 <code>setState ( () {...})</code> 方法。</p><h3 id="dispose"><a href="#dispose" class="headerlink" title="dispose()"></a>dispose()</h3><p>当 <code>Widget</code> 废弃时调用 <code>dispose()</code> 方法。</p><p>如果需要执行一些清理（例如侦听器）工作，需要复写此方法，之后调用 <code>super.dispose()</code>。</p><h2 id="有状态和无状态-Widget-如何选择"><a href="#有状态和无状态-Widget-如何选择" class="headerlink" title="有状态和无状态 Widget 如何选择"></a>有状态和无状态 Widget 如何选择</h2><p>Widget无状态或有状态？如何选择。</p><p>为了回答这个问题，请问问自己：</p><blockquote><p>在我的 <code>Widget</code> 生命周期中，是否需要考虑一个变量, 将要更改，何时更改，从而强制重建 <code>Widget</code>？</p></blockquote><p>如果问题的答案是肯定的，那么您需要一个有状态 <code>Widget</code>，否则，您需要一个无状态 <code>Widget</code>。</p><p>举例：</p><ul><li><p>用于显示复选框列表的 <code>Widget</code>。要显示复选框，您需要考虑一系列 <code>item</code>。每个 <code>item</code> 都是一个具有 <code>title</code> 和 ‘status’ 的对象。如果单击复选框，则会切换相应的 <code>item.status</code>。</p><p>  在这种情况下，您需要使用有状态 <code>Widget</code> 来记住项目的状态，以便能够重绘复选框。</p></li><li><p>单一表格, 该表格 <code>Widget</code> 允许用户输入，并将输入之后的表格发送到服务器。</p><p>  在这种情况下，除非您需要在提交表单之前验证表单或执行任何其他操作，否则无状态 <code>Widget</code> 可能就足够了。</p></li></ul><h2 id="有状态-Widget-由两部分组成"><a href="#有状态-Widget-由两部分组成" class="headerlink" title="有状态 Widget 由两部分组成"></a>有状态 Widget 由两部分组成</h2><h3 id="Widget-定义"><a href="#Widget-定义" class="headerlink" title="Widget 定义"></a>Widget 定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefulWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="type">MyStatefulWidget</span>(&#123;<span class="type">Key</span> key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一部分 <code>MyStatefulWidget</code> 通常是 <code>Widget</code> 的公共部分。 当您要将其添加到 <code>Widget</code> 树，可以实例化此<code>Widget</code>。此部分在 <code>Widget</code> 的生命周期内不会发生变化，但可以接受其相应的 <code>State</code> 实例参数。</p><p>请注意，在 <code>Widget</code> 的第一部分定义的任何变量通常在其生命周期内不会更改。</p><h3 id="State-定义"><a href="#State-定义" class="headerlink" title="State 定义"></a><code>State</code> 定义</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyStatefulWidgetState</span> <span class="keyword">extends</span> <span class="title">State&lt;MyStatefulWidget&gt;</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="type">Widget</span> build(<span class="type">BuildContext</span> context)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二部分 <code>_MyStatefulWidgetState</code> 是在 <code>Widget</code> 的生命周期中变化的部分，并在每次应用修改时强制重建 <code>Widget</code>实例。 名称开头的 <code>_</code> 字符表示该类对当前 <code>.dart</code> 文件是私有的。</p><p>如果需要在 <code>.dart</code> 文件之外引用此类，去掉 <code>_</code> 前缀即可。</p><p><code>_MyStatefulWidgetState</code> 类可以使用 <code>widget.{变量名}</code> 访问存储在 <code>MyStatefulWidget</code> 中的任何变量。 示例：<code>widget.color</code></p><h3 id="Widget-的唯一标识-Key"><a href="#Widget-的唯一标识-Key" class="headerlink" title="Widget 的唯一标识 - Key"></a>Widget 的唯一标识 - Key</h3><p>在Flutter中，每个Widget都是唯一标识的。这个唯一标识由框架在<strong>构建/渲染</strong>时定义。</p><p>此唯一标识对应为可选的 <code>Key</code> 参数。 如果省略，Flutter将为您生成一个。</p><p>在某些情况下，您可能需要使用此 <code>Key</code>，以便可以通过 <code>Key</code> 访问 <code>Widget</code>。</p><p>为此，您可以使用以下类之一：<code>GlobalKey</code>，<code>LocalKey</code>，<code>UniqueKey</code> 或 <code>ObjectKey</code>。</p><p>GlobalKey确保 <code>Key</code> 在整个应用程序中是唯一的。</p><p>使用 <code>Widget</code> 的唯一标识 <code>Key</code>：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GlobalKey myKey = <span class="keyword">new</span> <span class="type">GlobalKey</span>();</span><br><span class="line">    ...</span><br><span class="line">    @<span class="keyword">override</span></span><br><span class="line">    Widget build(BuildContext context)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">MyWidget</span>(</span><br><span class="line">            key: <span class="type">myKey</span></span><br><span class="line"><span class="type">        </span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="第二部分，-如何访问-State"><a href="#第二部分，-如何访问-State" class="headerlink" title="第二部分， 如何访问 State"></a>第二部分， 如何访问 State</h2><p>如前所述，State 关联一个 <code>Context</code>，<code>Context</code> 关联一个 <code>Widget</code> 实例。</p><h3 id="1-Widget-本身"><a href="#1-Widget-本身" class="headerlink" title="1. Widget 本身"></a>1. Widget 本身</h3><p>从理论上讲，唯一能够访问状态的是 <code>Widget State</code> 本身。</p><p>在这种情况下，没有困难。 <code>Widget State</code> 类访问其任何内部变量。</p><h3 id="2-子-Widget"><a href="#2-子-Widget" class="headerlink" title="2. 子 Widget"></a>2. 子 Widget</h3><p>有时候，父 <code>Widget</code> 可能需要根据其子 <code>Widget</code> 的状态执行特定任务。</p><p>在Flutter中，每个Widget都有一个唯一的标识，由框架在构建/渲染时确定。 </p><p>如前所示，您可以使用 <code>key</code> 参数强制标识 <code>Widget</code>,</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">   GlobalKey&lt;MyStatefulWidgetState&gt; myWidgetStateKey = <span class="keyword">new</span> <span class="type">GlobalKey</span>&lt;MyStatefulWidgetState&gt;();</span><br><span class="line">   ...</span><br><span class="line">   @<span class="keyword">override</span></span><br><span class="line">   Widget build(BuildContext context)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">MyStatefulWidget</span>(</span><br><span class="line">           key: <span class="type">myWidgetStateKey</span>,</span><br><span class="line">           color: <span class="type">Colors</span>.blue,</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一旦确定，父 <code>Widget</code> 可以通过以下方式访问其子 <code>Widget</code> 的状态：</p><blockquote><p>myWidgetStateKey.currentState</p></blockquote><p>让我们考虑一个基本示例，当用户点击按钮时显示 <code>SnackBar</code>。 由于 <code>SnackBar</code> 是 <code>Scaffold</code>的子 <code>Widget</code>，它不能直接访问 <code>Scaffold</code> 的任何其他子 <code>Widget</code>。 因此，访问它的唯一方法是 <code>ScaffoldState</code>，公开一个公共方法来显示 <code>SnackBar</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyScreenState</span> <span class="keyword">extends</span> <span class="title">State&lt;MyScreen&gt;</span> </span>&#123;</span><br><span class="line">        <span class="comment">/// the unique identity of the Scaffold</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">GlobalKey</span>&lt;<span class="type">ScaffoldState</span>&gt; _scaffoldKey = <span class="keyword">new</span> <span class="type">GlobalKey</span>&lt;<span class="type">ScaffoldState</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@override</span></span><br><span class="line">        <span class="type">Widget</span> build(<span class="type">BuildContext</span> context)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Scaffold</span>(</span><br><span class="line">                key: _scaffoldKey,</span><br><span class="line">                appBar: <span class="keyword">new</span> <span class="type">AppBar</span>(</span><br><span class="line">                    title: <span class="keyword">new</span> <span class="type">Text</span>(<span class="symbol">'My</span> <span class="type">Screen</span>'),</span><br><span class="line">                ),</span><br><span class="line">                body: <span class="keyword">new</span> <span class="type">Center</span>(</span><br><span class="line">                    <span class="keyword">new</span> <span class="type">RaiseButton</span>(</span><br><span class="line">                        child: <span class="keyword">new</span> <span class="type">Text</span>(<span class="symbol">'Hit</span> me'),</span><br><span class="line">                        onPressed: ()&#123;</span><br><span class="line">                            _scaffoldKey.currentState.showSnackBar(</span><br><span class="line">                                <span class="keyword">new</span> <span class="type">SnackBar</span>(</span><br><span class="line">                                    content: <span class="keyword">new</span> <span class="type">Text</span>(<span class="symbol">'This</span> is the <span class="type">Snackbar</span>...'),</span><br><span class="line">                                )</span><br><span class="line">                            );</span><br><span class="line">                        &#125;</span><br><span class="line">                    ),</span><br><span class="line">                ),</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-Widget-祖先"><a href="#3-Widget-祖先" class="headerlink" title="3. Widget 祖先"></a>3. Widget 祖先</h3><p><img src="https://user-gold-cdn.xitu.io/2019/1/23/16879cf976983156?w=752&amp;h=775&amp;f=png&amp;s=43865" alt></p><h4 id="1-带状态的-Widget（红色）需要暴露其状态"><a href="#1-带状态的-Widget（红色）需要暴露其状态" class="headerlink" title="1. 带状态的 Widget（红色）需要暴露其状态"></a>1. <code>带状态的 Widget</code>（红色）需要暴露其状态</h4><p>为了公开它的状态，Widget需要在创建时记录它，如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExposingWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">MyExposingWidgetState</span> myState;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   <span class="type">MyExposingWidgetState</span> createState()&#123;</span><br><span class="line">      myState = <span class="keyword">new</span> <span class="type">MyExposingWidgetState</span>();</span><br><span class="line">      <span class="keyword">return</span> myState;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Widget-State-需要暴露-getters-setters"><a href="#2-Widget-State-需要暴露-getters-setters" class="headerlink" title="2. Widget State 需要暴露 getters/setters"></a>2. <code>Widget State</code> 需要暴露 getters/setters</h4><p>为了让其他 <code>Widget</code>可以 设置/获取 State属性，<code>Widget State</code> 需要通过以下方式授权访问：</p><ul><li>public 属性 (不推荐)</li><li>getter / setter</li></ul><p>例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyExposingWidgetState</span> <span class="keyword">extends</span> <span class="title">State&lt;MyExposingWidget&gt;</span></span>&#123;</span><br><span class="line">   <span class="type">Color</span> _color;</span><br><span class="line"></span><br><span class="line">   <span class="type">Color</span> get color =&gt; _color;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-蓝色-Widget-获得-State-引用"><a href="#3-蓝色-Widget-获得-State-引用" class="headerlink" title="3. 蓝色 Widget 获得 State 引用"></a>3. 蓝色 <code>Widget</code> 获得 State 引用</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildWidget</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   <span class="type">Widget</span> build(<span class="type">BuildContext</span> context)&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">MyExposingWidget</span> widget = context.ancestorWidgetOfExactType(<span class="type">MyExposingWidget</span>);</span><br><span class="line">      <span class="keyword">final</span> <span class="type">MyExposingWidgetState</span> state = widget?.myState;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Container</span>(</span><br><span class="line">         color: state == <span class="literal">null</span> ? <span class="type">Colors</span>.blue : state.color,</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解决方案很容易实现，但子 <code>Widget</code> 无法知道它何时需要重建，</p><p>它必须等待重建才能刷新其内容，这将导致UI无法及时刷新。</p><p>下一节将讨论 <code>Inherited Widget</code> 概念，它可以解决这个问题。</p><h2 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h2><p>简而言之，<code>InheritedWidget</code> 允许在 <code>Widget</code> 树中有效地传递（和共享）信息。</p><p><code>InheritedWidget</code> 是一个特殊的 <code>Widget</code>，您可以将其插入 <code>Widget</code> 树中，作为一个 <code>Widget</code> 子树的父节点。 该子树的所有 <code>Widget</code> 都能够访问 <code>InheritedWidget</code> 公开的数据。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>为了解释 <code>InheritedWidget</code>，让我们考虑以下代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInheritedWidget</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">   <span class="type">MyInheritedWidget</span>(&#123;</span><br><span class="line">      <span class="type">Key</span> key,</span><br><span class="line">      <span class="meta">@required</span> <span class="type">Widget</span> child,</span><br><span class="line">      <span class="keyword">this</span>.data,</span><br><span class="line">   &#125;): <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> data;</span><br><span class="line"></span><br><span class="line">   static <span class="type">MyInheritedWidget</span> of(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">      <span class="keyword">return</span> context.inheritFromWidgetOfExactType(<span class="type">MyInheritedWidget</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   bool updateShouldNotify(<span class="type">MyInheritedWidget</span> oldWidget) =&gt; data != oldWidget.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此代码定义了一个名为 <code>MyInheritedWidget</code> 的 Widget，目的是 “共享” 所有 <code>Widget</code> 中的某些数据。</p><p>如前所述，为了能够<strong>传递/共享</strong>某些数据，需要将 <code>InheritedWidget</code> 定位在 <code>Widget</code> 树的顶部，这解释为什么 <code>InheritedWidget</code> 构造函数设置 <code>Widget</code> 为 <code>@required</code> 。</p><p>静态方法 <code>MyInheritedWidget(BuildContext context)</code> 允许所有子 <code>Widget</code> 获取最近包含 <code>Context</code> 的 <code>MyInheritedWidget</code> 实例（参见后面的内容）。</p><p>最后重写 <code>updateShouldNotify</code> 方法，用于设置 <code>InheritedWidget</code> 是否必须通知所有子 <code>Widget</code>（已注册/已订阅），如果数据发生修改（请参阅下文）。</p><p>因此，我们需要将它放在树节点上，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParentWidget</span>... </span>&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyInheritedWidget(</span><br><span class="line">         data: counter,</span><br><span class="line">         child: <span class="keyword">new</span> Row(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">               ...</span><br><span class="line">            ],</span><br><span class="line">         ),</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子-Widget-如何访问-InheritedWidget-的数据"><a href="#子-Widget-如何访问-InheritedWidget-的数据" class="headerlink" title="子 Widget 如何访问 InheritedWidget 的数据"></a>子 <code>Widget</code> 如何访问 <code>InheritedWidget</code> 的数据</h3><p>在构建子 <code>Widget</code> 时，将获得 <code>InheritedWidget</code> 的引用，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildWidget</span>... </span>&#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   <span class="meta">@override</span></span><br><span class="line">   <span class="function">Widget <span class="title">build</span><span class="params">(BuildContext context)</span></span>&#123;</span><br><span class="line">      <span class="keyword">final</span> MyInheritedWidget inheritedWidget = MyInheritedWidget.of(context);</span><br><span class="line"></span><br><span class="line">      <span class="comment">///</span></span><br><span class="line">      <span class="comment">/// From this moment, the widget can use the data, exposed by the MyInheritedWidget</span></span><br><span class="line">      <span class="comment">/// by calling:  inheritedWidget.data</span></span><br><span class="line">      <span class="comment">///</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Container(</span><br><span class="line">         color: inheritedWidget.data.color,</span><br><span class="line">      );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何在-Widget-之间进行交互-？"><a href="#如何在-Widget-之间进行交互-？" class="headerlink" title="如何在 Widget 之间进行交互 ？"></a>如何在 <code>Widget</code> 之间进行交互 ？</h3><p>思考下面 <code>Widget</code> 树。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/23/1687a730eb729412?w=728&amp;h=528&amp;f=png&amp;s=37579" alt></p><p>为了说明一种交互方式，我们假设如下：</p><ul><li><code>Widget A</code> 是一个按钮，点击时将货物添加到购物车;</li><li><code>Widget B</code> 是一个文本，显示购物车中商品数量;</li><li><code>Widget C</code> 位于 <code>Widget B</code> 旁边，是一个文本;</li><li>我们希望在按下 <code>Widget A</code> 时自动在 <code>Widget B</code> 购物车中显示正确数量的项目，但我们不希望重建 <code>Widget C</code>，<code>InheritedWidget</code> 应用场景正式于此！</li></ul><blockquote><p><a href="https://github.com/hongruqi/inheritedDemo" target="_blank" rel="noopener">示例代码 github </a></p></blockquote><p><strong>main.dart:</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/material.dart';</span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter_app_demo/inherited.dart';</span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter_app_demo/widgetA.dart';</span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter_app_demo/widgetB.dart';</span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter_app_demo/widgetC.dart';</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(<span class="type">MyApp</span>());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This widget is the root of your application.</span></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">MaterialApp</span>(</span><br><span class="line">      title: <span class="symbol">'Flutter</span> <span class="type">Demo</span>',</span><br><span class="line">      theme: <span class="type">ThemeData</span>(</span><br><span class="line">        primarySwatch: <span class="type">Colors</span>.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: <span class="type">MyStatefulWidget</span>(title: <span class="symbol">'Flutter</span> <span class="type">Demo</span> <span class="type">Home</span> <span class="type">Page</span>'),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefulWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="type">MyStatefulWidget</span>(&#123;<span class="type">Key</span> key, <span class="keyword">this</span>.title&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">String</span> title;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  _MyStatefulWidgetState createState() =&gt; _MyStatefulWidgetState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyStatefulWidgetState</span> <span class="keyword">extends</span> <span class="title">State&lt;MyStatefulWidget&gt;</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">MyInheritedWidget</span>(</span><br><span class="line">      child: <span class="type">Scaffold</span>(</span><br><span class="line">        appBar: <span class="type">AppBar</span>(</span><br><span class="line">          title: <span class="type">Text</span>(<span class="symbol">'I</span> am <span class="type">Tree</span>'),</span><br><span class="line">        ),</span><br><span class="line">        body: <span class="type">Column</span>(</span><br><span class="line">          children: &lt;<span class="type">Widget</span>&gt;[</span><br><span class="line">            <span class="type">WidgetA</span>(),</span><br><span class="line">            <span class="type">Padding</span>(padding: <span class="type">EdgeInsets</span>.all(<span class="number">15.0</span>),),</span><br><span class="line">            <span class="type">Container</span>(</span><br><span class="line">              child: <span class="type">Row</span>(</span><br><span class="line">                mainAxisAlignment: <span class="type">MainAxisAlignment</span>.spaceEvenly,</span><br><span class="line">                children: &lt;<span class="type">Widget</span>&gt;[</span><br><span class="line">                  <span class="type">WidgetB</span>(),</span><br><span class="line">                  <span class="type">WidgetC</span>(),</span><br><span class="line">                ],</span><br><span class="line">              ),</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>inherited.dart</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/material.dart';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInheritedWidget</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span></span>&#123;</span><br><span class="line">  <span class="type">MyInheritedWidget</span>(&#123;<span class="type">Key</span> key, <span class="keyword">this</span>.child,&#125;):<span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Widget</span> child;</span><br><span class="line"></span><br><span class="line">  <span class="type">MyInheritedWidgetState</span> createState() =&gt; <span class="keyword">new</span> <span class="type">MyInheritedWidgetState</span>();</span><br><span class="line"></span><br><span class="line">  static <span class="type">MyInheritedWidgetState</span> of(<span class="type">BuildContext</span> context)&#123;</span><br><span class="line">    <span class="keyword">return</span> (context.inheritFromWidgetOfExactType(_MyInherited) as _MyInherited).data;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInheritedWidgetState</span> <span class="keyword">extends</span> <span class="title">State&lt;MyInheritedWidget&gt;</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">List</span>&lt;<span class="type">Item</span>&gt; _items = &lt;<span class="type">Item</span>&gt;[];</span><br><span class="line"></span><br><span class="line">  int get itemsCount =&gt; _items.length;</span><br><span class="line"></span><br><span class="line">  void addItem(<span class="type">String</span> name)&#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      _items.add(<span class="keyword">new</span> <span class="type">Item</span>(name));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> _MyInherited(child:  widget.child, data: <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_MyInherited</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</span><br><span class="line">  _MyInherited(&#123;</span><br><span class="line">    <span class="type">Key</span> key,</span><br><span class="line">    <span class="meta">@required</span> <span class="type">Widget</span> child,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.data,</span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">MyInheritedWidgetState</span> data;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  bool updateShouldNotify(_MyInherited oldWidget) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span></span>&#123;</span><br><span class="line">  <span class="type">String</span> name;</span><br><span class="line"></span><br><span class="line">  <span class="type">Item</span>(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Widgets:</strong></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetA</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MyInheritedWidgetState</span> state = <span class="type">MyInheritedWidget</span>.of(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Container</span>(</span><br><span class="line">      child: <span class="keyword">new</span> <span class="type">RaisedButton</span>(</span><br><span class="line">        child: <span class="keyword">new</span> <span class="type">Text</span>(<span class="symbol">'WidgetA</span> <span class="type">Add</span> <span class="type">Item</span>',</span><br><span class="line">          textAlign: <span class="type">TextAlign</span>.right,</span><br><span class="line">          overflow: <span class="type">TextOverflow</span>.ellipsis,</span><br><span class="line">          style: <span class="type">TextStyle</span>(</span><br><span class="line">            color: <span class="type">Colors</span>.blue,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          state.addItem(<span class="symbol">'new</span> item');</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetB</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MyInheritedWidgetState</span> state = <span class="type">MyInheritedWidget</span>.of(context);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Container</span>(</span><br><span class="line">      child: <span class="type">Row</span>(</span><br><span class="line">        children: &lt;<span class="type">Widget</span>&gt;[</span><br><span class="line">          <span class="type">Icon</span>(<span class="type">Icons</span>.shopping_cart),</span><br><span class="line">          <span class="type">Text</span>('$&#123;state.itemsCount&#125;',</span><br><span class="line">            textAlign: <span class="type">TextAlign</span>.right,</span><br><span class="line">            overflow: <span class="type">TextOverflow</span>.ellipsis,</span><br><span class="line">            style: <span class="type">TextStyle</span>(</span><br><span class="line">              color: <span class="type">Colors</span>.red,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetC</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Text</span>(</span><br><span class="line">        <span class="symbol">'Widget</span> <span class="type">C</span>',</span><br><span class="line">      textAlign: <span class="type">TextAlign</span>.right,</span><br><span class="line">      overflow: <span class="type">TextOverflow</span>.ellipsis,</span><br><span class="line">      style: <span class="type">TextStyle</span>(</span><br><span class="line"><span class="comment">//          fontWeight: FontWeight.bold,</span></span><br><span class="line">        color: <span class="type">Colors</span>.green[<span class="number">200</span>],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h2><p>在这个非常基本的例子中，</p><ul><li><code>_MyInherited</code> 是一个 <code>InheritedWidget</code>，每次我们点击 <code>Widget A</code> 按钮添加一个 <code>Item</code> 时都会被重新创建。</li><li><code>MyInheritedWidget</code> 是一个 <code>Widget</code>，其状态包含 <code>Items</code> 列表。 可以通过<code>MyInheritedWidgetState of(BuildContext context)</code>静态方法访问此状态。</li><li><code>MyInheritedWidgetState</code> 公开一个 getter（itemsCount）和一个 <code>addItem</code> 方法，以便它们可以被 <code>Widget</code> 使用。</li><li>每次我们将一个 <code>Item</code> 添加到 <code>State</code>，<code>MyInheritedWidgetState</code> 都会重建。</li><li><code>MyStatefulWidget</code> 类只是构建一个 <code>Widget</code> 树，将 <code>MyInheritedWidget</code> 作为树的根节点。</li><li><code>WidgetA</code> 是一个简单的 <code>RaisedButton</code>，当按下它时，调用 <code>MyInheritedWidget</code> 的 <code>addItem</code> 方法。</li><li><code>WidgetB</code> 是一个简单的文本，显示 <code>MyInheritedWidget</code> 的 <code>item</code>数。</li></ul><p><strong>这一切是如何运作 ？</strong></p><h3 id="注册-Widget-以供以后通知"><a href="#注册-Widget-以供以后通知" class="headerlink" title="注册 Widget 以供以后通知"></a>注册 Widget 以供以后通知</h3><p>当子 <code>Widget</code> 调用 <code>MyInheritedWidget.of(context)</code>时，它调用 <code>MyInheritedWidget</code> 的以下方法，将 ‘Context’ 作为参数进行传递。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static MyInheritedWidgetState of(<span class="keyword">BuildContext </span><span class="built_in">context</span>) &#123;</span><br><span class="line">return (<span class="built_in">context</span>.inheritFromWidgetOfExactType(_MyInherited) as _MyInherited)<span class="meta">.data</span><span class="comment">;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在内部，除了简单地返回 <code>MyInheritedWidgetState</code> 的实例之外，它还向 <code>Widget</code> 订阅更改通知。</p><p>在场景后面，对这个静态方法的简单调用实际上做了两件事：</p><ul><li><code>Widget</code> 被自动添加到订阅列表中，当对 <code>_MyInherited</code> 进行修改时， 将自动重建。</li><li><code>MyInheritedWidgetState</code> 中引用的数据将返回给使用者。</li></ul><p>由于 <code>Widget A</code> 和 <code>Widget B</code> 都已使用 <code>InheritedWidget</code> 订阅，因此如果对 <code>_MyInherited</code> 进行修改，即当单击 <code>Widget A</code> 的 <code>RaisedButton</code> 时，大致操作流程如下：</p><ol><li>调用 <code>MyInheritedWidgetState</code> 的 <code>addItem</code> 方法。</li><li><code>MyInheritedWidgetState.addItem</code> 方法将新项添加到 <code>List</code>。</li><li>调用 <code>setState()</code> 重建 <code>MyInheritedWidget</code>。</li><li>使用<code>List</code>的新内容创建 <code>_MyInherited</code> 的新实例。</li><li><code>_MyInherited</code> 记录新 <code>State</code>。</li><li>作为 <code>InheritedWidget</code>，它检查是否需要通知订阅者（答案是需要）。</li><li>它遍历整个订阅者列表（这里是 <code>Widget A</code> 和 <code>Widget B</code> ）并要求他们重建。</li><li>由于 <code>Wiget C</code> 不是订阅者，因此不会重建。</li></ol><p><code>Widget A</code> 和 <code>Widget B</code> 都重建了，而重建 <code>Wiget A</code> 却没用，因为它没有任何改变。如何防止这种情况发生？</p><h3 id="访问-InheritedWidget-时阻止某些-Widget-重建"><a href="#访问-InheritedWidget-时阻止某些-Widget-重建" class="headerlink" title="访问 InheritedWidget 时阻止某些 Widget 重建"></a>访问 InheritedWidget 时阻止某些 Widget 重建</h3><p><code>Widget A</code> 也被重建的原因是访问 <code>MyInheritedWidgetState</code> 的方式。</p><p>如前所述，调用 <code>context.inheritFromWidgetOfExactType()</code> 方法会自动将 <code>Widget</code> 订阅到订阅列表中。</p><p>防止此自动订阅同时仍允许 <code>Widget A</code> 访问 <code>MyInheritedWidgetState</code> 的解决方案是更改<code>MyInheritedWidget</code> 的静态方法，如下所示：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static MyInheritedWidgetState <span class="keyword">of</span>([BuildContext <span class="keyword">context</span>, bool rebuild =<span class="built_in"> true</span>])&#123;</span><br><span class="line">    <span class="keyword">return</span> (rebuild ? <span class="keyword">context</span>.inheritFromWidgetOfExactType(_MyInherited) <span class="keyword">as</span> _MyInherited</span><br><span class="line">                    : <span class="keyword">context</span>.ancestorWidgetOfExactType(_MyInherited) <span class="keyword">as</span> _MyInherited).data;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>添加额外布尔参数:</p><ul><li>如果 <code>rebuild</code> 参数为 <code>true</code>（默认情况下），Widget将被添加到订阅者列表中。</li><li>如果 <code>rebuild</code> 参数为 <code>false</code>，我们仍然可以访问数据，但不使用 <code>InheritedWidget</code> 的内部实现。</li></ul><p>因此，要完成解决方案，我们还需要稍微更新 <code>Widget A</code> 的代码，如下所示（我们添加 <code>false</code> 参数）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WidgetA</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">MyInheritedWidgetState</span> state = <span class="type">MyInheritedWidget</span>.of(context, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">Container</span>(</span><br><span class="line">      child: <span class="keyword">new</span> <span class="type">RaisedButton</span>(</span><br><span class="line">        child: <span class="keyword">new</span> <span class="type">Text</span>(<span class="symbol">'Add</span> <span class="type">Item</span>'),</span><br><span class="line">        onPressed: () &#123;</span><br><span class="line">          state.addItem(<span class="symbol">'new</span> item');</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，按下 <code>button</code> 不会重建 <code>Widget A</code>.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通篇，我们介绍了 <code>Flutter</code> 的核心概念， Widget， State， Context， InheritedWidget。</p><p>并且，完成了 State 之间交互的介绍。并使用 <code>InheritedWidget</code> 进行了 Demo制作。希望这篇文章，能够帮助您，深入了解 <code>Flutter</code>。 </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://medium.com/@maksimrv/reactive-app-state-in-flutter-73f829bcf6a7" target="_blank" rel="noopener">Reactive app state in Flutter</a></li><li><a href="https://medium.com/@chemamolins/is-flutters-inheritedwidget-a-good-fit-to-hold-app-state-2ec5b33d023e" target="_blank" rel="noopener">Using Flutter’s InheritedWidget to hold app state</a></li><li><a href="https://docs.flutter.io/flutter/widgets/InheritedWidget-class.html" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://www.youtube.com/watch?reload=9&amp;time_continue=7&amp;v=RS36gBEp8OI" target="_blank" rel="noopener">Google I/O 2018</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter-深入理解-State&quot;&gt;&lt;a href=&quot;#Flutter-深入理解-State&quot; class=&quot;headerlink&quot; title=&quot;Flutter 深入理解 State&quot;&gt;&lt;/a&gt;Flutter 深入理解 State&lt;/h1&gt;&lt;p&gt;本文主要介绍
      
    
    </summary>
    
      <category term="Flutter" scheme="https://hongruqi.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter 从 0 到 1</title>
    <link href="https://hongruqi.github.io/2019/01/07/Flutter%20%E4%BB%8E%200%20%E5%88%B0%201%20/"/>
    <id>https://hongruqi.github.io/2019/01/07/Flutter 从 0 到 1 /</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-02-22T07:30:01.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter-从-0-到-1"><a href="#Flutter-从-0-到-1" class="headerlink" title="Flutter 从 0 到 1"></a>Flutter 从 0 到 1</h1><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827a8eb15e7fa2?w=164&amp;h=185&amp;f=jpeg&amp;s=9801" alt></p><p><strong>长话短说</strong> 我发现 Flutter 的 widget 和 tween 的强大之处，在使用 Dart 开发 Android/iOS 应用程序的图表动画过程中。</p><p>2018 年 8 月 7 日更新，适配 Dart 2 语法。<a href="https://github.com/mravn/charts" target="_blank" rel="noopener">GitHub repo</a>在 2018 年 10 月 17 日添加。下面的描述每步都是一个单独提交。</p><hr><p>迁移到新的开发栈可以让您了解自己对技术的优先级。在我的清单中排在前三位的是：</p><ul><li><strong>强大的概念</strong>通过提供简单的，相关的构造方法，逻辑或数据，从而有效地处理复杂度。</li><li><strong>清晰的代码</strong>让我们可以清晰地表达概念，不被语言陷阱、过多的引用或者辅助细节所干扰。。</li><li><strong>快速迭代</strong>是实验和学习的关键 - 软件开发团队以学习为生：需求到底是什么，以及如何通过最优的代码实现它。</li></ul><p>Flutter 是用 Dart 实现，可以用一套代码同时构建 Android 和 iOS 应用的新平台。由于我们的需求涉及到一个相当复杂的 UI，包括动画图表，所以只构建一次的想法似乎非常有吸引力。我的任务包括使用 Flutter 的 CLI 工具，一些预先构建的 Widgets 及其 2D 渲染引擎。除了编写大量 Dart 代码来构建模型和动画图表外。我将在下面分享一些重点概念，并为您自己评估 Flutter/Dart 技术栈提供一个参考。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827a8ebce51bde?w=300&amp;h=228&amp;f=gif&amp;s=4784454" alt></p><p>一个简单的动画条形图，在开发过程中从 iOS 模拟器获取</p><p>这是 Flutter 及其 “widgets” 和 “tween” 概念介绍的<a href="https://medium.com/dartlang/zero-to-one-with-flutter-part-two-5aa2f06655cb" target="_blank" rel="noopener">两部分</a>中的第一部分。我将通过使用它们实现显示动画（如上图所示的图表）来说明这些概念的强大之处。完整的代码示例将给你 Dart 代码能清晰表达问题的印象。我将包含足够的细节，您应该能够在自己的笔记本电脑（以及模拟器或设备）上进行操作，并体验 Flutter 开发周期的长度。</p><p>首先，<a href="https://flutter.io/setup" target="_blank" rel="noopener">安装 Flutter</a>，完成之后在终端运行。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>flutter doctor</span><br></pre></td></tr></table></figure><p>检查设置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ flutter doctor</span><br><span class="line">Doctor summary (<span class="keyword">to</span> see all details, <span class="builtin-name">run</span> flutter doctor -v):</span><br><span class="line">[✓] Flutter</span><br><span class="line">    (Channel beta, v0.5.1, on Mac OS X 10.13.6 17G65, locale en-US)</span><br><span class="line">[✓] Android toolchain - develop <span class="keyword">for</span> Android devices</span><br><span class="line">    (Android SDK 28.0.0)</span><br><span class="line">[✓] iOS toolchain - develop <span class="keyword">for</span> iOS devices (Xcode 9.4)</span><br><span class="line">[✓] Android Studio (version 3.1)</span><br><span class="line">[✓] IntelliJ IDEA<span class="built_in"> Community </span>Edition (version 2018.2.1)</span><br><span class="line">[✓] Connected devices (1 available)</span><br><span class="line"></span><br><span class="line">• <span class="literal">No</span> issues found!</span><br></pre></td></tr></table></figure><p>以上复选框都满足了，您将可以创建一个 Flutter 应用程序了。我们命名它为 charts：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>flutter create charts</span><br></pre></td></tr></table></figure><p>目录结构：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">charts</span><br><span class="line">  android</span><br><span class="line">  ios</span><br><span class="line">  <span class="class"><span class="keyword">lib</span></span></span><br><span class="line">    main.dart</span><br></pre></td></tr></table></figure><p>大约生成 60 个文件，组成一个可以安装在 Android 和 iOS 上的完整示例程序。我们将在 <code>main.dart</code> 和它的同级文件中完成所有编码，而不需要触及任何其他文件或目录。</p><p>您应该验证是否可以启动示例程序。 启动模拟器或插入设备，然后在 <code>charts</code> 目录下，执行</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ flutter <span class="keyword">run</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>您应该在模拟器或设备上看到一个简单的计数应用程序。 它默认使用 MD 风格的 widgets，但这是可选的。作为 Flutter 架构的最顶层，这些 widgets 是完全可替换的。</p><hr><p>让我们首先用下面的代码替换 <code>main.dart</code> 的内容，作为玩转图表动画的简单起点。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="symbol">'dart</span>:math';</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/material.dart';</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(<span class="type">MaterialApp</span>(home: <span class="type">ChartPage</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">ChartPageState</span> createState() =&gt; <span class="type">ChartPageState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPageState</span> <span class="keyword">extends</span> <span class="title">State&lt;ChartPage&gt;</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> random = <span class="type">Random</span>();</span><br><span class="line">  int dataSet;</span><br><span class="line"></span><br><span class="line">  void changeData() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      dataSet = random.nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Scaffold</span>(</span><br><span class="line">      body: <span class="type">Center</span>(</span><br><span class="line">        child: <span class="type">Text</span>(<span class="symbol">'Data</span> set: $dataSet'),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="type">FloatingActionButton</span>(</span><br><span class="line">        child: <span class="type">Icon</span>(<span class="type">Icons</span>.refresh),</span><br><span class="line">        onPressed: changeData,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存更改，然后重新启动应用程序。您可以通过按 “R” 从终端执行此操作。这种“完全重启”操作会重置应用程序状态，然后重建 UI。对于在代码更改后，现有应用程序状态仍然有效的情况，可以按 “r” 执行“热重载”，这只会重建 UI。IntelliJ IDEA 安装 Flutter 插件，它提供了集成 Dart 编辑器相同的功能：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827a8eb822e810?w=800&amp;h=340&amp;f=png&amp;s=130539" alt></p><p>屏幕截图来自 IntelliJ IDEA，带有旧版本的 Flutter 插件，显示右上角的重新加载和重启按钮。如果已在 IDE 中启动应用程序，则启用这些按钮。较新版本的插件会在保存时进行热重载。</p><p>重新启动后，应用程序会显示一个居中的文本标签，上面写着 “Data set：null” 和一个浮动操作按钮来刷新数据。</p><p>要了解热重载和完全重启之间的区别，请尝试以下操作：按几次浮动操作按钮后，记下当前数据集编号，然后将代码中的 Icons.refresh 改为 Icons.add，保存并执行热重载。观察按钮已经改变，但程序的状态仍然保留; 我们仍然在文本上显示获取的随机数。现在撤消 Icon 更改，保存并完全重新启动。应用程序状态已重置，文本标签显示最初状态 “Data set：null”。</p><p>我们简单的应用程序显示了 Flutter Widget 两个核心方面：</p><ul><li>用户界面由<strong>不可变的 widgets</strong> 树定义，它是通过调用构造函数（你可以在其中配置 widgets）和 <code>build</code> 方法构建的（其中 widget 可以决定子树的外观）。我们的应用程序生成的树结构如下所示，每个 widget 的主要内容都在括号中。 正如您所看到的，虽然 widget 概念非常广泛，但每个具体 widget 类型通常都具有非常集中的职责。</li></ul><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp                    (<span class="name">navigation</span>)</span><br><span class="line">  ChartPage                    (<span class="name">state</span> management)</span><br><span class="line">    Scaffold                   (<span class="name">layout</span>)</span><br><span class="line">      Center                   (<span class="name">layout</span>)</span><br><span class="line">        Text                   (<span class="name">text</span>)</span><br><span class="line">      FloatingActionButton     (<span class="name">user</span> interaction)</span><br><span class="line">        Icon                   (<span class="name">graphics</span>)</span><br></pre></td></tr></table></figure><ul><li>使用不可变 widget 的不可变树定义用户界面，更改该界面的唯一方法是重建 widget 树。当下一帧到期时，Flutter 会处理这个问题。我们所要做的就是告诉 Flutter 一个子树所依赖的状态已经改变了。这种<strong>状态依赖子树</strong>的根必须是<code>StatefulWidget</code>。像任何 widget 一样，<code>StatefulWidget</code> 是不可变的，但是它的子树是由 <code>State</code> 对象构建的。Flutter 在树重建期间保留 “State” 对象，并在构建期间将每个对象附加到新树中的各自 widget 上。然后，他们决定 widget 的子树是如何构建的。在我们的应用程序中，<code>ChartPage</code> 是一个 <code>StatefulWidget</code>，<code>ChartPageState</code> 作为它的 <code>State</code>。每当用户按下按钮时，我们执行一些代码来改变 <code>ChartPageState</code>。我们用 <code>setState</code> 界定变化，以便 Flutter 可以进行内部处理并安排widget树进行重建。当发生这种情况时，<code>ChartPageState</code> 将构建一个稍微不同的子树，该子树以新的 <code>ChartPage</code> 实例为根。</li></ul><p>不可变 widget 和状态相关子树是 Flutter，为了解决UI异步响应事件，如按钮按下，计时器滴答或传入数据这样复杂的状态管理，而提供的主要工具。 从我的桌面应用开发经验来看，我会说这种复杂性是非常真实的。评估 Flutter 的优势，应该是读者去实践它：尝试一些非平凡的事情。</p><hr><p>我们的图表应用程序将在 widget 结构方面保持简单，但我们会做一些自定义视图动画。第一步是用非常简单的图表替换每个数据集的文本表示。由于数据集当前只涉及区间 “0..100” 中的单个数字，因此图表将是带有单个条形的条形图，其高度由该数字决定。我们将使用初始值 “50” 来避免 “null” 高度：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="symbol">'dart</span>:math';</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/material.dart';</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(<span class="type">MaterialApp</span>(home: <span class="type">ChartPage</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">ChartPageState</span> createState() =&gt; <span class="type">ChartPageState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPageState</span> <span class="keyword">extends</span> <span class="title">State&lt;ChartPage&gt;</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> random = <span class="type">Random</span>();</span><br><span class="line">  int dataSet = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  void changeData() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      dataSet = random.nextInt(<span class="number">100</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Scaffold</span>(</span><br><span class="line">      body: <span class="type">Center</span>(</span><br><span class="line">        child: <span class="type">CustomPaint</span>(</span><br><span class="line">          size: <span class="type">Size</span>(<span class="number">200.0</span>, <span class="number">100.0</span>),</span><br><span class="line">          painter: <span class="type">BarChartPainter</span>(dataSet.toDouble()),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="type">FloatingActionButton</span>(</span><br><span class="line">        child: <span class="type">Icon</span>(<span class="type">Icons</span>.refresh),</span><br><span class="line">        onPressed: changeData,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarChartPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line">  static const barWidth = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">BarChartPainter</span>(<span class="keyword">this</span>.barHeight);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> double barHeight;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void paint(<span class="type">Canvas</span> canvas, <span class="type">Size</span> size) &#123;</span><br><span class="line">    <span class="keyword">final</span> paint = <span class="type">Paint</span>()</span><br><span class="line">      ..color = <span class="type">Colors</span>.blue[<span class="number">400</span>]</span><br><span class="line">      ..style = <span class="type">PaintingStyle</span>.fill;</span><br><span class="line">    canvas.drawRect(</span><br><span class="line">      <span class="type">Rect</span>.fromLTWH(</span><br><span class="line">        (size.width - barWidth) / <span class="number">2.0</span>,</span><br><span class="line">        size.height - barHeight,</span><br><span class="line">        barWidth,</span><br><span class="line">        barHeight,</span><br><span class="line">      ),</span><br><span class="line">      paint,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  bool shouldRepaint(<span class="type">BarChartPainter</span> old) =&gt; barHeight != old.barHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CustomPaint</code> 是一个widget，它将绘画委托给 <code>CustomPainter</code>，执行后只画出一个条形图。</p><p>下一步是添加动画。每当数据集发生变化时，我们都希望条图形平滑而不是突然地改变高度。Flutter 有一个用于编排动画的<code>AnimationController</code> 类，通过注册一个监听器，我们被告知动画值(从 0 到 1 的 double 值)何时发生变化。每当发生这种情况时，我们可以像以前一样调用 <code>setState</code> 并更新 <code>ChartPageState</code>。</p><p>出于解释的原因，我们首先做一个简单的事例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="symbol">'dart</span>:math';</span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'dart</span>:ui' show lerpDouble;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/animation.dart';</span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/material.dart';</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(<span class="type">MaterialApp</span>(home: <span class="type">ChartPage</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">ChartPageState</span> createState() =&gt; <span class="type">ChartPageState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPageState</span> <span class="keyword">extends</span> <span class="title">State&lt;ChartPage&gt;</span> <span class="keyword">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> random = <span class="type">Random</span>();</span><br><span class="line">  int dataSet = <span class="number">50</span>;</span><br><span class="line">  <span class="type">AnimationController</span> animation;</span><br><span class="line">  double startHeight;   <span class="comment">// Strike one.</span></span><br><span class="line">  double currentHeight; <span class="comment">// Strike two.</span></span><br><span class="line">  double endHeight;     <span class="comment">// Strike three. Refactor.</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    animation = <span class="type">AnimationController</span>(</span><br><span class="line">      duration: const <span class="type">Duration</span>(milliseconds: <span class="number">300</span>),</span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    )..addListener(() &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          currentHeight = lerpDouble( <span class="comment">// Strike one.</span></span><br><span class="line">            startHeight,</span><br><span class="line">            endHeight,</span><br><span class="line">            animation.value,</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    startHeight = <span class="number">0.0</span>;                <span class="comment">// Strike two.</span></span><br><span class="line">    currentHeight = <span class="number">0.0</span>;</span><br><span class="line">    endHeight = dataSet.toDouble();</span><br><span class="line">    animation.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    animation.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void changeData() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      startHeight = currentHeight;    <span class="comment">// Strike three. Refactor.</span></span><br><span class="line">      dataSet = random.nextInt(<span class="number">100</span>);</span><br><span class="line">      endHeight = dataSet.toDouble();</span><br><span class="line">      animation.forward(from: <span class="number">0.0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Scaffold</span>(</span><br><span class="line">      body: <span class="type">Center</span>(</span><br><span class="line">        child: <span class="type">CustomPaint</span>(</span><br><span class="line">          size: <span class="type">Size</span>(<span class="number">200.0</span>, <span class="number">100.0</span>),</span><br><span class="line">          painter: <span class="type">BarChartPainter</span>(currentHeight),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="type">FloatingActionButton</span>(</span><br><span class="line">        child: <span class="type">Icon</span>(<span class="type">Icons</span>.refresh),</span><br><span class="line">        onPressed: changeData,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarChartPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line">  static const barWidth = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">BarChartPainter</span>(<span class="keyword">this</span>.barHeight);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> double barHeight;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void paint(<span class="type">Canvas</span> canvas, <span class="type">Size</span> size) &#123;</span><br><span class="line">    <span class="keyword">final</span> paint = <span class="type">Paint</span>()</span><br><span class="line">      ..color = <span class="type">Colors</span>.blue[<span class="number">400</span>]</span><br><span class="line">      ..style = <span class="type">PaintingStyle</span>.fill;</span><br><span class="line">    canvas.drawRect(</span><br><span class="line">      <span class="type">Rect</span>.fromLTWH(</span><br><span class="line">        (size.width - barWidth) / <span class="number">2.0</span>,</span><br><span class="line">        size.height - barHeight,</span><br><span class="line">        barWidth,</span><br><span class="line">        barHeight,</span><br><span class="line">      ),</span><br><span class="line">      paint,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  bool shouldRepaint(<span class="type">BarChartPainter</span> old) =&gt; barHeight != old.barHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂性已经让人头疼，尽管我们的数据集只是一个数字！设置动画控件所需的代码是一个次要问题，因为当我们获得更多图表数据时，它不会产生分支。真正的问题是变量 <code>startHeight</code>，<code>currentHeight</code> 和 <code>endHeight</code>，它们反映了对数据集和动画值所做的更改，并在三个不同的地方进行了更新。</p><p>我们需要一个概念来处理这个烂摊子。</p><hr><p><strong>tweens</strong>，虽然远非Flutter独有，但它们是构造动画代码的一个非常简单的概念。他们的主要贡献是用函数试方法取代上面的命令式方法。tween 是一个值。它描述了空间中的两个点之间的路径，如条形图一样，动画值从 0 到 1 运行。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827a8ec20fee65?w=260&amp;h=335&amp;f=jpeg&amp;s=15466" alt></p><p>Tweens 是通用的，并且可以在 Dart 中表示为 “Tween <t>” 类型的对象：</t></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Tween</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> T begin;</span><br><span class="line">  <span class="keyword">final</span> T end;</span><br><span class="line">  </span><br><span class="line">  Tween(<span class="keyword">this</span>.begin, <span class="keyword">this</span>.end);</span><br><span class="line">  </span><br><span class="line">  <span class="function">T <span class="title">lerp</span><span class="params">(<span class="keyword">double</span> t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>专业术语 <code>lerp</code> 来自计算机图形学领域，是 linear interpolation（作为名词）和 linearly interpolate（作为动词）的缩写。参数 <code>t</code> 是动画值，tween 应该从 <code>begin</code>（当 <code>t</code> 为零时）到 <code>end</code>（当 <code>t</code> 为 1 时）。</p><p>Flutter SDK 的 <code>[Tween &lt;T&gt;](https://docs.flutter.io/flutter/animation/Tween-class.html)</code> 类与上面相似，但它支持 <code>begin</code> 和 <code>end</code> 突变。我不完全确定为什么会做出这样的选择，但是在 SDK 动画支持方面可能有很好的理由，这里我还没深入探索。在下面，我将使用 Flutter<code>Tween &lt;T&gt;</code>，假装它是不可变的。</p><p>我们可以使用 “Tween<double>” 来代替代码中的条形图高度 barHeight：</double></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="symbol">'dart</span>:math';</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/animation.dart';</span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/material.dart';</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(<span class="type">MaterialApp</span>(home: <span class="type">ChartPage</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">ChartPageState</span> createState() =&gt; <span class="type">ChartPageState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPageState</span> <span class="keyword">extends</span> <span class="title">State&lt;ChartPage&gt;</span> <span class="keyword">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> random = <span class="type">Random</span>();</span><br><span class="line">  int dataSet = <span class="number">50</span>;</span><br><span class="line">  <span class="type">AnimationController</span> animation;</span><br><span class="line">  <span class="type">Tween</span>&lt;double&gt; tween;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    animation = <span class="type">AnimationController</span>(</span><br><span class="line">      duration: const <span class="type">Duration</span>(milliseconds: <span class="number">300</span>),</span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line">    tween = <span class="type">Tween</span>&lt;double&gt;(begin: <span class="number">0.0</span>, end: dataSet.toDouble());</span><br><span class="line">    animation.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    animation.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void changeData() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      dataSet = random.nextInt(<span class="number">100</span>);</span><br><span class="line">      tween = <span class="type">Tween</span>&lt;double&gt;(</span><br><span class="line">        begin: tween.evaluate(animation),</span><br><span class="line">        end: dataSet.toDouble(),</span><br><span class="line">      );</span><br><span class="line">      animation.forward(from: <span class="number">0.0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Scaffold</span>(</span><br><span class="line">      body: <span class="type">Center</span>(</span><br><span class="line">        child: <span class="type">CustomPaint</span>(</span><br><span class="line">          size: <span class="type">Size</span>(<span class="number">200.0</span>, <span class="number">100.0</span>),</span><br><span class="line">          painter: <span class="type">BarChartPainter</span>(tween.animate(animation)),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="type">FloatingActionButton</span>(</span><br><span class="line">        child: <span class="type">Icon</span>(<span class="type">Icons</span>.refresh),</span><br><span class="line">        onPressed: changeData,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarChartPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line">  static const barWidth = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">BarChartPainter</span>(<span class="type">Animation</span>&lt;double&gt; animation)</span><br><span class="line">      : animation = animation,</span><br><span class="line">        <span class="keyword">super</span>(repaint: animation);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Animation</span>&lt;double&gt; animation;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void paint(<span class="type">Canvas</span> canvas, <span class="type">Size</span> size) &#123;</span><br><span class="line">    <span class="keyword">final</span> barHeight = animation.value;</span><br><span class="line">    <span class="keyword">final</span> paint = <span class="type">Paint</span>()</span><br><span class="line">      ..color = <span class="type">Colors</span>.blue[<span class="number">400</span>]</span><br><span class="line">      ..style = <span class="type">PaintingStyle</span>.fill;</span><br><span class="line">    canvas.drawRect(</span><br><span class="line">      <span class="type">Rect</span>.fromLTWH(</span><br><span class="line">        (size.width - barWidth) / <span class="number">2.0</span>,</span><br><span class="line">        size.height - barHeight,</span><br><span class="line">        barWidth,</span><br><span class="line">        barHeight,</span><br><span class="line">      ),</span><br><span class="line">      paint,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  bool shouldRepaint(<span class="type">BarChartPainter</span> old) =&gt; <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 <code>Tween</code> 将条形图高度动画端点打包在一个值中。它与 <code>AnimationController</code> 和 <code>CustomPainter</code> 灵活的交换，避免了动画期间的 widgets 树重建。Flutter 基础架构现在标记 <code>CustomPaint</code> 用于在每个动画刻度处重绘，而不是标记整个 <code>ChartPage</code> 子树用于重建，重新布局和重绘。这些都是明确的改进。但 tween 概念还有更多内容; 它提供 <em>structure</em> 来组织我们的想法和代码，但我们不用特意关注这些。Tween 动画描述，</p><p>动画值从0到1运动时，通过遍历空间路径中所有 <code>_T_</code> 的路径进行动画。用 <code>_Tween &lt;T&gt; _</code> 对路径建模。</p><p>在上面的代码中，<code>T</code> 是一个 <code>double</code>，但我们不想动画是 <code>double</code>，我们想要制作条形图的动画！嗯，好的，现在是单独条形图，但概念很强，如果我们有需要，可以扩展它。</p><p>（你可能想知道，为什么我们不进一步讨论这个问题，并且坚持数据集动画化，而不是将其表示为条形图。这是因为数据集与条形图不同，条形图是图形对象。通常不会占据平滑路径存在的空间。条形图的数据集通常涉及映射到离散数据类的数字数据。但如果没有条形图的空间表示，则涉及不同类别的两个数据集之间没有合理的平滑路径概念。）</p><p>回到我们的代码，我们需要一个 <code>Bar</code> 类型和一个 <code>BarTween</code> 来为它设置动画。让我们将与 bar 相关的类提取到 <code>main.dart</code> 旁边的 <code>bar.dart</code> 文件中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="symbol">'dart</span>:ui' show lerpDouble;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/animation.dart';</span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/material.dart';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="type">Bar</span>(<span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> double height;</span><br><span class="line"></span><br><span class="line">  static <span class="type">Bar</span> lerp(<span class="type">Bar</span> begin, <span class="type">Bar</span> end, double t) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Bar</span>(lerpDouble(begin.height, end.height, t));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarTween</span> <span class="keyword">extends</span> <span class="title">Tween&lt;Bar&gt;</span> </span>&#123;</span><br><span class="line">  <span class="type">BarTween</span>(<span class="type">Bar</span> begin, <span class="type">Bar</span> end) : <span class="keyword">super</span>(begin: begin, end: end);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Bar</span> lerp(double t) =&gt; <span class="type">Bar</span>.lerp(begin, end, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BarChartPainter</span> <span class="keyword">extends</span> <span class="title">CustomPainter</span> </span>&#123;</span><br><span class="line">  static const barWidth = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">BarChartPainter</span>(<span class="type">Animation</span>&lt;<span class="type">Bar</span>&gt; animation)</span><br><span class="line">      : animation = animation,</span><br><span class="line">        <span class="keyword">super</span>(repaint: animation);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="type">Animation</span>&lt;<span class="type">Bar</span>&gt; animation;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void paint(<span class="type">Canvas</span> canvas, <span class="type">Size</span> size) &#123;</span><br><span class="line">    <span class="keyword">final</span> bar = animation.value;</span><br><span class="line">    <span class="keyword">final</span> paint = <span class="type">Paint</span>()</span><br><span class="line">      ..color = <span class="type">Colors</span>.blue[<span class="number">400</span>]</span><br><span class="line">      ..style = <span class="type">PaintingStyle</span>.fill;</span><br><span class="line">    canvas.drawRect(</span><br><span class="line">      <span class="type">Rect</span>.fromLTWH(</span><br><span class="line">        (size.width - barWidth) / <span class="number">2.0</span>,</span><br><span class="line">        size.height - bar.height,</span><br><span class="line">        barWidth,</span><br><span class="line">        bar.height,</span><br><span class="line">      ),</span><br><span class="line">      paint,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  bool shouldRepaint(<span class="type">BarChartPainter</span> old) =&gt; <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我在遵循一个 Flutter SDK 约定，在 <code>Bar</code> 类的静态方法中定义 <code>BarTween.lerp</code>。这适用于简单类型，如 “Bar”，“Color”，“Rect” 等等，但我们需要重新考虑更多涉及图表类型的方法。Dart SDK 中没有 <code>double.lerp</code>，所以我们使用 <code>dart：ui</code> 包中的 <code>lerpDouble</code> 函数来达到同样的效果。</p><p>我们的应用程序现在可以用 Bar 重新表达，如下面的代码所示；我借此机会调用 <code>dataSet</code>。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="symbol">'dart</span>:math';</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/animation.dart';</span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'package</span>:flutter/material.dart';</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="symbol">'bar</span>.dart';</span><br><span class="line"></span><br><span class="line">void main() &#123;</span><br><span class="line">  runApp(<span class="type">MaterialApp</span>(home: <span class="type">ChartPage</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">ChartPageState</span> createState() =&gt; <span class="type">ChartPageState</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChartPageState</span> <span class="keyword">extends</span> <span class="title">State&lt;ChartPage&gt;</span> <span class="keyword">with</span> <span class="title">TickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> random = <span class="type">Random</span>();</span><br><span class="line">  <span class="type">AnimationController</span> animation;</span><br><span class="line">  <span class="type">BarTween</span> tween;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    animation = <span class="type">AnimationController</span>(</span><br><span class="line">      duration: const <span class="type">Duration</span>(milliseconds: <span class="number">300</span>),</span><br><span class="line">      vsync: <span class="keyword">this</span>,</span><br><span class="line">    );</span><br><span class="line">    tween = <span class="type">BarTween</span>(<span class="type">Bar</span>(<span class="number">0.0</span>), <span class="type">Bar</span>(<span class="number">50.0</span>));</span><br><span class="line">    animation.forward();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  void dispose() &#123;</span><br><span class="line">    animation.dispose();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  void changeData() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      tween = <span class="type">BarTween</span>(</span><br><span class="line">        tween.evaluate(animation),</span><br><span class="line">        <span class="type">Bar</span>(random.nextDouble() * <span class="number">100.0</span>),</span><br><span class="line">      );</span><br><span class="line">      animation.forward(from: <span class="number">0.0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="type">Widget</span> build(<span class="type">BuildContext</span> context) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Scaffold</span>(</span><br><span class="line">      body: <span class="type">Center</span>(</span><br><span class="line">        child: <span class="type">CustomPaint</span>(</span><br><span class="line">          size: <span class="type">Size</span>(<span class="number">200.0</span>, <span class="number">100.0</span>),</span><br><span class="line">          painter: <span class="type">BarChartPainter</span>(tween.animate(animation)),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: <span class="type">FloatingActionButton</span>(</span><br><span class="line">        child: <span class="type">Icon</span>(<span class="type">Icons</span>.refresh),</span><br><span class="line">        onPressed: changeData,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新版本更长，额外的代码被添加。这些代码将会出现，当我们在<a href="https://medium.com/@mravn/zero-to-one-with-flutter-part-two-5aa2f06655cb" target="_blank" rel="noopener">第二部分</a>中解决增加的图表复杂性时。我们的要求涉及彩条，多条，部分数据，堆叠条，分组条，堆叠和分组条，…所有这些都是动画的。敬请关注。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/7/16827a8efe002dd4?w=372&amp;h=308&amp;f=gif&amp;s=9773142" alt></p><p>我们将在第二部分中对其中一个动画进行预览。</p><blockquote><p>如果发现译文存在错误或其他需要改进的地方，欢迎到 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 对译文进行修改并 PR，也可获得相应奖励积分。文章开头的 <strong>本文永久链接</strong> 即为本文在 GitHub 上的 MarkDown 链接。</p></blockquote><hr><blockquote><p><a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a> 是一个翻译优质互联网技术文章的社区，文章来源为 <a href="https://juejin.im" target="_blank" rel="noopener">掘金</a> 上的英文分享文章。内容覆盖 <a href="https://github.com/xitu/gold-miner#android" target="_blank" rel="noopener">Android</a>、<a href="https://github.com/xitu/gold-miner#ios" target="_blank" rel="noopener">iOS</a>、<a href="https://github.com/xitu/gold-miner#前端" target="_blank" rel="noopener">前端</a>、<a href="https://github.com/xitu/gold-miner#后端" target="_blank" rel="noopener">后端</a>、<a href="https://github.com/xitu/gold-miner#区块链" target="_blank" rel="noopener">区块链</a>、<a href="https://github.com/xitu/gold-miner#产品" target="_blank" rel="noopener">产品</a>、<a href="https://github.com/xitu/gold-miner#设计" target="_blank" rel="noopener">设计</a>、<a href="https://github.com/xitu/gold-miner#人工智能" target="_blank" rel="noopener">人工智能</a>等领域，想要查看更多优质译文请持续关注 <a href="https://github.com/xitu/gold-miner" target="_blank" rel="noopener">掘金翻译计划</a>、<a href="http://weibo.com/juejinfanyi" target="_blank" rel="noopener">官方微博</a>、<a href="https://zhuanlan.zhihu.com/juejinfanyi" target="_blank" rel="noopener">知乎专栏</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter-从-0-到-1&quot;&gt;&lt;a href=&quot;#Flutter-从-0-到-1&quot; class=&quot;headerlink&quot; title=&quot;Flutter 从 0 到 1&quot;&gt;&lt;/a&gt;Flutter 从 0 到 1&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
      <category term="Flutter" scheme="https://hongruqi.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>Flutter异步编程</title>
    <link href="https://hongruqi.github.io/2018/12/27/Flutter%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B-%20Futures/"/>
    <id>https://hongruqi.github.io/2018/12/27/Flutter异步编程- Futures/</id>
    <published>2018-12-26T16:00:00.000Z</published>
    <updated>2019-02-23T06:24:13.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Flutter异步编程"><a href="#Flutter异步编程" class="headerlink" title="Flutter异步编程"></a>Flutter异步编程</h1><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul><li>Dart代码运行在一个已执行的线程内。</li><li>阻塞线程执行的代码能够使程序冻结。</li><li>Future对象（Futures）表示异步执行的结果（将要完成的执行结果或I/O操作）。</li><li>异步函数使用await()(或者用then())，暂停执行直到future完成。</li><li>异步函数使用try-cache表达式，捕获错误。</li><li>构造一个isolate(web 使用 worker)，立刻运行代码，</li></ul><p>Dart代码运行在一个已执行的线程内。如果Dart代码阻塞，例如，运行一个长时间运算或者等待I/O操作，程序将要冻结。<br>异步操作可以让你在等待一个操作完成时，进行其他工作。Dart使用Future对象（Futures）表示异步执行结果。<br>你可以使用async和await也可以使用Future API，进行futures开发。</p><blockquote><p>Node: 所有Dart代码运行在isolate上下文中，这个isolate拥有Dart代码所有内存。当Dart代码执行时，isolate内不能运行其他代码。<br>如果你想多部分Dart代码同时运行，你能运行他们在其他的isolate（Web 用workers代替 isolate）。多个isolate同时运行，通常运行在各自的CPU内核上。isolate不共享内存，他们之间的唯一沟通方式是发送消息。关于isolate更多内容，请查看文档<a href="https://api.dartlang.org/stable/2.1.0/dart-isolate/dart-isolate-library.html" target="_blank" rel="noopener">isolates</a>或者<a href="https://api.dartlang.org/stable/2.1.0/dart-html/Worker-class.html" target="_blank" rel="noopener">web workers</a></p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>让我们看一些可能导致程序冻结的代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Synchronous code</span></span><br><span class="line">void printDailyNewsDigest() &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">new</span><span class="type">sDigest</span> = gatherNewsReports(); <span class="comment">// Can take a while.</span></span><br><span class="line">  print(<span class="keyword">new</span><span class="type">sDigest</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  printDailyNewsDigest();</span><br><span class="line">  printWinningLotteryNumbers();</span><br><span class="line">  printWeatherForecast();</span><br><span class="line">  printBaseballScore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的程序收集当天的新闻，并打印它，然后打印一些用户感兴趣的其他项目:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;gathered <span class="keyword">new</span><span class="type">s</span> goes <span class="keyword">here</span>&gt;</span><br><span class="line">Winning lotto numbers: <span class="type"></span>[<span class="number">23</span>, <span class="number">63</span>, <span class="number">87</span>, <span class="number">26</span>, <span class="number">2</span>]</span><br><span class="line">Tomorrow<span class="string">'s forecast: 70F, sunny.</span></span><br><span class="line"><span class="string">Baseball score: Red Sox 10, Yankees 0</span></span><br></pre></td></tr></table></figure><p>我们的代码是有潜在问题的：由于gatherNewsReports()阻塞，余下的代码只能一直等待gatherNewsReports()从文件读取返回值之后执行。如果读取文件花费很长时间，用户必须等，尽管用户可能更想知道他们是否赢了彩票，明天的天气是什么，谁赢了今天的比赛。</p><p>为了保证程序响应，Dart库作者处理耗时操作时使用异步模式，这些函数使用future作为返回值。</p><p>#Future 是什么？<br>future是一个Future<t>对象，它表示一个异步操作产生一个T类型的结果。如果结果为不可用的值，返回类型为Future<void>。当一个返回futrue的函数被调用时，有两件事发生：</void></t></p><ol><li>该函数将加入工作队列，并返回一个未完成的Future对象。</li><li>之后，当操作完成后，返回完成的Future对象值或者错误。</li></ol><p>使用future，有两种方式：</p><ul><li>用async 和 await</li><li>用Future API</li></ul><h1 id="Async-和-await"><a href="#Async-和-await" class="headerlink" title="Async 和 await"></a>Async 和 await</h1><p>async和await是Dart支持异步编程的一部分。他们允许你写异步代码，看起来像同步代码并且不需要使用Future API。<br>异步函数即是将async关键字放在函数体前即可。await关键字只用在async函数。<br>下面程序使用async和await模拟从 <a href="http://www.dartlang.org" target="_blank" rel="noopener">www.dartlang.org</a>. 读取内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file</span></span><br><span class="line"><span class="comment">// for details. All rights reserved. Use of this source code is governed by a</span></span><br><span class="line"><span class="comment">// BSD-style license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; printDailyNewsDigest() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> newsDigest = <span class="keyword">await</span> gatherNewsReports();</span><br><span class="line">  <span class="built_in">print</span>(newsDigest);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  printDailyNewsDigest();</span><br><span class="line">  printWinningLotteryNumbers();</span><br><span class="line">  printWeatherForecast();</span><br><span class="line">  printBaseballScore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printWinningLotteryNumbers() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Winning lotto numbers: [23, 63, 87, 26, 2]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printWeatherForecast() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Tomorrow's forecast: 70F, sunny."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printBaseballScore() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Baseball score: Red Sox 10, Yankees 0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> news = <span class="string">'&lt;gathered news goes here&gt;'</span>;</span><br><span class="line"><span class="keyword">const</span> oneSecond = <span class="built_in">Duration</span>(seconds: <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Imagine that this function is more complex and slow. :)</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; gatherNewsReports() =&gt;</span><br><span class="line">    Future.delayed(oneSecond, () =&gt; news);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alternatively, you can get news from a server using features</span></span><br><span class="line"><span class="comment">// from either dart:io or dart:html. For example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// import 'dart:html';</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString(</span></span><br><span class="line"><span class="comment">//      'https://www.dartlang.org/f/dailyNewsDigest.txt',</span></span><br><span class="line"><span class="comment">//    );</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Winning lotto numbers</span>: [23, 63, 87, 26, 2]</span><br><span class="line"><span class="attribute">Tomorrow's forecast</span>: 70F, sunny.</span><br><span class="line"><span class="attribute">Baseball score</span>: Red Sox 10, Yankees 0</span><br><span class="line">&lt;gathered news goes here&gt;</span><br></pre></td></tr></table></figure><p>printDailyNewsDigest()是第一个被调用的，虽然只是输出一行，但是新闻也是最后被打印的。这是因为运行和打印代码是异步运行的。</p><p>在这个例子中，printDailyNewsDigest()调用非阻塞gatherNewsReports()，调用gatherNewsReports()会将执行任务加入队列，但不会阻止剩下代码执行。程序打印彩票号码，预测棒球比赛分数。当gatherNewsReports() 完成获得新闻后，打印它。如果gatherNewsReports()花费一些时间完成，由于异步执行也不会给用户带来很大的影响。在打印每日新闻之前用户可以阅读其他消息。</p><p>请留意返回类型， gatherNewsReports()的返回类型是Future<string>，这意味这个返回值是一个以字符future。printDailyNewsDigest() 无返回值，它的返回类型为Future<void>。</void></string></p><p>下图展示调用流程，数字和步骤相互对应：</p><p><img src="https://user-gold-cdn.xitu.io/2018/12/26/167e9874a198490b?w=1704&amp;h=588&amp;f=png&amp;s=193800" alt></p><ol><li>程序开始运行</li><li>main函数调用printDailyNewsDigest()，printDailyNewsDigest()开始执行。</li><li>printDailyNewsDigest()使用await调用atherNewsReports(),atherNewsReports()开始执行。</li><li>gatherNewsReports()返回一个未完成的future（一个Future<string>实例）。</string></li><li>因为printDailyNewsDigest()是一个异步函数并且等待返回值，它暂停执行并返回一个未完成的future（这种情况下，返回的是Future<void>）给它的调用者（这里是main函数）。</void></li><li>执行剩下的打印函数。因为他们是同步的，每个函数完全执行完，才会执行下一个函数。例如，彩票中奖号码都是在天气预报之前打印出来的。</li><li>当main()函数完成执行，异步函数仍然能执行。首先gatherNewsReports() 完成后返回future，然后 printDailyNewsDigest()继续执行，打印新闻。</li><li>当printDailyNewsDigest()函数体完成执行，完成的future返回，程序退出。</li></ol><p>注意，异步函数立即(同步地)开始执行。当第一次出现一下情况时，函数暂停执行，并返回一个未完成的future:</p><ul><li>函数的第一个await表达式（函数获得未完成future之后)。</li><li>reture 语句。</li><li>函数体结束。</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>异步函数使用try-cache进行错误处理。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;<span class="keyword">void</span>&gt; <span class="title">printDailyNewsDigest</span>(<span class="params"></span>) <span class="keyword">async</span></span> &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> newsDigest = <span class="keyword">await</span> gatherNewsReports();</span><br><span class="line">    print(newsDigest);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle error...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try-cache的行为在异步代码和同步代码中是相同的，如果try块中的代码抛出异常，则catch子句中的代码将执行。</p><h2 id="顺序处理"><a href="#顺序处理" class="headerlink" title="顺序处理"></a>顺序处理</h2><p>您可以使用多个await表达式来确保顺序执行，即每个语句在执行下一个语句之前完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Sequential processing using <span class="keyword">async</span> <span class="keyword">and</span> <span class="keyword">await</span>.</span><br><span class="line">main() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> expensiveA();</span><br><span class="line">  <span class="keyword">await</span> expensiveB();</span><br><span class="line">  doSomethingWith(<span class="keyword">await</span> expensiveC());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expensiveA()执行完成后，才会执行expensiveB().</p><p>#Future API<br>在Dart 1.9中添加async和await之前，您必須使用Future API。目前仍然可能在老的Dart代码中以及需要比asyn-await提供更丰富功能的代码中，看到Future API。</p><p>使用Future API写异步代码，用then()注册回调。当Future完成后，回调被执行。</p><p>下面程序使用Future API模拟从 <a href="http://www.dartlang.org" target="_blank" rel="noopener">www.dartlang.org</a>. 读取内容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2013, the Dart project authors.  Please see the AUTHORS file</span></span><br><span class="line"><span class="comment">// for details. All rights reserved. Use of this source code is governed by a</span></span><br><span class="line"><span class="comment">// BSD-style license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;<span class="keyword">void</span>&gt; printDailyNewsDigest() &#123;</span><br><span class="line">  <span class="keyword">final</span> future = gatherNewsReports();</span><br><span class="line">  <span class="keyword">return</span> future.then(<span class="built_in">print</span>);</span><br><span class="line">  <span class="comment">// You don't *have* to return the future here.</span></span><br><span class="line">  <span class="comment">// But if you don't, callers can't await it.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  printDailyNewsDigest();</span><br><span class="line">  printWinningLotteryNumbers();</span><br><span class="line">  printWeatherForecast();</span><br><span class="line">  printBaseballScore();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printWinningLotteryNumbers() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Winning lotto numbers: [23, 63, 87, 26, 2]'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printWeatherForecast() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Tomorrow's forecast: 70F, sunny."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printBaseballScore() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Baseball score: Red Sox 10, Yankees 0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> news = <span class="string">'&lt;gathered news goes here&gt;'</span>;</span><br><span class="line"><span class="keyword">const</span> oneSecond = <span class="built_in">Duration</span>(seconds: <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Imagine that this function is more complex and slow. :)</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; gatherNewsReports() =&gt;</span><br><span class="line">    Future.delayed(oneSecond, () =&gt; news);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Alternatively, you can get news from a server using features</span></span><br><span class="line"><span class="comment">// from either dart:io or dart:html. For example:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// import 'dart:html';</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Future&lt;String&gt; gatherNewsReportsFromServer() =&gt; HttpRequest.getString(</span></span><br><span class="line"><span class="comment">//      'https://www.dartlang.org/f/dailyNewsDigest.txt',</span></span><br><span class="line"><span class="comment">//    );</span></span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Winning lotto numbers</span>: [23, 63, 87, 26, 2]</span><br><span class="line"><span class="attribute">Tomorrow's forecast</span>: 70F, sunny.</span><br><span class="line"><span class="attribute">Baseball score</span>: Red Sox 10, Yankees 0</span><br><span class="line">&lt;gathered news goes here&gt;</span><br></pre></td></tr></table></figure><p>printDailyNewsDigest()是第一个被调用的，虽然只是输出一行，但是新闻也是最后被打印的。这是因为运行和打印代码是异步运行的。</p><p>程序执行步骤：</p><ol><li>开始执行</li><li>main()函数调用printDailyNewsDigest()，printDailyNewsDigest()没有立即返回，而是调用了gatherNewsReports().</li><li>gatherNewsReports()开始获取新闻并且返回一个Future。</li><li>printDailyNewsDigest()使用then()处理对应的Future返回值。调用then()返回一个新的Future，它将作为then()的回调参数。</li><li>执行剩下的打印函数。因为他们是同步的，每个函数完全执行完，才会执行下一个函数。例如，彩票中奖号码都是在天气预报之前打印出来的。</li><li>当所有的新闻都收到后， gatherNewsReports()完成后返回包含新闻信息字符串的Future。</li><li>在printDailyNewsDigest()中指定的then()执行，打印新闻。</li><li>退出程序。</li></ol><blockquote><p>Node : 在printDailyNewsDigest()函数，future.then(print) 等价于：<br>future.then((newsDigest) =&gt; print(newsDigest))</p></blockquote><p>另外，then()内部代码可以使用{}:</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;void&gt; printDailyNewsDigest() &#123;</span><br><span class="line">  <span class="keyword">final</span> future = gatherNewsReports();</span><br><span class="line">  <span class="keyword">return</span> future.<span class="keyword">then</span>((newsDigest) &#123;</span><br><span class="line">    <span class="built_in">print</span>(newsDigest);</span><br><span class="line">    // <span class="keyword">Do</span> something <span class="keyword">else</span>...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你需要提供一个参数给then()的回调，即使Future是Future<void>类型。按照惯例，一个无用参数使用下划线表示。</void></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> future = printDailyNewsDigest();</span><br><span class="line"><span class="function"><span class="keyword">return</span> future.<span class="title">then</span><span class="params">((_)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Code that doesn't use the `_` parameter...</span></span><br><span class="line">  print(<span class="string">'All reports printed.'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>##错误处理<br>使用Future API，你能用catchError()捕获错误。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;<span class="keyword">void</span>&gt; printDailyNewsDigest() =&gt;</span><br><span class="line">    gatherNewsReports().then(<span class="built_in">print</span>).catchError(handleError);</span><br></pre></td></tr></table></figure><p>如果新闻数据读取无效，代码的执行流程如下：</p><ol><li>gatherNewsReports()返回包含错误信息的future。</li><li>then()返回的future以错误结束，print()函数不被掉用。</li><li>catchError() (handleError())处理错误， catchError()返回的正常的future，并且错误不会被传播。</li></ol><blockquote><p>链式模式是Future API的常见模式。可以将Future API 等同于try-catch模块。</p></blockquote><p>与then()类似，catchError()返回一个新的Future，它是回调的返回值。<br>更多详细信息和例子，请参考<a href="https://www.dartlang.org/guides/libraries/futures-error-handling" target="_blank" rel="noopener">Futures and Error Handling</a>.</p><h2 id="调用多个函数"><a href="#调用多个函数" class="headerlink" title="调用多个函数"></a>调用多个函数</h2><p>考虑三个函数，expensiveA(), expensiveB(), 和expensiveC(),这三个函数都返回Future对象。你能顺序调用他们，或者你能同时开始他们，并在所有函数执行完成后做一些事情。Future接口可以轻松的处理这两种用例。</p><h3 id="使用then-进行链式调用"><a href="#使用then-进行链式调用" class="headerlink" title="使用then()进行链式调用"></a>使用then()进行链式调用</h3><p>当函数需要按顺序执行时，使用链式then():</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expensiveA()</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">(aValue)</span> =&gt;</span> expensiveB())</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">(bValue)</span> =&gt;</span> expensiveC())</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">(cValue)</span> =&gt;</span> doSomethingWith(cValue));</span><br></pre></td></tr></table></figure><p>嵌套回调虽然可以工作，但是难于阅读。</p><h3 id="使用Future-wait-等待多个future完成"><a href="#使用Future-wait-等待多个future完成" class="headerlink" title="使用Future.wait()等待多个future完成"></a>使用Future.wait()等待多个future完成</h3><p>如果函数的执行顺序不重要，你可以用Future.wait()。</p><p>当你传递一个future列表给Future.wait(),它立刻返回一个未完成的future。直到给定的future列表全部执行完这个future才完成。future的返回值，由列表中的每个future的返回值组成。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future.wait([expensiveA(), expensiveB(), expensiveC()])</span><br><span class="line">    .<span class="keyword">then</span>(<span class="function"><span class="params">(List responses)</span> =&gt;</span> chooseBestResponse(responses, moreInfo))</span><br><span class="line">    .catchError(handleError);</span><br></pre></td></tr></table></figure><p>如果任何一个函数返回错误，Future.wait()的futrue都以错误结束。使用catchError()处理错误。</p><p>#其他资源<br>阅读以下文档，了解有关在Dart中使用future和异步编程的更多详细信息：</p><ul><li><a href="https://www.dartlang.org/guides/libraries/futures-error-handling" target="_blank" rel="noopener">Futures and Error Handling</a></li><li><a href="https://webdev.dartlang.org/articles/performance/event-loop" target="_blank" rel="noopener">The Event Loop and Dart</a></li><li><a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">Asynchrony support</a></li><li>API 文档API <a href="https://api.dartlang.org/stable/2.1.0/dart-async/Future-class.html" target="_blank" rel="noopener">futures</a>, <a href="https://api.dartlang.org/stable/2.1.0/dart-isolate/dart-isolate-library.html" target="_blank" rel="noopener">isolates</a>, <a href="https://api.dartlang.org/stable/2.1.0/dart-html/Worker-class.html" target="_blank" rel="noopener">web workers</a>.</li></ul><p>#原文链接<br><a href="https://www.dartlang.org/tutorials/language/futures" target="_blank" rel="noopener">Asynchronous Programming: Futures</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Flutter异步编程&quot;&gt;&lt;a href=&quot;#Flutter异步编程&quot; class=&quot;headerlink&quot; title=&quot;Flutter异步编程&quot;&gt;&lt;/a&gt;Flutter异步编程&lt;/h1&gt;&lt;h2 id=&quot;重点&quot;&gt;&lt;a href=&quot;#重点&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Flutter" scheme="https://hongruqi.github.io/categories/Flutter/"/>
    
    
  </entry>
  
  <entry>
    <title>WKWebView 使用详解</title>
    <link href="https://hongruqi.github.io/2017/08/31/WKWebView%20%E7%89%B9%E6%80%A7/"/>
    <id>https://hongruqi.github.io/2017/08/31/WKWebView 特性/</id>
    <published>2017-08-30T16:00:00.000Z</published>
    <updated>2019-02-22T08:05:10.554Z</updated>
    
    <content type="html"><![CDATA[<p>#WKWebView 使用详解</p><p>##前言<br>WKWebView是在Apple的WWDC 2014发布，将原有UIWebViewDelegate与UIWebView重构成了14类与3个协议。<br>WKWebView，在iOS8和OS X 10.10开始支持，是为了解决UIWebView加载速度慢、占用内存大的问题。<br>在使用UIWebView加载网页的时候，会出现内存会无限增长，内存泄漏的问题。<br>WebKit中WKWebView控件的特性与使用方法，很好的解决了UIWebView存在的内存、加载速度等诸多问题。</p><h2 id="一、WKWebView-特性"><a href="#一、WKWebView-特性" class="headerlink" title="一、WKWebView 特性"></a>一、WKWebView 特性</h2><ul><li>占用更少的内存</li><li>Safari相同的JavaScript引擎</li><li>支持了更多的HTML5特性；</li><li>支持手势返回</li><li>滚动刷新率可达到60fps，堪比native</li></ul><p>##webkit<br><img src="http://upload-images.jianshu.io/upload_images/901318-ed61ead50e44c08d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WebKit.png"></p><p>##OC与JS交互<br>WKWebview提供了API实现js交互 不需要借助JavaScriptCore或者webJavaScriptBridge。</p><p>###WKWebView<br>WKWebView对象显示交互式Web内容，例如针对应用内浏览器。 您可以使用WKWebView类将Web内容嵌入到您的应用程序中。 只需要创建一个WKWebView对象，并向其发送加载Web内容的请求。<br><strong>API</strong></p><p>初始化</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame configuration:(<span class="built_in">WKWebViewConfiguration</span> *)configuration</span><br></pre></td></tr></table></figure><p>常用方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)loadRequest:(<span class="built_in">NSURLRequest</span> *)request;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)loadHTMLString:(<span class="built_in">NSString</span> *)string baseURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)baseURL;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)goBack;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)goForward;</span><br><span class="line"><span class="comment">// Reloads the current page.</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)reload;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKNavigation</span> *)reloadFromOrigin;</span><br></pre></td></tr></table></figure><p>###WKNavigtionDelegate</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面开始加载时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didStartProvisionalNavigation:(<span class="built_in">WKNavigation</span> *)navigation;</span><br><span class="line"><span class="comment">// 当内容开始返回时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didCommitNavigation:(<span class="built_in">WKNavigation</span> *)navigation;</span><br><span class="line"><span class="comment">// 页面加载完成之后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFinishNavigation:(<span class="built_in">WKNavigation</span> *)navigation;</span><br><span class="line"><span class="comment">// 页面加载失败时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didFailProvisionalNavigation:(<span class="built_in">WKNavigation</span> *)navigation;</span><br><span class="line"><span class="comment">// 接收到服务器跳转请求之后再执行</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView didReceiveServerRedirectForProvisionalNavigation:(<span class="built_in">WKNavigation</span> *)navigation;</span><br><span class="line"><span class="comment">// 在收到响应后，决定是否跳转</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationResponse:(<span class="built_in">WKNavigationResponse</span> *)navigationResponse decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationResponsePolicy</span>))decisionHandler;</span><br><span class="line"><span class="comment">// 在发送请求之前，决定是否跳转</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView decidePolicyForNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction decisionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">WKNavigationActionPolicy</span>))decisionHandler;</span><br></pre></td></tr></table></figure><p>###WKUIDelegate</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个新的WebVeiw</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">WKWebView</span> *)webView:(<span class="built_in">WKWebView</span> *)webView createWebViewWithConfiguration:(<span class="built_in">WKWebViewConfiguration</span> *)configuration forNavigationAction:(<span class="built_in">WKNavigationAction</span> *)navigationAction windowFeatures:(<span class="built_in">WKWindowFeatures</span> *)windowFeatures;</span><br><span class="line"><span class="comment">//2.WebVeiw关闭（9.0中的新方法）</span></span><br><span class="line">- (<span class="keyword">void</span>)webViewDidClose:(<span class="built_in">WKWebView</span> *)webView <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_11, <span class="number">9</span>_0);</span><br><span class="line"><span class="comment">//3.显示一个JS的Alert（与JS交互）</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptAlertPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"><span class="comment">//4.弹出一个输入框（与JS交互的）</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptTextInputPanelWithPrompt:(<span class="built_in">NSString</span> *)prompt defaultText:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)defaultText initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSString</span> * __<span class="keyword">nullable</span> result))completionHandler;</span><br><span class="line"><span class="comment">//5.显示一个确认框（JS的）</span></span><br><span class="line">- (<span class="keyword">void</span>)webView:(<span class="built_in">WKWebView</span> *)webView runJavaScriptConfirmPanelWithMessage:(<span class="built_in">NSString</span> *)message initiatedByFrame:(<span class="built_in">WKFrameInfo</span> *)frame completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> result))completionHandler;</span><br></pre></td></tr></table></figure><h3 id="JS调用OC"><a href="#JS调用OC" class="headerlink" title="JS调用OC"></a>JS调用OC</h3><p>使用WKUserContentController实现js=&gt;native交互。简单的说就是先注册约定好的方法，然后再调用。<br><strong>流程图：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">op=&gt;operation: 配置环境</span><br><span class="line">op1=&gt;operation: 注册方法</span><br><span class="line">op-&gt;op1</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置环境，使用WKWebViewConfiguration</span></span><br><span class="line"><span class="built_in">WKWebViewConfiguration</span> *configuration = [[<span class="built_in">WKWebViewConfiguration</span> alloc] init];</span><br><span class="line">configuration.allowsInlineMediaPlayback = <span class="literal">YES</span>;</span><br><span class="line"><span class="built_in">WKUserContentController</span> *userContentController = [[<span class="built_in">WKUserContentController</span> alloc] init];</span><br><span class="line">configuration.userContentController = userContentController;</span><br><span class="line"><span class="comment">//注册方法</span></span><br><span class="line">／*</span><br><span class="line"><span class="keyword">self</span>.hybrid 是WTWebViewJSBridge类实例，处理js调用native方法</span><br><span class="line">BridgeName js 方法名</span><br><span class="line">*／</span><br><span class="line">[userContentController addScriptMessageHandler:<span class="keyword">self</span>.hybrid name:BridgeName];</span><br></pre></td></tr></table></figure><p><strong>JS回调处理</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WTWebViewJSBridge.m</span></span><br><span class="line">- (<span class="keyword">void</span>)userContentController:(<span class="built_in">WKUserContentController</span> *)userContentController didReceiveScriptMessage:(<span class="built_in">WKScriptMessage</span> *)message</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([message.name isEqualToString:BridgeName]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([message.body isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> postMessage:message.body];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="meta">###OC调用JS</span></span><br><span class="line">这个简单多了，直接用<span class="built_in">WKWebview</span>，evaluateJavaScript方法进行调用</span><br><span class="line">```ObjC</span><br><span class="line">- (<span class="keyword">void</span>)evaluateJavaScript:(<span class="built_in">NSString</span> *)javaScriptString completionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">id</span>, <span class="built_in">NSError</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.webkit) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.webkit evaluateJavaScript:javaScriptString completionHandler:completionHandler];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##<a href="https://github.com/hongruqi/WTWebView" target="_blank" rel="noopener">详细Demo地址</a></p><p>##参考作者：<br><a href="http://www.jianshu.com/p/8f6d527f13bc" target="_blank" rel="noopener">iOS开发之WKWebView简单使用和常用使用场景</a><br><a href="http://www.jianshu.com/p/e537e6587274" target="_blank" rel="noopener">iOS开发 - WKWebView使用详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#WKWebView 使用详解&lt;/p&gt;
&lt;p&gt;##前言&lt;br&gt;WKWebView是在Apple的WWDC 2014发布，将原有UIWebViewDelegate与UIWebView重构成了14类与3个协议。&lt;br&gt;WKWebView，在iOS8和OS X 10.10开始支持
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 组件开发</title>
    <link href="https://hongruqi.github.io/2017/08/08/iOS%20%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <id>https://hongruqi.github.io/2017/08/08/iOS 组件开发/</id>
    <published>2017-08-07T16:00:00.000Z</published>
    <updated>2019-02-22T08:02:32.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-组件开发"><a href="#iOS-组件开发" class="headerlink" title="iOS 组件开发"></a>iOS 组件开发</h1><p>####<a href="https://github.com/hongruqi/WTModule" target="_blank" rel="noopener">WTModule组件间通信</a></p><p>##背景<br> 关于组件化开发，经历过几家不同公司，正好处于不同的开发阶段。<br>第一家港股上市公司，移动端业务线很多，主要是即时通讯功能，类似与微博的社区功能，企业ERP功能，视频教育功能，开始各条业务线独立，相互调用只能通过彼此提供静态库或者framework进行，每次升级都需要重新集成，比较麻烦，问题也很多，问题反馈解决时间也很漫长。之后公司后台业务重构，移动端随之进行组件化开发，经历了整个过程。<br>第二家公司，国内知名互联企业，进入开发组时，已经完成组件化工作，各个业务人员在自己的业务线上进行开发，每条业务线独立提测，在这样的业务线上工作，可以更专一的完成个人负责的业务，效率更高。<br>目前所在公司，没有进行组件化，业务耦合严重，全局变量使用频繁，经常会因为A业务被修改，导致B业务产生bug。现阶段开始进行组件化。</p><p>##个人思考： 什么时候做组件开发</p><ul><li>项目管理：项目的业务线超过2条以上，需要独立拆分。随着业务的拆分，对应的业务组件也就很自然的独立出来。</li><li>人员管理：随着人员的增加，过多人对同一块代码的进行修改，导致bug的可能性上升，这时候需要对人员和其维护的功能需要进行重新分配。</li><li>测试维度：随着项目的业务量增大，不做组件化，就很难做单元测试。每个小功能修改，测试都需要对App进行测试，严重增加测试工作量。</li><li>综上：当你的App业务之间交叉耦合，bug率难以下降，测试每天做大量重复工作。开发人员之间修改相互影响时，你需要考虑进行组件化。</li></ul><h2 id="如何做组件开"><a href="#如何做组件开" class="headerlink" title="如何做组件开"></a>如何做组件开</h2><h2 id="组件划分"><a href="#组件划分" class="headerlink" title="组件划分"></a>组件划分</h2><p><img src="http://upload-images.jianshu.io/upload_images/901318-be6b6895fec095e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构图.png"></p><blockquote><p>按照架构图，我们将App分为壳工程 + 业务 + 公共组件</p></blockquote><ol><li>壳工程：主要包含</li></ol><ul><li>main</li><li>XXAppDelegate</li><li>工程配置</li><li>Debug页面</li></ul><ol start="2"><li>业务组件：<blockquote><p>业务组件之间不相互依赖，只可以依赖公共业务组件和公共组件， 业务之间的调用通过统一的组件进行。</p></blockquote></li></ol><ul><li>具体业务组件：根据项目自身业务进行拆分</li><li>基础业务组件：User组件</li></ul><ol start="3"><li>公共组件：可以被业务组件依赖</li></ol><hr><p> 以下为我们目前的划分：</p><p>###公共组件：</p><ul><li>埋点组件</li><li>Common组件（聚合工具类）</li><li>启动组件</li><li>性能监控组件</li><li>定位组件</li><li>图片处理组件</li><li>UIKit封装和扩展组件</li><li>业务生命周期及通信组件<br>###网络组件：</li><li>基础网络组件 基于AFNetworking进行封装，提供JSON转Model，和缓存功能</li><li>DNS 加速组件<br>###持久化组件</li><li>基于FMDB进行封装组件<br>###第三方业务组件，在第三方SDK基础上进行适配</li><li>分享组件</li><li>推送组件<br>###基础业务组件</li><li>User组件，保存用户信息，登陆，登出状态</li></ul><p>##如何做组件</p><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul><li>Git</li><li>CocoaPods<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3>通过Pods 进划分好的组件，进行私有Pod化。可以参考这篇文档<br><a href="http://www.jianshu.com/p/80eeb5bc8834" target="_blank" rel="noopener">发布私有CocoaPod Spec</a></li></ul><h2 id="组件的构造和通信"><a href="#组件的构造和通信" class="headerlink" title="组件的构造和通信"></a>组件的构造和通信</h2><p>###组件生命周期管理</p><ul><li>组件的生命周期，与App的生命周期应该保持一致。<br><img src="http://upload-images.jianshu.io/upload_images/901318-07fec64bc877746a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组件生命周期.png"></li></ul><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#WTAppDelegate.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WTAppDelegate</span> : <span class="title">UIResponder</span>&lt;<span class="title">UIApplicationDelegate</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWindow</span> *window;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="meta">#WTAppDelegate.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WTAppDelegate.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WTModuleLifecycle+AppDelegate.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WTAppDelegate</span></span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[WTModuleLifecycle instance] application:application</span><br><span class="line">                                 didFinishLaunchingWithOptions:launchOptions];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didRegisterUserNotificationSettings:(<span class="built_in">UIUserNotificationSettings</span> *)notificationSettings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//注册远程通知</span></span><br><span class="line">    [application registerForRemoteNotifications];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)deviceToken</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] application:application</span><br><span class="line">       didRegisterForRemoteNotificationsWithDeviceToken:deviceToken];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didFailToRegisterForRemoteNotificationsWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] application:application</span><br><span class="line">       didFailToRegisterForRemoteNotificationsWithError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] application:application</span><br><span class="line">                           didReceiveRemoteNotification:userInfo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] application:application</span><br><span class="line">                            didReceiveLocalNotification:notification];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application continueUserActivity:(<span class="built_in">NSUserActivity</span> *)userActivity restorationHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span> * _Nullable))restorationHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[WTModuleLifecycle instance] application:application</span><br><span class="line">                                          continueUserActivity:userActivity</span><br><span class="line">                                            restorationHandler:restorationHandler];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidEnterBackground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] applicationDidEnterBackground:application];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidBecomeActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] applicationDidBecomeActive:application];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillResignActive:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] applicationWillResignActive:application];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillTerminate:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] applicationWillTerminate:application];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationDidReceiveMemoryWarning:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] applicationDidReceiveMemoryWarning:application];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application openURL:(<span class="built_in">NSURL</span> *)url sourceApplication:(<span class="built_in">NSString</span> *)sourceApplication annotation:(<span class="keyword">id</span>)annotation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[WTModuleLifecycle instance] application:application</span><br><span class="line">                                                       openURL:url</span><br><span class="line">                                             sourceApplication:sourceApplication</span><br><span class="line">                                                    annotation:annotation];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)app openURL:(<span class="built_in">NSURL</span> *)url options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">UIApplicationOpenURLOptionsKey</span>,<span class="keyword">id</span>&gt; *)options</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[WTModuleLifecycle instance] application:app openURL:url options:options];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application performActionForShortcutItem:(<span class="built_in">UIApplicationShortcutItem</span> *)shortcutItem completionHandler:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> succeeded))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] application:application</span><br><span class="line">                           performActionForShortcutItem:shortcutItem</span><br><span class="line">                                      completionHandler:completionHandler];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)applicationWillEnterForeground:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">&#123;</span><br><span class="line">    [[WTModuleLifecycle instance] applicationWillEnterForeground:application];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###组件间通信</p><blockquote><p>现状：目前非常流行的方式为，蘑菇街的解决方案，通过路由协议，实现全部App的内页面间跳转。不过我们没有选择这样做。</p></blockquote><ul><li>首先，我们定义件间： 有与App相同的生命周期，可以独立编译，功能独立，对外提供统一接口。</li></ul><blockquote><p>通过上面的定义，我们会发现路由协议不适用于我们对组件的定义。<br>分析：页面路由，打破了件间的独立性，虽然是通过统一的协议进行访问。但是这样就存在一个问题。A组件的一个子界面，可以访问B组件的子界面。这对我们对组件的理解有些矛盾。A组件的子界面需要调用B的子界面，需要通过B组件提供的接口调用。</p></blockquote><p>##我们的实现</p><ol><li>注册组件由WTModuleLifecycle最为媒介持有组件</li><li>通过统一API调用，实现组件间通信</li></ol><p>###代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"WTModuleMessager.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"WTModuleLifecycle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WTModuleMessager</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> *services;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WTModuleMessager</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)instance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="keyword">static</span> WTModuleMessager *instance;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        instance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _services = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">id</span>)performAPI:(<span class="built_in">NSString</span> *)moduleName methodName:(<span class="built_in">NSString</span> *)methodName withParams:(<span class="built_in">NSDictionary</span> *)params</span><br><span class="line">&#123;</span><br><span class="line">    Class targetClass = [WTModuleMessager serviceClassFromString:moduleName];</span><br><span class="line">    SEL targetSelector = [WTModuleMessager selectorFromString:methodName hasCallBack:<span class="literal">NO</span>];</span><br><span class="line">    <span class="keyword">if</span> (![WTModuleMessager validateClass:targetClass selector:targetSelector]) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(targetClass, <span class="string">@"%@ 名称不规范"</span>,moduleName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//    id targetOpenService = [[targetClass alloc]init];</span></span><br><span class="line">    <span class="keyword">id</span> targetOpenService = [[WTModuleLifecycle instance] moduleInstanceByName:<span class="built_in">NSStringFromClass</span>(targetClass)];</span><br><span class="line">    <span class="keyword">if</span> ([targetOpenService respondsToSelector:targetSelector]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>))objc_msgSend)(targetOpenService, targetSelector, params);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(targetClass, <span class="string">@"%@ 找不到对应的类方法"</span>,methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)performAPI:(<span class="built_in">NSString</span> *)moduleName methodName:(<span class="built_in">NSString</span> *)methodName withParams:(<span class="built_in">NSDictionary</span> *)params block:(WTModuleMessagerCallback)block</span><br><span class="line">&#123;</span><br><span class="line">    Class targetClass = [WTModuleMessager serviceClassFromString:moduleName];</span><br><span class="line">    SEL targetSelector = [WTModuleMessager selectorFromString:methodName hasCallBack:<span class="literal">YES</span>];</span><br><span class="line">    <span class="keyword">if</span> (![WTModuleMessager validateClass:targetClass selector:targetSelector]) &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(targetClass, <span class="string">@"%@ 名称不规范"</span>,moduleName);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">id</span> targetOpenService = [[targetClass alloc]init];</span><br><span class="line">    <span class="keyword">if</span> ([targetOpenService respondsToSelector:targetSelector]) &#123;</span><br><span class="line">        [[WTModuleMessager instance].services addObject:targetOpenService];</span><br><span class="line">        <span class="keyword">return</span> ((<span class="built_in">BOOL</span> (*)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>, WTModuleMessagerCallback))objc_msgSend)(targetOpenService, targetSelector, params,[WTModuleMessager callbackBlock:block openService:targetOpenService]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(targetClass, <span class="string">@"%@ 找不到对应的类方法"</span>,methodName);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (WTModuleMessagerCallback)callbackBlock:(WTModuleMessagerCallback)callbackBlock openService:(<span class="built_in">NSObject</span> *)openService</span><br><span class="line">&#123;</span><br><span class="line">    WTModuleMessagerCallback block = ^(<span class="built_in">NSError</span> *error, <span class="keyword">id</span> result)&#123;</span><br><span class="line">        [[WTModuleMessager instance].services removeObject:openService];</span><br><span class="line">        callbackBlock(error,result);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> [block <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)validateClass:(Class)targetClass selector:(SEL)targetSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetClass &amp;&amp; targetSelector) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)serviceClassFromString:(<span class="built_in">NSString</span> *)moduleName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *pathArray = [moduleName componentsSeparatedByString:<span class="string">@"/"</span>];</span><br><span class="line">    <span class="built_in">NSMutableString</span> *serviceClassMS = [[<span class="built_in">NSMutableString</span> alloc] initWithString:<span class="string">@"WT"</span>];</span><br><span class="line">    [serviceClassMS appendString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>, [[pathArray.firstObject substringToIndex:<span class="number">1</span>] capitalizedString], [pathArray.firstObject substringFromIndex:<span class="number">1</span>]]];</span><br><span class="line">    [serviceClassMS appendString:<span class="string">@"Module"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSClassFromString</span>(serviceClassMS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (SEL)selectorFromString:(<span class="built_in">NSString</span> *)methodName hasCallBack:(<span class="built_in">BOOL</span>)hasCallBack</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *pathArray = [methodName componentsSeparatedByString:<span class="string">@"/"</span>];</span><br><span class="line">    <span class="built_in">NSMutableString</span> *serviceClassMS = [[<span class="built_in">NSMutableString</span> alloc] init];</span><br><span class="line">    [serviceClassMS appendString:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>, [[pathArray.firstObject substringToIndex:<span class="number">1</span>] lowercaseString], [pathArray.firstObject substringFromIndex:<span class="number">1</span>]]];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *selectorString = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (hasCallBack) &#123;</span><br><span class="line">        selectorString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@:block:"</span>,serviceClassMS];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        selectorString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@:"</span>,serviceClassMS];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NSSelectorFromString</span>(selectorString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####<a href="https://github.com/hongruqi/WTModule" target="_blank" rel="noopener">组件化基础代码Github地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-组件开发&quot;&gt;&lt;a href=&quot;#iOS-组件开发&quot; class=&quot;headerlink&quot; title=&quot;iOS 组件开发&quot;&gt;&lt;/a&gt;iOS 组件开发&lt;/h1&gt;&lt;p&gt;####&lt;a href=&quot;https://github.com/hongruqi/WTMod
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS App 启动优化</title>
    <link href="https://hongruqi.github.io/2017/07/19/iOS%20App%20%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/"/>
    <id>https://hongruqi.github.io/2017/07/19/iOS App 启动优化/</id>
    <published>2017-07-18T16:00:00.000Z</published>
    <updated>2019-02-22T08:01:01.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-App-启动优化"><a href="#iOS-App-启动优化" class="headerlink" title="iOS App 启动优化"></a>iOS App 启动优化</h1><h2 id="技术调研"><a href="#技术调研" class="headerlink" title="技术调研"></a>技术调研</h2><h3 id="启动时间计算公式"><a href="#启动时间计算公式" class="headerlink" title="启动时间计算公式"></a>启动时间计算公式</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App总启动时间 = t<span class="number">1</span><span class="comment">(main()</span>之前的加载时间) + t<span class="number">2</span><span class="comment">(main()</span>之后的加载时间)。</span><br></pre></td></tr></table></figure><blockquote><p>t1 = 系统dylib(动态链接库)和自身App可执行文件的加载； </p></blockquote><blockquote><p>t2 = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</p></blockquote><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><h4 id="main-调用之前加载过程"><a href="#main-调用之前加载过程" class="headerlink" title="main()调用之前加载过程"></a>main()调用之前加载过程</h4><p>exec() 是一个系统调用。系统内核把应用映射到新的地址空间，且每次起始位置都是随机的（因为使用 ASLR）。并将起始位置到 0x000000 这段范围的进程权限都标记为不可读写不可执行。如果是 32 位进程，这个范围至少是 4KB；对于 64 位进程则至少是 4GB。NULL 指针引用和指针截断误差都是会被它捕获。</p><h4 id="dylib-loading"><a href="#dylib-loading" class="headerlink" title="dylib loading"></a>dylib loading</h4><p>从主执行文件的 header 获取到需要加载的所依赖动态库列表，而 header 早就被内核映射过。然后它需要找到每个 dylib，然后打开文件读取文件起始位置，确保它是 Mach-O 文件。接着会找到代码签名并将其注册到内核。然后在 dylib 文件的每个 segment 上调用 mmap()。应用所依赖的 dylib 文件可能会再依赖其他 dylib，所以 dyld 所需要加载的是动态库列表一个递归依赖的集合。一般应用会加载 100 到 400 个 dylib 文件，但大部分都是系统 dylib，它们会被预先计算和缓存起来，加载速度很快。</p><h4 id="rebase-bind"><a href="#rebase-bind" class="headerlink" title="rebase/bind"></a>rebase/bind</h4><p>由于ASLR(address space layout randomization)的存在，可执行文件和动态链接库在虚拟内存中的加载地址每次启动都不固定，所以需要这2步来修复镜像中的资源指针，来指向正确的地址。 rebase修复的是指向当前镜像内部的资源指针； 而bind指向的是镜像外部的资源指针。<br>rebase步骤先进行，需要把镜像读入内存，并以page为单位进行加密验证，保证不会被篡改，所以这一步的瓶颈在IO。bind在其后进行，由于要查询符号表，来指向跨镜像的资源，加上在rebase阶段，镜像已被读入和加密验证，所以这一步的瓶颈在于CPU计算。<br>通过命令行可以查看相关的资源指针:</p><p>xcrun dyldinfo -rebase -bind -lazy_bind myApp.App/myApp</p><p>优化该阶段的关键在于减少__DATA segment中的指针数量。我们可以优化的点有：</p><ol><li>减少Objc类数量， 减少selector数量</li><li>减少C++虚函数数量</li><li>转而使用swift struct（其实本质上就是为了减少符号的数量）</li></ol><h4 id="Objc-Runtime"><a href="#Objc-Runtime" class="headerlink" title="Objc Runtime"></a>Objc Runtime</h4><p>这一步主要工作是:</p><ol><li>注册Objc类 (class registration)</li><li>把category的定义插入方法列表 (category registration)</li><li>保证每一个selector唯一 (selctor uniquing)</li></ol><p>由于之前2步骤的优化，这一步实际上没有什么可做的。</p><h4 id="initializers"><a href="#initializers" class="headerlink" title="initializers"></a>initializers</h4><p>以上三步属于静态调整(fix-up)，都是在修改__DATA segment中的内容，而这里则开始动态调整，开始在堆和堆栈中写入内容。 在这里的工作有：</p><ol><li>Objc的+load()函数,使用 +initialize 来替代 +load</li><li>C++的构造函数属性函数 形如attribute((constructor)) void DoSomeInitializationWork()</li><li>非基本类型的C++静态全局变量的创建(通常是类或结构体)(non-trivial initializer) 比如一个全局静态结构体的构建，如果在构造函数中有繁重的工作，那么会拖慢启动速度</li></ol><p>Objc的load函数和C++的静态构造函数采用由底向上的方式执行，来保证每个执行的方法，都可以找到所依赖的动态库。</p><h3 id="main-调用之后的加载时间"><a href="#main-调用之后的加载时间" class="headerlink" title="main()调用之后的加载时间"></a>main()调用之后的加载时间</h3><p>在main()被调用之后，App的主要工作就是初始化必要的服务，显示首页内容等。而我们的优化也是围绕如何能够快速展现首页来开展。 App通常在AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法中创建首页需要展示的view，然后在当前runloop的末尾，主动调用CA::Transaction::commit完成视图的渲染。<br>而视图的渲染主要涉及三个阶段：</p><p>准备阶段 这里主要是图片的解码<br>布局阶段 首页所有UIView的- (void)layoutSubViews()运行<br>绘制阶段 首页所有UIView的- (void)drawRect:(CGRect)rect运行<br>再加上启动之后必要服务的启动、必要数据的创建和读取，这些就是我们可以尝试优化的地方</p><p>因此，main()函数调用之前我们可以优化的点有：</p><ul><li>不使用xib，直接视用代码加载首页视图。</li><li>NSUserDefaults实际上是在Library文件夹下会生产一个plist文件，如果文件太大的话一次能读取到内存中可能很耗时，这个影响需要评估，如果耗时很大的话需要拆分(需考虑老版本覆盖安装兼容问题)。</li><li>每次用NSLog方式打印会隐式的创建一个Calendar, 仅仅针对内测版输出log。</li><li>梳理应用启动时发送的所有网络请求，统一在异步线程请求。</li><li>并行初始化各个业务。</li></ul><p>###优化方案</p><h3 id="main-调用之前加载过程-优化内容"><a href="#main-调用之前加载过程-优化内容" class="headerlink" title="main()调用之前加载过程,优化内容"></a>main()调用之前加载过程,优化内容</h3><ol><li>减少framework引用</li><li>删除无用类，无用函数</li><li>减少+load 函数使用</li></ol><h3 id="main-调用之后-优化内容"><a href="#main-调用之后-优化内容" class="headerlink" title="main()调用之后, 优化内容"></a>main()调用之后, 优化内容</h3><p>####思路</p><ul><li>launcherImage图片尽量小，实测这个大小会影响启动速度</li><li>Splash 不要Xib，直接用代码尽量简单</li><li>将需要执行的处理，放入不同的block内，并发到不同的queue中进行。</li><li>提供串行队列，执行有依赖的逻辑</li><li>提供group，对彼此依赖不明确，但需要整体执行完成后，进行处理的业务，提供dispatch_group功能满足需求。<br>~~</li><li>对于MainThread有需要的业务，提供mainThread 支持。 <h4 id="提供四个type选项执行启动block"><a href="#提供四个type选项执行启动block" class="headerlink" title="提供四个type选项执行启动block"></a>提供四个type选项执行启动block</h4></li><li>WTAppLauncherType_WTGroupQueue 自定义group</li><li>WTAppLauncherType_MainThread 主线程async 执行 block</li><li>WTAppLauncherType_ConcurrentQueue concurrent queue 执行block</li><li>WTAppLauncherType_SerialQueue sync 执行 block</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, WTAppLauncherType) &#123;</span><br><span class="line">    WTAppLauncherType_WTGroupQueue,</span><br><span class="line">    WTAppLauncherType_MainThread,</span><br><span class="line">    WTAppLauncherType_ConcurrentQueue,</span><br><span class="line">    WTAppLauncherType_SerialQueue <span class="comment">// 串行队列，放入有执行顺序的block</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addLauncherWithType:(WTAppLauncherType )type block:(dispatch_block_t) block;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 等待barrier之前的ConcurrentQueue中的block操作执行完毕后，barrier中的block执行，并且在barrier函数执行之后,barrier函数之后的操作才会得到执行</span></span><br><span class="line"><span class="comment"> 满足一些需要之前业务逻辑</span></span><br><span class="line"><span class="comment"> @param block run block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)barrierAsyncRunLaunchInConcurrentQueue:(dispatch_block_t) block;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> add Group Queue notification</span></span><br><span class="line"><span class="comment"> 添加group notification 监听group 之前的block 执行完成。</span></span><br><span class="line"><span class="comment"> 如果有业务需要依赖之前的block 执行完， 可以调用这个api 进行处理。</span></span><br><span class="line"><span class="comment"> @param block run block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)addNotificationGroupQueue:(dispatch_block_t) block; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 结束初始化调用函数，必须被调用，确保之前加入的block，在didFinishLaunching函数结束前，全部被执行完。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)endLanuchingWithTimeout:(<span class="keyword">float</span>)timeout;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/hongruqi/WTAppLauncher" target="_blank" rel="noopener">Launcher 具体代码</a></p><p><a href="https://techblog.toutiao.com/2017/01/17/iosspeed/" target="_blank" rel="noopener">今日头条iOS客户端启动速度优化</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/406/" target="_blank" rel="noopener">苹果广告视频</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-App-启动优化&quot;&gt;&lt;a href=&quot;#iOS-App-启动优化&quot; class=&quot;headerlink&quot; title=&quot;iOS App 启动优化&quot;&gt;&lt;/a&gt;iOS App 启动优化&lt;/h1&gt;&lt;h2 id=&quot;技术调研&quot;&gt;&lt;a href=&quot;#技术调研&quot; cla
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 应用，性能监控</title>
    <link href="https://hongruqi.github.io/2017/07/15/iOS%20%E5%BA%94%E7%94%A8%EF%BC%8C%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <id>https://hongruqi.github.io/2017/07/15/iOS 应用，性能监控/</id>
    <published>2017-07-14T16:00:00.000Z</published>
    <updated>2019-02-22T07:59:56.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-应用，性能监控"><a href="#iOS-应用，性能监控" class="headerlink" title="iOS 应用，性能监控"></a>iOS 应用，性能监控</h1><h2 id="github-源码地址"><a href="#github-源码地址" class="headerlink" title="github 源码地址"></a><a href="https://github.com/hongruqi/Walle.git" target="_blank" rel="noopener">github 源码地址</a></h2><h1 id="iOS-应用，性能监控-1"><a href="#iOS-应用，性能监控-1" class="headerlink" title="iOS 应用，性能监控"></a>iOS 应用，性能监控</h1><blockquote><p>背景，目前正在优化项目，首先要对项目内的性能指标进行分析，这个可以通过Instrument 进行debug 分析。这样做只适用于开发人员。性能指标作为一项衡量App的重要指标无法量化。为了每次发布前能有一个性能报告，需要开发一个组件，对性能数据进行记录，之后通过脚本生成报表。</p></blockquote><p>##报表中重点关注的指标有以下几点：</p><ul><li>启动时间</li><li>内存</li><li>FPS（页面刷新帧率）</li><li>CPU </li><li>页面渲染时间</li></ul><h2 id="debug模式"><a href="#debug模式" class="headerlink" title="debug模式"></a>debug模式</h2><ul><li>主线程阻塞时，输出MainThread 栈信息。</li></ul><p>##分别介绍如何实现这些数据的采集。</p><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vm_size_t usedMemory(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">struct</span> task_basic_info info;</span><br><span class="line">    mach_msg_type_number_t size = <span class="keyword">sizeof</span>(info);</span><br><span class="line">    kern_return_t kerr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);</span><br><span class="line">    <span class="keyword">return</span> (kerr == KERN_SUCCESS) ? info.resident_size : <span class="number">0</span>; <span class="comment">// size in bytes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FPS"><a href="#FPS" class="headerlink" title="FPS"></a>FPS</h3><ul><li>使用CADisplayLink 进行获取</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">        _displayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(envokeDisplayLink:)];</span><br><span class="line">        [_displayLink addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)envokeDisplayLink:(<span class="built_in">CADisplayLink</span> *)displayLink</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_lastTime == <span class="number">0</span>) &#123;</span><br><span class="line">        _lastTime = displayLink.timestamp;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _count ++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSTimeInterval</span> interval = displayLink.timestamp - _lastTime;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (interval &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _lastTime = displayLink.timestamp;</span><br><span class="line">    <span class="built_in">CGFloat</span> fps = _count / interval;</span><br><span class="line">    _count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInteger</span> shownFPS = round(fps);</span><br><span class="line">    <span class="built_in">CGFloat</span> memory = [XYPerformanceUtility usedMemoryInMB];</span><br><span class="line">    <span class="built_in">CGFloat</span> cpu = [XYPerformanceUtility cpuUsage];</span><br><span class="line">    DDLogInfo(<span class="string">@"FPS:%ld,MEM:%.2f,CPU:%.2f"</span>, (<span class="keyword">long</span>)shownFPS, memory, cpu);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.performanceView setPerformanceViewData:cpu memory:memory FPS:shownFPS];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> cpu_usage()</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t kr;</span><br><span class="line">    task_info_data_t tinfo;</span><br><span class="line">    mach_msg_type_number_t task_info_count;</span><br><span class="line">    </span><br><span class="line">    task_info_count = TASK_INFO_MAX;</span><br><span class="line">    kr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)tinfo, &amp;task_info_count);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    task_basic_info_t      basic_info;</span><br><span class="line">    thread_array_t         thread_list;</span><br><span class="line">    mach_msg_type_number_t thread_count;</span><br><span class="line">    </span><br><span class="line">    thread_info_data_t     thinfo;</span><br><span class="line">    mach_msg_type_number_t thread_info_count;</span><br><span class="line">    </span><br><span class="line">    thread_basic_info_t basic_info_th;</span><br><span class="line">    uint32_t stat_thread = <span class="number">0</span>; <span class="comment">// Mach threads</span></span><br><span class="line">    </span><br><span class="line">    basic_info = (task_basic_info_t)tinfo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get threads in the task</span></span><br><span class="line">    kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (thread_count &gt; <span class="number">0</span>)</span><br><span class="line">        stat_thread += thread_count;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> tot_sec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> tot_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">float</span> tot_cpu = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; thread_count; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        thread_info_count = THREAD_INFO_MAX;</span><br><span class="line">        kr = thread_info(thread_list[j], THREAD_BASIC_INFO,</span><br><span class="line">                         (thread_info_t)thinfo, &amp;thread_info_count);</span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        basic_info_th = (thread_basic_info_t)thinfo;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) &#123;</span><br><span class="line">            tot_sec = tot_sec + basic_info_th-&gt;user_time.seconds + basic_info_th-&gt;system_time.seconds;</span><br><span class="line">            tot_usec = tot_usec + basic_info_th-&gt;user_time.microseconds + basic_info_th-&gt;system_time.microseconds;</span><br><span class="line">            tot_cpu = tot_cpu + basic_info_th-&gt;cpu_usage / (<span class="keyword">float</span>)TH_USAGE_SCALE * <span class="number">100.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="comment">// for each thread</span></span><br><span class="line">    </span><br><span class="line">    kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * <span class="keyword">sizeof</span>(thread_t));</span><br><span class="line">    assert(kr == KERN_SUCCESS);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tot_cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    loadTime = mach_absolute_time();</span><br><span class="line">    mach_timebase_info(&amp;timebaseInfo);</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        __block <span class="keyword">id</span> obs;</span><br><span class="line">        obs = [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserverForName:<span class="built_in">UIApplicationDidFinishLaunchingNotification</span></span><br><span class="line">                                                                object:<span class="literal">nil</span> queue:<span class="literal">nil</span></span><br><span class="line">                                                            usingBlock:^(<span class="built_in">NSNotification</span> *note) &#123;</span><br><span class="line">                                                                <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">                                                                    applicationRespondedTime = mach_absolute_time();</span><br><span class="line">                                                                   DDLogInfo(<span class="string">@"VivaVedio_IOS_Start_Time: %.f"</span>, MachTimeToSeconds(applicationRespondedTime - loadTime));</span><br><span class="line">                                                                &#125;);</span><br><span class="line">                                                                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:obs];</span><br><span class="line">                                                            &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="页面渲染耗时"><a href="#页面渲染耗时" class="headerlink" title="页面渲染耗时"></a>页面渲染耗时</h3><p>利用runtime， 将UIViewController 的viewWillAppear， viewDidAppear 进行hook。输出调用的时间间隔。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIViewController</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CFTimeInterval</span> viewControllerAppearDuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Performance</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    [<span class="keyword">self</span> walle_swizzlingViewWillAppear];</span><br><span class="line">    [<span class="keyword">self</span> walle_swizzlingViewDidAppear];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)walle_swizzlingViewWillAppear</span><br><span class="line">&#123;</span><br><span class="line">    SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">    SEL swizzledSelector = <span class="keyword">@selector</span>(walle_viewWillAppear:);</span><br><span class="line">    [<span class="keyword">self</span> swizzlingInClass:[<span class="keyword">self</span> <span class="keyword">class</span>] originalSelector:originalSelector swizzledSelector:swizzledSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)walle_swizzlingViewDidAppear</span><br><span class="line">&#123;</span><br><span class="line">    SEL originalSelector = <span class="keyword">@selector</span>(viewDidAppear:);</span><br><span class="line">    SEL swizzledSelector = <span class="keyword">@selector</span>(walle_viewDidAppear:);</span><br><span class="line">    [<span class="keyword">self</span> swizzlingInClass:[<span class="keyword">self</span> <span class="keyword">class</span>] originalSelector:originalSelector swizzledSelector:swizzledSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)walle_viewWillAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.viewControllerAppearDuration = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    [<span class="keyword">self</span> walle_viewWillAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)walle_viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> walle_viewDidAppear:animated];</span><br><span class="line">    <span class="keyword">self</span>.viewControllerAppearDuration = <span class="built_in">CACurrentMediaTime</span>() - <span class="keyword">self</span>.viewControllerAppearDuration;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="built_in">NSString</span> *name = <span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>.class);</span><br><span class="line">        DDLogInfo(<span class="string">@"View Controller :%@ show time : %g s"</span>, name, <span class="keyword">self</span>.viewControllerAppearDuration);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)swizzlingInClass:(Class)cls originalSelector:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector</span><br><span class="line">&#123;</span><br><span class="line">    Class clz = cls;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(clz, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(clz, swizzledSelector);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(clz, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(clz, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setViewControllerAppearDuration:(<span class="built_in">CFTimeInterval</span>)viewControllerAppearDuration</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewControllerAppearDuration), @(viewControllerAppearDuration), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CFTimeInterval</span> )viewControllerAppearDuration</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(viewControllerAppearDuration)) doubleValue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="debug-主线程阻塞"><a href="#debug-主线程阻塞" class="headerlink" title="debug 主线程阻塞"></a>debug 主线程阻塞</h2><ul><li>通过监控Runloop的回调进行监控</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_observer = <span class="built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">true</span>, <span class="number">0</span>, ^(<span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFRunLoopActivity</span> activity) &#123;</span><br><span class="line">    <span class="keyword">self</span>-&gt;_activity = activity;</span><br><span class="line">    dispatch_semaphore_t semaphore = <span class="keyword">self</span>-&gt;_semaphore;</span><br><span class="line">    dispatch_semaphore_signal(semaphore);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopGetMain</span>(), _observer, kCFRunLoopCommonModes);</span><br><span class="line"><span class="comment">// 创建信号</span></span><br><span class="line">_semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 在子线程监控时长</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 超时250ms 认为卡顿</span></span><br><span class="line">        <span class="keyword">long</span> st = dispatch_semaphore_wait(_semaphore, dispatch_time(DISPATCH_TIME_NOW, <span class="number">50</span>*<span class="built_in">NSEC_PER_MSEC</span>));</span><br><span class="line">        <span class="keyword">if</span> (st != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (_activity == kCFRunLoopBeforeSources || _activity == kCFRunLoopAfterWaiting)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (++_countTime &lt; <span class="number">5</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="built_in">NSString</span> *track = [BSBacktraceLogger bs_backtraceOfMainThread];</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"############### Main thread is blocked ###############"</span>);</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, track);</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@"############### Main thread is blocked ###############"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _countTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-应用，性能监控&quot;&gt;&lt;a href=&quot;#iOS-应用，性能监控&quot; class=&quot;headerlink&quot; title=&quot;iOS 应用，性能监控&quot;&gt;&lt;/a&gt;iOS 应用，性能监控&lt;/h1&gt;&lt;h2 id=&quot;github-源码地址&quot;&gt;&lt;a href=&quot;#github
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 编码规范整理</title>
    <link href="https://hongruqi.github.io/2016/07/24/iOS%20%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B4%E7%90%86/"/>
    <id>https://hongruqi.github.io/2016/07/24/iOS 编码规范整理/</id>
    <published>2016-07-23T16:00:00.000Z</published>
    <updated>2019-02-22T07:54:31.867Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-编码规范整理"><a href="#iOS-编码规范整理" class="headerlink" title="iOS 编码规范整理"></a>iOS 编码规范整理</h1><blockquote><p>本文参考自<br><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/CodingGuidelines.html" target="_blank" rel="noopener">《苹果Cocoa编码规范》</a><br><a href="https://github.com/raywenderlich/objective-c-style-guide#language" target="_blank" rel="noopener">《objective-c-style-guide》</a><br>，希望能够启动抛砖引玉的功能。而且会持续更新，逐步细化。</p></blockquote><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><h3 id="一般原则"><a href="#一般原则" class="headerlink" title="一般原则"></a>一般原则</h3><h4 id="清晰"><a href="#清晰" class="headerlink" title="清晰"></a>清晰</h4><ul><li><p>命名最好清晰又简洁，但是不能过于简洁而失去了清晰。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insertObject:atIndex: <span class="comment">//这是个好例子</span></span><br><span class="line">insert:at: <span class="comment">//不够清晰，插入的是什么？at又指的是什么？</span></span><br></pre></td></tr></table></figure></li><li><p>名称通常不缩写，即使名称很长，也要拼写完全</p></li></ul><table><thead><tr><th>代码</th><th style="text-align:center">点评</th></tr></thead><tbody><tr><td>destinationSelection</td><td style="text-align:center">Good.</td></tr><tr><td>destSel</td><td style="text-align:center">Not clear.</td></tr><tr><td>setBackgroundColor:</td><td style="text-align:center">Good.</td></tr><tr><td>setBkgdColor:</td><td style="text-align:center">Not clear.</td></tr></tbody></table><p>关于缩写，你可能会认为某个缩写广为人知，但有可能并非如此，尤其是当你的代码被来自不同文化和语言背景的开发人员所使用时。当然，你可以使用少数非常常见，历史悠久的缩写。所有可以使用的缩写见<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/APIAbbreviations.html#//apple_ref/doc/uid/20001285-BCIHCGAE" target="_blank" rel="noopener">这个列表</a></p><blockquote><p>建议：类、变量和函数命名参考苹果的头文件及优秀的开源项目。</p></blockquote><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><ul><li>尽可能使用与 Cocoa 编程接口命名保持一致的名称。</li><li>在使用多态方法的类中，命名的一致性非常重要。在不同类中实现相同功能的方法应该具有相同的名称</li></ul><h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><p>由于苹果没有命名空间，因此使用前缀可以防止和苹果以及其他第三方库的命名冲突。</p><ul><li>不要使用下划线或子前缀</li><li>对class、protocol、structure、公开方法、常量命名时使用前缀，成员方法和结构体字段时不使用前缀。</li><li>Category 方法统一使用xy_methodName 形式进行扩展</li></ul><h4 id="书写约定"><a href="#书写约定" class="headerlink" title="书写约定"></a>书写约定</h4><ul><li>命名时单词之间不要使用下划线、破折号等标点符号分隔，请使用驼峰命名法对方法、变量进行命名</li><li><p>如果方法名使用一个广为人知的大写首字母缩略词开头，则首字母可以大些。如NSImage<br>中的TIFFRepresentation</p></li><li><p>如果方法名或者常量名使用了前缀，则前缀之后所有单词的首字母都要大写。如NSRunAlertPanel</p></li></ul><p><strong>避免使用下划线来表示名称的私有属性。苹果公司保留该方式的使用。如果第三方这样使用可能会导致命名冲突，他们可能会在无意中用自己的方法覆盖掉已有的私有方法，这会导致严重的后果</strong></p><h4 id="类和协议的命名"><a href="#类和协议的命名" class="headerlink" title="类和协议的命名"></a>类和协议的命名</h4><p>类名应该包含明确描述该类/对象是什么或者做什么的名词，类名要有合适的前缀。<br>协议应根据它包含的方法的作用来命名。</p><ul><li>大多数协议仅组合一组相关的方法，而不关联任何类，这种协议的命名应该使用动名词(ing)，以不与类名混淆  比如NSLocking </li><li>有些协议组合一些彼此无关的方法（这样做是避免创建多个独立的小协议）。这样的协议倾向于与某个类关联在一起，该类是协议的主要体现者。在这种情形，我们约定协议的名称与该类同名。NSObject 协议就是这样一个例子。这个协议组合一组彼此无关的方法，有用于查询对象在其类层次中位置的方法，有使之能调用特殊方法的方法以及用于增减引用计数的方法。由于 NSObject 是这些方法的主要体现者，所以我们用类的名称命名这个协议。</li></ul><h4 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h4><ul><li>声明孤立的类或协议：将孤立的类或协议声明放置在单独的头文件中，该头文件名称与类或协议同名</li><li>声明相关联的类或协议：将相关联的声明（类，类别及协议) 放置在一个头文件中，该头文件名称与主要的类/类别/协议的名字相同<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@protocol</span> SDWebImageManagerDelegate &lt;NSObject&gt;</span><br><span class="line"></span><br><span class="line"><span class="variable">@optional</span></span><br><span class="line">- (BOOL)<span class="attribute">imageManager</span>:(nonnull SDWebImageManager *)imageManager <span class="attribute">shouldDownloadImageForURL</span>:(nullable NSURL *)imageURL;</span><br><span class="line"><span class="variable">@end</span></span><br><span class="line"></span><br><span class="line"><span class="variable">@interface</span> <span class="attribute">SDWebImageManager </span>: NSObject</span><br><span class="line"></span><br><span class="line"><span class="variable">@property</span> (weak, nonatomic, nullable) id &lt;SDWebImageManagerDelegate&gt; delegate;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="方法命名规范"><a href="#方法命名规范" class="headerlink" title="方法命名规范"></a>方法命名规范</h2><h3 id="一般规则"><a href="#一般规则" class="headerlink" title="一般规则"></a>一般规则</h3><ul><li><p>小写第一个单词的首字符，大写随后单词的首字符，不使用前缀。有两种例外情况：<br>1，方法名以广为人知的大写字母缩略词（如TIFF or PDF）开头；<br>2，私有方法可以使用统一的前缀来分组和辨识</p></li><li><p>表示对象行为的方法，名称以动词开头</p></li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)invokeWithTarget:(<span class="keyword">id</span>)target:</span><br><span class="line">- (<span class="keyword">void</span>)selectTabViewItem:(<span class="built_in">NSTableViewItem</span> *)tableViewItem</span><br></pre></td></tr></table></figure><p>名称中不要出现 do 或 does，因为这些助动词没什么实际意义。也不要在动词前使用副词或形容词修饰</p><ul><li>方法返回接收者的某个属性，直接用属性名称命名。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSSize</span>)cellSize; <span class="comment">//优</span></span><br><span class="line">- (<span class="built_in">NSSize</span>)calcCellSize; <span class="comment">//差</span></span><br><span class="line">- (<span class="built_in">NSSize</span>)getCellSize; <span class="comment">//差</span></span><br></pre></td></tr></table></figure><blockquote><p>只有在方法需要间接返回多个值的情况下，才使用 get<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">//NSBezierPath</span></span><br><span class="line">&gt;- (<span class="keyword">void</span>) getLineDash:(<span class="keyword">float</span> *)pattern count:(<span class="keyword">int</span> *)count phase:(<span class="keyword">float</span> *)phase; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>像上面这样的方法，在其实现里应允许接受 NULL 作为其 in/out 参数，以表示调用者对一个或多个返回值不感兴趣。</p></blockquote><ul><li>参数前面的单词要能描述该参数</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendAction:(SEL)aSelector to:(<span class="keyword">id</span>)anObject forAllCells:(<span class="built_in">BOOL</span>)flag; <span class="comment">//优</span></span><br><span class="line">- (<span class="keyword">void</span>)sendAction:(SEL)aSelector :(<span class="keyword">id</span>)anObject :(<span class="built_in">BOOL</span>)flag; <span class="comment">//差</span></span><br><span class="line">- (<span class="keyword">id</span>)viewWithTag:(<span class="keyword">int</span>)aTag; <span class="comment">//优</span></span><br><span class="line">- (<span class="keyword">id</span>)taggedView:(<span class="keyword">int</span>)aTag; <span class="comment">//差</span></span><br></pre></td></tr></table></figure><ul><li>细化基类中的已有方法：创建一个新方法，其名称是在被细化方法名称后面追加参数关键词</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSView</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">NSRect</span>)frameRect;</span><br><span class="line"><span class="comment">//NSMatrix - NSView 的子类</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">NSRect</span>)frameRect </span><br><span class="line">               mode:(ind)aMode </span><br><span class="line">          cellClass:(Class)factoryId </span><br><span class="line">       numberOfRows:(<span class="keyword">int</span>)rowsHigh</span><br><span class="line">    numberOfColumns:(<span class="keyword">int</span>)colsWide;</span><br></pre></td></tr></table></figure><ul><li>不要使用 and 来连接用属性作参数关键字</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">int</span>) runModalForDirectory:(<span class="built_in">NSString</span> *)path file:(<span class="built_in">NSString</span> *)name types:(<span class="built_in">NSArray</span> *)fileTypes; <span class="comment">//优</span></span><br><span class="line">- (<span class="keyword">int</span>) runModalForDirectory:(<span class="built_in">NSString</span> *)path addFile:(<span class="built_in">NSString</span> *)name addTypes:(<span class="built_in">NSArray</span> *)fileTypes; <span class="comment">//差</span></span><br></pre></td></tr></table></figure><p>###访问方法</p><ul><li>如果属性是用名词描述的，则命名格式为：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (type)noun;</span><br><span class="line">- (<span class="keyword">void</span>)setNoun:(type)aNoun;</span><br></pre></td></tr></table></figure><p>如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSColor</span> *)color;</span><br><span class="line">- (<span class="keyword">void</span>)setgColor:(<span class="built_in">NSColor</span> *)aColor;</span><br></pre></td></tr></table></figure><ul><li>如果属性是用形容词描述的，则命名格式为：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isAdjective;</span><br><span class="line">- (<span class="keyword">void</span>)setAdjective:(<span class="built_in">BOOL</span>)flag;</span><br></pre></td></tr></table></figure><p>如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isEditable;</span><br><span class="line">- (<span class="keyword">void</span>)setEditable:(<span class="built_in">BOOL</span>)flag;</span><br></pre></td></tr></table></figure></p><ul><li>如果属性是用动词描述的，则命名格式为：（动词要用现在时时态）</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)verbObject;</span><br><span class="line">- (<span class="keyword">void</span>)setVerbObject:(<span class="built_in">BOOL</span>)flag;</span><br></pre></td></tr></table></figure><p>例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)showsAlpha;</span><br><span class="line">- (<span class="keyword">void</span>)setShowAlpha:(<span class="built_in">BOOL</span>)flag;</span><br></pre></td></tr></table></figure></p><ul><li>不要使用动词的过去分词形式作形容词使用</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)acceptsGlyphInfo; <span class="comment">//优</span></span><br><span class="line">- (<span class="keyword">void</span>)setAcceptsGlyphInfo:(<span class="built_in">BOOL</span>)flag; <span class="comment">//优</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)glyphInfoAccepted; <span class="comment">//差</span></span><br><span class="line">- (<span class="keyword">void</span>)setGlyphInfoAccepted:(<span class="built_in">BOOL</span>)flag; <span class="comment">//差</span></span><br></pre></td></tr></table></figure><ul><li>可以使用情态动词（can, should, will 等）来提高清晰性，但不要使用 do 或 does</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)canHide; <span class="comment">//优</span></span><br><span class="line">- (<span class="keyword">void</span>)setCanHide:(<span class="built_in">BOOL</span>)flag; <span class="comment">//优</span></span><br><span class="line">- (<span class="keyword">void</span>)shouldCloseDocument; <span class="comment">//优</span></span><br><span class="line">- (<span class="keyword">void</span>)setShouldCloseDocument:(<span class="built_in">BOOL</span>)flag; <span class="comment">//优</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)doseAcceptGlyphInfo; <span class="comment">//差</span></span><br><span class="line">- (<span class="keyword">void</span>)setDoseAcceptGlyphInfo: <span class="comment">//差</span></span><br></pre></td></tr></table></figure><h4 id="Delegate-Methods-委托方法"><a href="#Delegate-Methods-委托方法" class="headerlink" title="Delegate Methods 委托方法"></a>Delegate Methods 委托方法</h4><p>委托方法是那些在特定事件发生时可被对象调用，并声明在对象的委托类中的方法。它们有独特的命名约定，这些命名约定同样也适用于对象的数据源方法。</p><ul><li>名称以标示发送消息的对象的类名开头，省略类名的前缀并小写类第一个字符</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)tableView:(<span class="built_in">UITableView</span> *)tableView shouldSelectRow:(<span class="keyword">int</span>)row;</span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">NSApplication</span> *)sender openFile:(<span class="built_in">NSString</span> *)filename;</span><br></pre></td></tr></table></figure><ul><li>冒号紧跟在类名之后（随后的那个参数表示委派的对象）。该规则不适用于只有一个 sender 参数的方法</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)applicationOpenUntitledFile:(<span class="built_in">NSApplication</span> *)sender;</span><br></pre></td></tr></table></figure><ul><li>上面的那条规则也不适用于响应通知的方法。在这种情况下，方法的唯一参数表示通知对象</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)windowDidChangeScreen:(<span class="built_in">NSNotification</span> *)notification;</span><br></pre></td></tr></table></figure><ul><li>用于通知委托对象操作即将发生或已经发生的方法名中要使用 did 或 will</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)browserDidScroll:(<span class="built_in">NSBrowser</span> *)sender;</span><br><span class="line">- (<span class="built_in">NSUndoManager</span> *)windowWillReturnUndoManager:(<span class="built_in">NSWindow</span> *)window;</span><br></pre></td></tr></table></figure><ul><li>用于询问委托对象可否执行某操作的方法名中可使用 did 或 will，但最好使用 should</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)windowShouldClose:(<span class="keyword">id</span>)sender;</span><br></pre></td></tr></table></figure><p>####Collection Methods 集合方法</p><ul><li>管理对象（集合中的对象被称之为元素）的集合类，约定要具备如下形式的方法：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addElement:(elementType)adObj;</span><br><span class="line">- (<span class="keyword">void</span>)removeElement:(elementType)anObj;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)elements;</span><br></pre></td></tr></table></figure><p>例如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addLayoutManager:(<span class="built_in">NSLayoutManager</span> *)adObj;</span><br><span class="line">- (<span class="keyword">void</span>)removeLayoutManager:(<span class="built_in">NSLayoutManager</span> *)anObj;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)layoutManagers;</span><br></pre></td></tr></table></figure></p><p>集合方法命名有如下一些限制和约定：</p><ul><li>集合中的元素无序，返回 NSSet，而不是 NSArray</li><li>将元素插入指定位置的功能很重要，则需具备如下方法：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)insertElement:(elementType)anObj atIndex:(<span class="keyword">int</span>)index;</span><br><span class="line">- (<span class="keyword">void</span>)removeElementAtIndex:(<span class="keyword">int</span>)index;</span><br></pre></td></tr></table></figure><p>集合方法的实现要考虑如下细节：</p><ul><li>以上集合类方法通常负责管理元素的所有者关系，在 add 或 insert 的实现代码里会 retain 元素，在 remove 的实现代码中会 release 元素</li><li>当被插入的对象需要持有指向集合对象的指针时，通常使用 set… 来命名其设置该指针的方法，且不要 retain 集合对象。比如上面的 insertLayerManager:atIndex: 这种情形，NSLayoutManager 类使用如下方法：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSTextStorage</span> *)textStorage;</span><br><span class="line">- (<span class="keyword">void</span>) setTextStorage:(<span class="built_in">NSTextStorage</span> *)textStorage;</span><br></pre></td></tr></table></figure><p>通常你不会直接调用 setTextStorage:，而是覆写它。另一个关于集合约定的例子来自 NSWindow 类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addChildWindow:(<span class="built_in">NSWindow</span> *)childWin ordered:(<span class="built_in">NSWindowOrderingMode</span>)place;</span><br><span class="line">- (<span class="keyword">void</span>)removeChildWindow:(<span class="built_in">NSWindow</span> *)childWin;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)childWindows;</span><br><span class="line">- (<span class="built_in">NSWindow</span> *)parentWindow;</span><br><span class="line">- (<span class="keyword">void</span>)setParentWindow:(<span class="built_in">NSWindow</span> *)window;</span><br></pre></td></tr></table></figure></p><h4 id="Method-Arguments-方法参数"><a href="#Method-Arguments-方法参数" class="headerlink" title="Method Arguments 方法参数"></a>Method Arguments 方法参数</h4><p>命名方法参数时要考虑如下规则：</p><ul><li>如同方法名，参数名小写第一个单词的首字符，大写后继单词的首字符。如：removeObject:(id)anObject</li><li>不要在参数名中使用 pointer 或 ptr，让参数的类型来说明它是指针</li><li>避免使用 one， two，…，作为参数名</li><li>避免为节省几个字符而缩写<br>按照 Cocoa 惯例，以下关键字与参数联合使用：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...action:(SEL)aSelector</span><br><span class="line">...alignment:(<span class="keyword">int</span>)mode</span><br><span class="line">...atIndex:(<span class="keyword">int</span>)index</span><br><span class="line">...content:(<span class="built_in">NSRect</span>)aRect</span><br><span class="line">...doubleValue:(<span class="keyword">double</span>)aDouble</span><br><span class="line">...floatValue:(<span class="keyword">float</span>)aFloat</span><br><span class="line">...font:(<span class="built_in">NSFont</span> *)fontObj</span><br><span class="line">...frame:(<span class="built_in">NSRect</span>)frameRect</span><br><span class="line">...intValue:(<span class="keyword">int</span>)anInt</span><br><span class="line">...keyEquivalent:(<span class="built_in">NSString</span> *)charCode</span><br><span class="line">...length:(<span class="keyword">int</span>)numBytes</span><br><span class="line">...point:(<span class="built_in">NSPoint</span>)aPoint</span><br><span class="line">...stringValue:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">...tag:(<span class="keyword">int</span>)anInt</span><br><span class="line">...target:(<span class="keyword">id</span>)anObject</span><br><span class="line">...title:(<span class="built_in">NSString</span> *)aString</span><br></pre></td></tr></table></figure></li></ul><h4 id="rivate-Methods-私有方法"><a href="#rivate-Methods-私有方法" class="headerlink" title="rivate Methods 私有方法"></a>rivate Methods 私有方法</h4><p>大多数情况下，私有方法命名相同与公共方法命名约定相同，但通常我们约定给私有方法添加前缀，以便与公共方法区分开来。即使这样，私有方法的名称很容易导致特别的问题。当你设计一个继承自 Cocoa framework 某个类的子类时，你无法知道你的私有方法是否不小心覆盖了框架中基类的同名方法。<br>Cocoa framework 的私有方法名称通常以下划线作为前缀（如：_fooData），以标示其私有属性。基于这样的事实，遵循以下两条建议：</p><ul><li>不要使用下划线作为你自己的私有方法名称的前缀，Apple 保留这种用法。</li><li>若要继承 Cocoa framework 中一个超大的类（如：NSView），并且想要使你的私有方法名称与基类中的区别开来，你可以为你的私有方法名称添加你自己的前缀。这个前缀应该具有唯一性，如基于你公司的名称，或工程的名称，并以“XX_”形式给出。比如你的工程名为”Byte Flogger”，那么就可以是“BF_addObject:” 尽管为私有方法名称添加前缀的建议与前面类中方法命名的约定冲突，这里的意图有所不同：为了防止不小心地覆盖基类中的私有方法。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h4 id="一般变量"><a href="#一般变量" class="headerlink" title="一般变量"></a>一般变量</h4><p>变量使用驼峰命名法。命名时应使用完整的能表示变量作用的词语，禁止使用缩略词或者意义表示不明的词语。错误例子</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w;</span><br><span class="line"><span class="keyword">int</span> nerr;</span><br><span class="line"><span class="keyword">int</span> nCompConns;</span><br><span class="line">tix = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">obj = [someObject object];</span><br><span class="line">p = [network port];</span><br></pre></td></tr></table></figure><p>正确例子<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numErrors;</span><br><span class="line"><span class="keyword">int</span> numCompletedConnections;</span><br><span class="line">tickets = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">userInfo = [someObject object];</span><br><span class="line">port = [network port];</span><br></pre></td></tr></table></figure></p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>常量名称前统一加字母“k”，也可以是你认为可以表示为常量的字母，比如“c”<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNumberOfFiles = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> kUserKey = <span class="string">@"kUserKey"</span>;</span><br><span class="line"><span class="keyword">enum</span> DisplayTinge &#123; </span><br><span class="line">    kDisplayTingeGreen = <span class="number">1</span>, </span><br><span class="line">    kDisplayTingeBlue = <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="空格与格式"><a href="#空格与格式" class="headerlink" title="空格与格式"></a>空格与格式</h4><ul><li>方法的声明和定义在-号或者+号与返回值之间应留一个空格。而返回值与方法名以及方法名和参数列表之间都不应该有空格例如</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomethingWithString:(<span class="built_in">NSString</span> *)theString &#123; ...&#125;</span><br></pre></td></tr></table></figure><blockquote><p>推荐使用容器符号（[]以及{}）来表示数组和字典。容器符号与内容之间应使用空格分开<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>* array = @[ [foo description], <span class="string">@"Another String"</span>, [bar description] ];</span><br><span class="line"><span class="built_in">NSDictionary</span>* dict = @&#123; <span class="built_in">NSForegroundColorAttributeName</span> : [<span class="built_in">NSColor</span> redColor] &#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li><p>声明注释<br>每个类、category和protocol都需在注释中说明它的用途以及在整个框架中的作用</p></li><li><p>变量注释<br>尽可能详细地对关键变量进行注释，说明其作用</p></li><li>语句注释<br>在核心代码或者关键逻辑处必须进行注释，注释时不光要说明这段代码的作用，更要描述清楚为什么要这么做</li></ul><h3 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h3><ul><li><p>关键词和操作符之间加适当的空格。 [必须]<br>正确的示范：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">5</span>; <span class="comment">//注意 = 之间的空格</span></span><br><span class="line">错误的示范：</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>相对独立的程序块与块之间加空行。 [建议]</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">正确的示范：</span><br><span class="line"><span class="keyword">if</span>(retryCount &gt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">                            <span class="comment">//注意这里空一行</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//…do something</span></span><br><span class="line">&#125;</span><br><span class="line">          <span class="comment">//注意这里空一行</span></span><br><span class="line">错误的示范：</span><br><span class="line"><span class="keyword">int</span> nCount=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">if</span>(nRetryCount &gt; <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line"><span class="comment">//…do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法之间需要空一行。 [必须]</p></li><li><p>单行代码较长时、表达式等要分成多行书写,划分出的新行要进行适应的缩进，使排版整齐，语句可读。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正确的示范：</span><br><span class="line">    [_xyCameraMgr changePIPSourceRegion:willMoveSourceIndex</span><br><span class="line">                                 transX:transX/lastPIPZoomScale</span><br><span class="line">                                 transY:transY/lastPIPZoomScale];</span><br><span class="line">错误的示范：</span><br><span class="line">    [_xyCameraMgr changePIPSourceRegion:willMoveSourceIndex transX:transX/lastPIPZoomScale transY:transY/lastPIPZoomScale];</span><br></pre></td></tr></table></figure></li><li><p>长表达式要在低优先级操作符处划分新行，操作符放在新行之尾。 [建议]<br>【注：对于放在新行之首，还是之尾，有一个习惯的问题。每个团队需统一口径。】</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正确的示范：</span><br><span class="line"><span class="meta">#define IMG_UTIL_BSWAP_32(x) (unsigned int) ( \</span></span><br><span class="line">( ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(x)) &amp; <span class="number">0xff000000</span> )  | \</span><br><span class="line">(( ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(x)) &amp; <span class="number">0x00ff0000</span>) &gt;&gt; <span class="number">16</span>)  | \</span><br><span class="line">(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(x)) &amp; <span class="number">0x0000ff00</span> )  | \</span><br><span class="line">(( ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)(x)) &amp; <span class="number">0x000000ff</span>) &lt;&lt; <span class="number">16</span>)  \                                )</span><br></pre></td></tr></table></figure></li><li><p>循环、判断等语句中若有较长的表达式或语句，则要进行适应的划分。 </p></li><li>若函数或过程中的参数较长，则要进行适当的划分。 </li><li><p>不允许把多个短语句写在一行中，即一行只写一条语句。 [必须]</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正确的示范：</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">错误的示范：</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;<span class="keyword">int</span> j=<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数或过程的开始、结构的定义及循环、判断等语句中的代码都要采用缩进风格。  [建议]</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">正确的示范：</span><br><span class="line"><span class="keyword">if</span>(xxx)&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">错误的示范：</span><br><span class="line"><span class="keyword">if</span>(xxx)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h2><h3 id="UIKit-类实例变量命名规则"><a href="#UIKit-类实例变量命名规则" class="headerlink" title="UIKit 类实例变量命名规则"></a>UIKit 类实例变量命名规则</h3><p>UIXXX（标签名） *xx（自定义）+XXX（标签名）<br>例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">UILabel</span> *xxLabel;</span><br><span class="line"><span class="built_in">UIButton</span> *xxButton;</span><br><span class="line"><span class="built_in">UIImageView</span> *xxImageView;</span><br><span class="line"><span class="built_in">UIView</span> *xxView；</span><br><span class="line"><span class="built_in">UIViewController</span> *xxViewController；</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h3 id="Foundation-类实例变量"><a href="#Foundation-类实例变量" class="headerlink" title="Foundation 类实例变量"></a>Foundation 类实例变量</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSString</span>,<span class="built_in">NSMutableString</span> *xxStr</span><br><span class="line"><span class="built_in">NSArray</span>, <span class="built_in">NSMutableArray</span> 自描述items（templates）或者 itemArray</span><br><span class="line"><span class="built_in">NSDictionary</span>, <span class="built_in">NSMutableDictionary</span> *xxDict</span><br></pre></td></tr></table></figure><p>除了NSString，NSArray，NSDictionary 和它们的Mutable类之外都按照下面规则<br>NSXXX（标签名） *xx（自定义）+XXX（标签名）<br>例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSData</span> *xxData;</span><br><span class="line"><span class="built_in">NSBundle</span> *xxBundle;</span><br><span class="line"><span class="built_in">NSTimer</span> *xxTimer;</span><br><span class="line"><span class="built_in">NSURL</span> *xxURL；</span><br><span class="line"><span class="built_in">NSIndexSet</span> *xxIndexSet；</span><br><span class="line">\\ 容器</span><br><span class="line"><span class="built_in">NSSet</span>， <span class="built_in">NSMutableSet</span></span><br><span class="line"><span class="built_in">NSCache</span></span><br><span class="line"><span class="built_in">NSNumber</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>代码中使用语法糖，提高写代码效率</p><h3 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSArray的定义</span></span><br><span class="line"> <span class="built_in">NSArray</span> *array = @[<span class="string">@"lu"</span>, <span class="string">@"da"</span>, <span class="string">@"shi"</span>, @YES, @<span class="number">123</span>];</span><br><span class="line"> <span class="comment">//NSArray的访问</span></span><br><span class="line"> array[index];</span><br></pre></td></tr></table></figure><h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSDictionary的定义简化</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *dictionary = @&#123;</span><br><span class="line">                             <span class="string">@"key0"</span> : <span class="string">@"value0"</span>,</span><br><span class="line">                             <span class="string">@"key1"</span> : <span class="string">@"value1"</span>,</span><br><span class="line">                             <span class="string">@"key2"</span> : <span class="string">@"value2"</span></span><br><span class="line">                             &#125;;</span><br><span class="line"> <span class="comment">//NSDictionary访问数据简化</span></span><br><span class="line"> dictionary[<span class="string">@"key2"</span>];</span><br></pre></td></tr></table></figure><h3 id="NSNumber"><a href="#NSNumber" class="headerlink" title="NSNumber"></a>NSNumber</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *a = @<span class="number">123</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *b = @<span class="number">11.2</span>;</span><br><span class="line"><span class="built_in">NSNumber</span> *c = @(<span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><h3 id="枚举使用"><a href="#枚举使用" class="headerlink" title="枚举使用"></a>枚举使用</h3><p>当使用enum时，推荐使用新的固定基本类型规格，因为它有更强的类型检查和代码补全。现在SDK有一个宏NS_ENUM()来帮助和鼓励你使用固定的基本类型。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">例如:</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTLeftMenuTopItemType) &#123;</span><br><span class="line">  RWTLeftMenuTopItemMain,</span><br><span class="line">  RWTLeftMenuTopItemShows,</span><br><span class="line">  RWTLeftMenuTopItemSchedule</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">你也可以显式地赋值(展示旧的k-style常量定义)：</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, RWTGlobalConstants) &#123;</span><br><span class="line">  RWTPinSizeMin = <span class="number">1</span>,</span><br><span class="line">  RWTPinSizeMax = <span class="number">5</span>,</span><br><span class="line">  RWTPinCountMin = <span class="number">100</span>,</span><br><span class="line">  RWTPinCountMax = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">旧的k-style常量定义应该避免除非编写Core Foundation C的代码。</span><br><span class="line"></span><br><span class="line">不应该:</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> GlobalConstants &#123;</span><br><span class="line">  kMaxPinSize = <span class="number">5</span>,</span><br><span class="line">  kMaxPinCount = <span class="number">500</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br></pre></td></tr></table></figure><p>建议定义属性的时候把所有的属性特质写全,尤其是如果想定义成只读的(防止外面修改)那一定要加上readonly, 这也是代码安全性的一个习惯.</p><h4 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h4><p>私有属性应该在类的实现文件中的类扩展(匿名分类)中声明.<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RWTDetailViewController</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) GADBannerView *googleAdView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) ADBannerView *iAdView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIWebView</span> *adXWebView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><h3 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h3><p>Block使用时一定要注意循环引用的问题。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">dispatch_block_t block =  ^&#123;</span><br><span class="line">    [weakSelf doSomething]; <span class="comment">// weakSelf != nil</span></span><br><span class="line">    <span class="comment">// preemption, weakSelf turned nil</span></span><br><span class="line">    [weakSelf doSomethingElse]; <span class="comment">// weakSelf == nil</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>如此在上面定义一个weakSelf,然后在block体里面使用该weakSelf就可以避免循环引用的问题.很不幸，还是有问题。问题是block体里面的self是weak的,所以就有可能在某一个时段self已经被释放了, 这时block体里面再使用self那就是nil, 不难想象崩溃就在眼前。解决方法很简单, 就是在block体内define一个strong的self, 然后执行的时候判断下self是否还在, 如果在就继续执行下面的操作, 否则return或抛出异常.</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">myObj.myBlock =  ^&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf) &#123;</span><br><span class="line">      [strongSelf doSomething]; <span class="comment">// strongSelf != nil</span></span><br><span class="line">      <span class="comment">// preemption, strongSelf still not nil</span></span><br><span class="line">      [strongSelf doSomethingElse]; <span class="comment">// strongSelf != nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Probably nothing...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h3><p>在函数分组和protocol/delegate实现中使用#pragma mark -来分类方法，要遵循以下一般结构：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - Lifecycle</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - IBActions</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">IBAction</span>)submitData:(<span class="keyword">id</span>)sender &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Public</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)publicMethod &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Private</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)privateMethod &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Custom Accessors</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCustomProperty:(<span class="keyword">id</span>)value &#123;&#125;</span><br><span class="line">- (<span class="keyword">id</span>)customProperty &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Protocol conformance</span></span><br><span class="line"><span class="meta">#pragma mark - UITextFieldDelegate</span></span><br><span class="line"><span class="meta">#pragma mark - UITableViewDataSource</span></span><br><span class="line"><span class="meta">#pragma mark - UITableViewDelegate</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSCopying</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span> *)zone &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - NSObject</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)description &#123;&#125;</span><br></pre></td></tr></table></figure></p><h3 id="常量使用"><a href="#常量使用" class="headerlink" title="常量使用"></a>常量使用</h3><p>常量是容易重复被使用和无需通过查找和代替就能快速修改值。常量应该使用static来声明而不是使用#define，除非显式地使用宏。</p><p>应该:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> RWTAboutViewControllerCompanyName = <span class="string">@"RayWenderlich.com"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CGFloat</span> <span class="keyword">const</span> RWTImageThumbnailHeight = <span class="number">50.0</span>;</span><br></pre></td></tr></table></figure></p><p>不应该:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define CompanyName @<span class="meta-string">"RayWenderlich.com"</span></span></span><br><span class="line"><span class="meta">#define thumbnailHeight 2</span></span><br></pre></td></tr></table></figure></p><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>Objective-C使用YES和NO。因为true和false应该只在CoreFoundation，C或C++代码使用。既然nil解析成NO，所以没有必要在条件语句比较。不要拿某样东西直接与YES比较，因为YES被定义为1而一个BOOL能被设置为8位。</p><p>这是为了在不同文件保持一致性和在视觉上更加简洁而考虑。</p><p>应该:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (![anotherObject boolValue]) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>不应该:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (someObject == <span class="literal">nil</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> ([anotherObject boolValue] == <span class="literal">NO</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (isAwesome == <span class="literal">YES</span>) &#123;&#125; <span class="comment">// Never do this.</span></span><br><span class="line"><span class="keyword">if</span> (isAwesome == <span class="literal">true</span>) &#123;&#125; <span class="comment">// Never do this.</span></span><br></pre></td></tr></table></figure></p><p>如果BOOL属性的名字是一个形容词，属性就能忽略”is”前缀，但要指定get访问器的惯用名称。例如：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</span><br></pre></td></tr></table></figure><h3 id="在类的头文件中尽量少引入其他头文件"><a href="#在类的头文件中尽量少引入其他头文件" class="headerlink" title="在类的头文件中尽量少引入其他头文件"></a>在类的头文件中尽量少引入其他头文件</h3><p>通过向前引用 @class className; 解决编译问题。<br>在xxx.m 文件引人className 文件。这样可以加快编译速度。</p><h3 id="单例使用范例"><a href="#单例使用范例" class="headerlink" title="单例使用范例"></a>单例使用范例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">XY__Name__</span></span></span><br><span class="line"></span><br><span class="line">+(XY__Name__ *)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> XY__Name__ * sharedInstance;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line">    dispatch_ once(&amp;pred, ^&#123;</span><br><span class="line">        sharedInstance = [[XY__Name__ alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> == [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码建议"><a href="#编码建议" class="headerlink" title="编码建议"></a>编码建议</h2><ul><li>类变量若无特别需要尽量声明为@private</li><li>建议将所有NSObject的重载方法写在@implementation的顶端。例如init<br>、copyWithZone:以及dealloc</li><li>不需要把变量在init方法里初始化为0或者nil，这是多此一举</li><li>不要调用NSObject的new方法，也不要在子类中重载它。可以使用alloc和init方法来实例化对象</li><li>使用#import来引用OC头文件，使用#include来引用C/C++头文件</li><li>在init或者dealloc方法里不要使用.操作符来访问成员变量，因为在这些方法执行的过程中成员变量将处在不确定的状态</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init]; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123; </span><br><span class="line">        _bar = [[<span class="built_in">NSMutableString</span> alloc] init]; <span class="comment">// good </span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    _bar = <span class="literal">nil</span>; <span class="comment">// good </span></span><br><span class="line">    [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123; </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init]; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123; </span><br><span class="line">    <span class="keyword">self</span>.bar = [<span class="built_in">NSMutableString</span> string]; <span class="comment">// avoid</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123; </span><br><span class="line"><span class="keyword">self</span>.bar = <span class="literal">nil</span>; <span class="comment">// avoid </span></span><br><span class="line">[<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在dealloc中按照声明顺序来析构变量</li><li>所有的NSString变量都要使用copy关键字</li><li>判断BOOL值的时候不要直接把BOOL变量和YES进行比较。BOOL是由char封装而成，它可以表示的内容远远多于YES/NO或者1/0</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isGood;</span><br><span class="line"><span class="keyword">if</span> (isGood) &#123; <span class="comment">//正确 ...&#125;</span></span><br><span class="line"><span class="keyword">if</span> (isGood == <span class="literal">YES</span>) &#123; <span class="comment">//错误 ...&#125;</span></span><br></pre></td></tr></table></figure><ul><li>建议使用@property来声明变量。另外在ARC里不需要再写@ synthesize<br>了。也不需要再写一个跟property一样的带下划线的私有变量，ARC会自动生成一个下划线的变量的</li><li><p>使用@符号来定义一个NSNumber，这样更简单</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSNumber</span> *number1 = @<span class="number">1</span>; <span class="comment">//建议方式</span></span><br><span class="line"><span class="built_in">NSNumber</span> *number2 = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">2</span>]; <span class="comment">//过时的方式</span></span><br></pre></td></tr></table></figure></li><li><p>添加新文件时，注意放置的目录，不要把文件放到根目录下面。之前项目文件都在一个目录下，新的独立功能鼓励先建一个新的文件夹，再拖入Xcode中，所有相关的代码文件都放在该文件夹中。</p></li><li><p>不能引入warning。建议项目中开启Treat Warnings as Errors设置。</p><blockquote><p>但是目前该选项对Swift不起作用，未来苹果完善Swift之后，出现warning会导致编译通不过。<br>开发过程中注意Xcode控制台输出的警告信息，消除这些警告。目前来看AutoLayout相关的警告会比较多。</p></blockquote></li><li><p>基于UITableView写页面，基于BaseUITableViewController和RefreshTableViewController作为VC的基类，保证交互的一致性。UITableview构建UI好处如下：</p><blockquote><ul><li>1.UITableview是数据驱动的，根据内置的机制做展现。修改dataSource就可以控制界面的展现。刷新界面时只需要使用reloadData和reloadRowsAtIndexPaths就能完成。</li><li>2.页面扩展能力佳。未来业务发展，需要在页面最上面最下面增加内容，对之前代码做少量修改就能做到。</li><li>3.大量实现下拉刷新功能的开源项目，如果页面需要刷新功能，轻松做到。</li><li>4.UITableview具有强大的表现能力，再复杂的页面都可以完成。</li><li>5.UITableview使得交互更加统一，所有的页面，不管内容多少，都可以scroll和bounce，符合iOS的交互习惯。可以参看iOS自带的App的交互。</li><li>6.UITableView隐藏着很多高级特性（继承自UIScrollView），比如automaticallyAdjustsScrollViewInsets让内容可以滚动到导航栏和tabbar的后面，配合磨砂效果，视觉效果非常赞；比如点击状态栏会滚动到顶部；这些特性不需要开发就与生俱来。</li><li>7.iOS 8新增Self Sizing Cell，只需要设置rowHeight为UITableViewAutomaticDimension就可以实现cell高度根据约束自动调整（务必设置top和bottom与contentView的约束），cell高度计算和缓存已经成为历史往事。</li><li>8.滚动到页面指定的位置非常方便。并且通过保存UITableview的contentOffset，可以记住页面滚动的位置，当用户进入相同的页面，滚动到之前的位置。</li><li>9.对于拥有许多输入项的页面，将UITableView的keyboardDismissMode设置成interactive，轻松拥有MessageApp那样灵动的交互。</li></ul></blockquote></li><li><p>多用block替代delegate，比如UITableViewCell的点击操作，block比delegate代码更为简洁直观。</p></li><li>除了CRUD里面的CUD、下拉刷新和上拉翻页等，绝大部分接口都应该使用缓存，提高用户体验。</li><li>尽量使用枚举类型要标识状态，提高代码可读性和可维护性。Swift支持字符串作为枚举类型的值，使用根据方便。</li><li>使用registerClass:forCellReuseIdentifier:+dequeueReusableCellWithIdentifier:forIndexPath:<br>接口做cell复用。cell可以很多时，一定要坚持做cell复用，提高效率。</li><li>版本系统API时，通用功能不要引入高版本API。<br>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>编码规范，没有固定的版本，也没有明确的对错。但是对于完善的开发团队，明确的规范，可以为后期的代码维护，新人学习带来很多好处。还有就是规范，可以将开发维护过程中，前人犯过的错误，进行总结，写入内部编码规范内，起到避免重复犯错的作用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-编码规范整理&quot;&gt;&lt;a href=&quot;#iOS-编码规范整理&quot; class=&quot;headerlink&quot; title=&quot;iOS 编码规范整理&quot;&gt;&lt;/a&gt;iOS 编码规范整理&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文参考自&lt;br&gt;&lt;a href=&quot;https:/
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 保证线程同步方式 &amp; 性能对比</title>
    <link href="https://hongruqi.github.io/2016/07/23/iOS%20%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%20&amp;%20%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/"/>
    <id>https://hongruqi.github.io/2016/07/23/iOS 保证线程同步方式 &amp; 性能对比/</id>
    <published>2016-07-22T16:00:00.000Z</published>
    <updated>2019-02-22T07:56:59.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-保证线程同步方式-amp-性能对比"><a href="#iOS-保证线程同步方式-amp-性能对比" class="headerlink" title="iOS 保证线程同步方式 &amp; 性能对比"></a>iOS 保证线程同步方式 &amp; 性能对比</h1><p>##背景<br>IOS中保持线程同步的常用技术：</p><ul><li>@synchronized </li><li>NSLock</li><li>NSRecursiveLock</li><li>dispatch_semaphore</li><li>NSCondition</li><li>pthread_mutex</li><li>OSSpinLock。<br>他们的实现机制各不相同，性能也各不一样。而我们平时用的最多的@synchronized是性能最差的。<blockquote><p>本人开发时候，第一选择为NSRecursiveLock.</p></blockquote></li></ul><p>下面我们先分别介绍每个加锁方式的使用，在使用一个案例来对他们进行性能对比。</p><h2 id="介绍与使用"><a href="#介绍与使用" class="headerlink" title="介绍与使用"></a>介绍与使用</h2><p>###<strong>@synchronized</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(obj) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>);</span><br><span class="line">         sleep(<span class="number">3</span>); </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>);</span><br><span class="line">     &#125; </span><br><span class="line">  &#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    sleep(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">@synchronized</span>(obj) &#123; </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作2"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>@synchronized(obj)指令使用的obj为该锁的唯一标识，只有当标识相同时，才为满足互斥，如果线程2中的@synchronized(obj)改为@synchronized(self),刚线程2就不会被阻塞，@synchronized指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，但作为一种预防措施，@synchronized块会隐式的添加一个异常处理例程来保护代码，该处理例程会在异常抛出的时候自动的释放互斥锁。所以如果不想让隐式的异常处理例程带来额外的开销，你可以考虑使用锁对象。<br>上面结果的执行结果为：<br>2016-07-23 09:40:24.051 ThreadTest[13438:385647] 需要线程同步的操作1 开始<br>2016-07-23 09:40:27.054 ThreadTest[13438:385647] 需要线程同步的操作1 结束<br>2016-07-23 09:40:27.054 ThreadTest[13438:385646] 需要线程同步的操作2</p><p>##dispatch_semaphore<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dispatch_semaphore_t signal = dispatch_semaphore_create(<span class="number">1</span>); </span><br><span class="line">dispatch_time_t overTime = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">dispatch_semaphore_wait(signal, overTime); </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>); </span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>);</span><br><span class="line">        dispatch_semaphore_signal(signal); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">        dispatch_semaphore_wait(signal, overTime); </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作2"</span>); </span><br><span class="line">        dispatch_semaphore_signal(signal); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是dispatch_semaphore_create，dispatch_semaphore_signal，dispatch_semaphore_wait。</p><ol><li><strong>dispatch_semaphore_create的声明为：</strong><br>　　dispatch_semaphore_t  dispatch_semaphore_create(long value);<br>　　传入的参数为long，输出一个dispatch_semaphore_t类型且值为value的信号量。<br>　　值得注意的是，这里的传入的参数value必须大于或等于0，否则dispatch_semaphore_create会返回NULL。</li><li><strong>dispatch_semaphore_signal的声明为：</strong><br>　　long dispatch_semaphore_signal(dispatch_semaphore_t dsema)<br>　　这个函数会使传入的信号量dsema的值加1；</li><li><strong>dispatch_semaphore_wait的声明为：</strong><br>　　long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)；<br>　　这个函数会使传入的信号量dsema的值减1；这个函数的作用是这样的，如果dsema信号量的值大于0，该函数所处线程就继续执行下面的语句，并且将信号量的值减1；如果desema的值为0，那么这个函数就阻塞当前线程等待timeout（注意timeout的类型为dispatch_time_t，不能直接传入整形或float型数），如果等待的期间desema的值被dispatch_semaphore_signal函数加1了，且该函数（即dispatch_semaphore_wait）所处线程获得了信号量，那么就继续向下执行并将信号量减1。如果等待期间没有获取到信号量或者信号量的值一直为0，那么等到timeout时，其所处线程自动执行其后语句。<br>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。<br>如上的代码，如果超时时间overTime设置成&gt;2，可完成同步操作。如果overTime&lt;2的话，在线程1还没有执行完成的情况下，此时超时了，将自动执行下面的代码。<br>上面代码的执行结果为：<br>2016-07-23 09:53:00.898 ThreadTest[13507:391586]  需要线程同步的操作 1  开始<br>2016-07-23 09:53:02.903 ThreadTest[13507:391586]  需要线程同步的操作 1  结束<br>2016-07-23 09:53:02.904 ThreadTest[13507:391578]  需要线程同步的操作 2<br>如果把超时时间设置为&lt;2s的时候，执行的结果就是：<br>2016-07-23 09:54:04.499 ThreadTest[13518:392236]  需要线程同步的操作 1 开始<br>2016-07-23 09:54:06.002 ThreadTest[13518:392247]  需要线程同步的操作 2<br>2016-07-23 09:54:06.505 ThreadTest[13518:392236]  需要线程同步的操作 1 结束</li></ol><p>##NSLock<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="comment">//[lock lock]; </span></span><br><span class="line">    [lock lockBeforeDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>); </span><br><span class="line">    sleep(<span class="number">2</span>); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>); </span><br><span class="line">    [lock unlock];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ([lock tryLock]) &#123;</span><br><span class="line">        <span class="comment">//尝试获取锁，如果获取不到返回NO，不会阻塞该线程 </span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"锁可用的操作"</span>); </span><br><span class="line">        [lock unlock]; </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"锁不可用的操作"</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDate</span> *date = [[<span class="built_in">NSDate</span> alloc] initWithTimeIntervalSinceNow:<span class="number">3</span>]; </span><br><span class="line">    <span class="keyword">if</span> ([lock lockBeforeDate:date]) &#123;</span><br><span class="line">          <span class="comment">//尝试在未来的3s内获取锁，并阻塞该线程，如果3s内获取不到恢复线程, 返回NO,不会阻塞该线程</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"没有超时，获得锁"</span>); </span><br><span class="line">          [lock unlock]; </span><br><span class="line">     &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@"超时，没有获得锁"</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>NSLock是Cocoa提供给我们最基本的锁对象，这也是我们经常所使用的，除lock和unlock方法外，NSLock还提供了tryLock和lockBeforeDate:两个方法，前一个方法会尝试加锁，如果锁不可用(已经被锁住)，刚并不会阻塞线程，并返回NO。lockBeforeDate:方法会在所指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO。<br>上面代码的执行结果为：<br> 2016-07-23 10:01:06.165 ThreadTest[13541:394814]  需要线程同步的操作 1  开始<br> 2016-07-23 10:01:07.169 ThreadTest[13541:394804]  锁不可用的操作<br> 2016-07-23 10:01:08.168 ThreadTest[13541:394814]  需要线程同步的操作 1  结束<br> 2016-07-23 10:01:08.168 ThreadTest[13541:394804]  没有超时，获得锁<br>源码定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSLocking</span></span></span><br><span class="line">- (<span class="keyword">void</span>)lock;</span><br><span class="line">- (<span class="keyword">void</span>)unlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">@private</span> <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>##<strong>NSRecursiveLock递归锁</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NSLock *lock = [[NSLock alloc] init];</span></span><br><span class="line"><span class="built_in">NSRecursiveLock</span> *lock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> (^RecursiveMethod)(<span class="keyword">int</span>); </span><br><span class="line">    RecursiveMethod = ^(<span class="keyword">int</span> value) &#123; </span><br><span class="line">        [lock lock]; </span><br><span class="line">        <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"value = %d"</span>, value); </span><br><span class="line">            sleep(<span class="number">1</span>); </span><br><span class="line">            RecursiveMethod(value - <span class="number">1</span>); </span><br><span class="line">      &#125; </span><br><span class="line">        [lock unlock]; </span><br><span class="line">    &#125;;</span><br><span class="line">     RecursiveMethod(<span class="number">5</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这段代码是一个典型的死锁情况。在我们的线程中，RecursiveMethod是递归调用的。如果使用NSLock，每次进入这个block时，都会去加一次锁，而从第二次开始，由于锁已经被使用了且没有解锁，所以它需要等待锁被解除，这样就导致了死锁，线程被阻塞住了。调试器中会输出如下信息：<br>2016-07-23 10:09:50.932 ThreadTest[13568:398209] value = 5<br>2016-07-23 10:09:51.933 ThreadTest[13568:398209]  -[NSLock lock]: deadlock (&lt;NSLock: 0x7ff58a60b190&gt; ‘(null)’)<br>2016-07-23 10:09:51.934 ThreadTest[13568:398209]   Break on _NSLockError() to debug.<br>在这种情况下，我们就可以使用NSRecursiveLock。它可以允许同一线程多次加锁，而不会造成死锁。递归锁会跟踪它被lock的次数。每次成功的lock都必须平衡调用unlock操作。只有所有达到这种平衡，锁最后才能被释放，以供其它线程使用。<br>如果我们将NSLock代替为NSRecursiveLock，上面代码则会正确执行。<br> 2016-07-23 10:13:08.465 ThreadTest[13593:400360] value = 5<br> 2016-07-23 10:13:09.468 ThreadTest[13593:400360] value = 4<br> 2016-07-23 10:13:10.472 ThreadTest[13593:400360] value = 3<br> 2016-07-23 10:13:11.474 ThreadTest[13593:400360] value = 2<br> 2016-07-23 10:13:12.478 ThreadTest[13593:400360] value = 1<br>如果需要其他功能，源码定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSRecursiveLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">@private</span> </span><br><span class="line">    <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>##<strong>NSConditionLock条件锁</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSConditionLock</span> *lock = [[<span class="built_in">NSConditionLock</span> alloc] init];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *products = [<span class="built_in">NSMutableArray</span> array]; </span><br><span class="line"><span class="built_in">NSInteger</span> HAS_DATA = <span class="number">1</span>; </span><br><span class="line"><span class="built_in">NSInteger</span> NO_DATA = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">        [lock lockWhenCondition:NO_DATA]; </span><br><span class="line">        [products addObject:[[<span class="built_in">NSObject</span> alloc] init]]; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"produce a product,总量:%zi"</span>,products.count); </span><br><span class="line">        [lock unlockWithCondition:HAS_DATA]; </span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">   &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"wait for product"</span>); </span><br><span class="line">         [lock lockWhenCondition:HAS_DATA]; </span><br><span class="line">         [products removeObjectAtIndex:<span class="number">0</span>]; </span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"custome a product"</span>); </span><br><span class="line">         [lock unlockWithCondition:NO_DATA]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>当我们在使用多线程的时候，有时一把只会lock和unlock的锁未必就能完全满足我们的使用。因为普通的锁只能关心锁与不锁，而不在乎用什么钥匙才能开锁，而我们在处理资源共享的时候，多数情况是只有满足一定条件的情况下才能打开这把锁：<br>在线程1中的加锁使用了lock，所以是不需要条件的，所以顺利的就锁住了，但在unlock的使用了一个整型的条件，它可以开启其它线程中正在等待这把钥匙的临界地，而线程2则需要一把被标识为2的钥匙，所以当线程1循环到最后一次的时候，才最终打开了线程2中的阻塞。但即便如此，NSConditionLock也跟其它的锁一样，是需要lock与unlock对应的，只是lock,lockWhenCondition:与unlock，unlockWithCondition:是可以随意组合的，当然这是与你的需求相关的。<br>上面代码执行结果如下：<br>2016-07-23 10:30:00.764 ThreadTest[13645:406942] wait for product<br>2016-07-23 10:30:00.764 ThreadTest[13645:406951] produce a product,  总量 :1<br>2016-07-23 10:30:00.765 ThreadTest[13645:406942] custome a product<br>2016-07-23 10:30:00.765 ThreadTest[13645:406942] wait for product<br>2016-07-23 10:30:01.767 ThreadTest[13645:406951] produce a product, 总量:1<br>2016-07-23 10:30:01.767 ThreadTest[13645:406942] custome a product<br>如果你需要其他功能，源码定义如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSConditionLock</span> : <span class="title">NSObject</span> &lt;<span class="title">NSLocking</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">@private</span> </span><br><span class="line">    <span class="keyword">void</span> *_priv;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithCondition:(<span class="built_in">NSInteger</span>)condition <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> condition;</span><br><span class="line">- (<span class="keyword">void</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLock;</span><br><span class="line">- (<span class="built_in">BOOL</span>)tryLockWhenCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="keyword">void</span>)unlockWithCondition:(<span class="built_in">NSInteger</span>)condition;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockBeforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line">- (<span class="built_in">BOOL</span>)lockWhenCondition:(<span class="built_in">NSInteger</span>)condition beforeDate:(<span class="built_in">NSDate</span> *)limit;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>##<strong>NSCondition</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">NSCondition</span> *condition = [[<span class="built_in">NSCondition</span> alloc] init]; </span><br><span class="line"><span class="built_in">NSMutableArray</span> *products = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">        [condition lock]; </span><br><span class="line">        <span class="keyword">if</span> ([products count] == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"wait for product"</span>); </span><br><span class="line">           [condition wait]; </span><br><span class="line">       &#125;</span><br><span class="line">      [products removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"custome a product"</span>); </span><br><span class="line">      [condition unlock]; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">         [condition lock]; </span><br><span class="line">        [products addObject:[[<span class="built_in">NSObject</span> alloc] init]]; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"produce a product,总量:%zi"</span>,products.count); </span><br><span class="line">        [condition signal]; </span><br><span class="line">        [condition unlock]; </span><br><span class="line">        sleep(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>一种最基本的条件锁。手动控制线程wait和signal。<br>[condition lock];一般用于多线程同时访问、修改同一个数据源，保证在同一时间内数据源只被访问、修改一次，其他线程的命令需要在lock 外等待，只到unlock ，才可访问[condition unlock];与lock 同时使用[condition wait];让当前线程处于等待状态[condition signal];CPU发信号告诉线程不用在等待，可以继续执行。<br>上面代码执行结果如下：<br>2016-07-23 10:37:46.943 ThreadTest[13693:409659] wait for product<br>2016-07-23 10:37:46.944 ThreadTest[13693:409667] produce a product, 总量 :1<br>2016-07-23 10:37:46.944 ThreadTest[13693:409659] custome a product<br>2016-07-23 10:37:46.945 ThreadTest[13693:409659] wait for product<br>2016-07-23 10:37:47.947 ThreadTest[13693:409667] produce a product, 总量 :1<br>2016-07-23 10:37:47.947 ThreadTest[13693:409659] custome a product</p><p>##<strong>pthread_mutex</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__block pthread_mutex_t theLock; </span><br><span class="line">pthread_mutex_init(&amp;theLock, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    pthread_mutex_lock(&amp;theLock); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>); </span><br><span class="line">    sleep(<span class="number">3</span>); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>); </span><br><span class="line">    pthread_mutex_unlock(&amp;theLock); </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    sleep(<span class="number">1</span>); </span><br><span class="line">    pthread_mutex_lock(&amp;theLock); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作2"</span>); </span><br><span class="line">    pthread_mutex_unlock(&amp;theLock); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>c语言定义下多线程加锁方式。</p><ol><li>pthread_mutex_init(<strong>pthread_mutex_t</strong> <em> mutex,const pthread_mutexattr_t </em>attr);初始化锁变量mutex。attr为锁属性，NULL值为默认属性。</li><li>pthread_mutex_lock(<strong>pthread_mutex_t</strong> *mutex);加锁</li><li>pthread_mutex_tylock(<strong>pthread_mutex_t</strong> *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。</li><li>pthread_mutex_unlock(<strong>pthread_mutex_t</strong> *mutex);释放锁</li><li>pthread_mutex_destroy(<strong>pthread_mutex_t</strong> *mutex);使用完后释放</li></ol><p>代码执行操作结果如下：<br>2016-07-23 10:45:05.864 ThreadTest[13725:412938]  需要线程同步的操作 1  开始<br>2016-07-23 10:45:08.867 ThreadTest[13725:412938]  需要线程同步的操作 1  结束<br>2016-07-23 10:45:08.867 ThreadTest[13725:412931]  需要线程同步的操作 2</p><h2 id="pthread-mutex-recursive"><a href="#pthread-mutex-recursive" class="headerlink" title="pthread_mutex(recursive)"></a><strong>pthread_mutex(recursive)</strong></h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">__block pthread_mutex_t theLock; </span><br><span class="line"><span class="comment">//pthread_mutex_init(&amp;theLock, NULL);</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr); </span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE); </span><br><span class="line">pthread_mutex_init(&amp;theLock, &amp;attr); </span><br><span class="line">pthread_mutexattr_destroy(&amp;attr); </span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> (^RecursiveMethod)(<span class="keyword">int</span>); </span><br><span class="line">    RecursiveMethod = ^(<span class="keyword">int</span> value) &#123; </span><br><span class="line">         pthread_mutex_lock(&amp;theLock); </span><br><span class="line">         <span class="keyword">if</span> (value &gt; <span class="number">0</span>) &#123; </span><br><span class="line">             <span class="built_in">NSLog</span>(<span class="string">@"value = %d"</span>, value); </span><br><span class="line">             sleep(<span class="number">1</span>); </span><br><span class="line">             RecursiveMethod(value - <span class="number">1</span>); </span><br><span class="line">     &#125;</span><br><span class="line">      pthread_mutex_unlock(&amp;theLock); </span><br><span class="line">   &#125;;</span><br><span class="line">      RecursiveMethod(<span class="number">5</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是pthread_mutex为了防止在递归的情况下出现死锁而出现的递归锁。作用和NSRecursiveLock递归锁类似。<br>如果使用pthread_mutex_init(&amp;theLock, NULL);初始化锁的话，上面的代码会出现死锁现象。如果使用递归锁的形式，则没有问题。</p><p>##OSSpinLock<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__block OSSpinLock theLock = OS_SPINLOCK_INIT;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    OSSpinLockLock(&amp;theLock); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 开始"</span>); </span><br><span class="line">    sleep(<span class="number">3</span>); </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作1 结束"</span>);</span><br><span class="line">    OSSpinLockUnlock(&amp;theLock);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">     OSSpinLockLock(&amp;theLock); </span><br><span class="line">     sleep(<span class="number">1</span>); </span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"需要线程同步的操作2"</span>); </span><br><span class="line">     OSSpinLockUnlock(&amp;theLock);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>OSSpinLock 自旋锁，性能最高的锁。原理很简单，就是一直 do while 忙等。它的缺点是当等待时会消耗大量 CPU 资源，所以它不适用于较长时间的任务。 不过最近YY大神在自己的博客<a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a>中说明了OSSpinLock已经不再安全，请大家谨慎使用。</p><p>#性能对比<br>对以上各个锁进行1000000次的加锁解锁的空操作时间如下：</p><table><thead><tr><th>方法</th><th>1000000消耗时间</th></tr></thead><tbody><tr><td>OSSpinLock</td><td>46.15 ms</td></tr><tr><td>dispatch_semaphore</td><td>56.50 ms</td></tr><tr><td>pthread_mutex</td><td>178.28 ms</td></tr><tr><td>NSCondition</td><td>193.38 ms</td></tr><tr><td>NSLock</td><td>175.02 ms</td></tr><tr><td>pthread_mutex(recursive):</td><td>172.56 ms</td></tr><tr><td>NSRecursiveLock</td><td>157.44 ms</td></tr><tr><td>NSConditionLock:</td><td>490.04 ms</td></tr><tr><td>@synchronized</td><td>371.17 ms</td></tr></tbody></table><p>总的来说：<br>OSSpinLock和dispatch_semaphore的效率远远高于其他。<br>@synchronized和NSConditionLock效率较差。<br>鉴于OSSpinLock的不安全，所以我们在开发中如果考虑性能的话，建议使用dispatch_semaphore。<br>如果不考虑性能，只是图个方便的话，那就使用@synchronized。<br>使用NSRecursiveLock，可以避免死锁，同时性能也不错，建议代码中使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-保证线程同步方式-amp-性能对比&quot;&gt;&lt;a href=&quot;#iOS-保证线程同步方式-amp-性能对比&quot; class=&quot;headerlink&quot; title=&quot;iOS 保证线程同步方式 &amp;amp; 性能对比&quot;&gt;&lt;/a&gt;iOS 保证线程同步方式 &amp;amp; 性能
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 手势详解</title>
    <link href="https://hongruqi.github.io/2016/07/22/iOS%20%E6%89%8B%E5%8A%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hongruqi.github.io/2016/07/22/iOS 手势详解/</id>
    <published>2016-07-21T16:00:00.000Z</published>
    <updated>2019-02-22T07:55:46.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-手势详解"><a href="#iOS-手势详解" class="headerlink" title="iOS 手势详解"></a>iOS 手势详解</h1><h2 id="手势识别"><a href="#手势识别" class="headerlink" title="##手势识别"></a>##手势识别</h2><p>手势识别器将抽像度低的事件操作转化为更容易理解的动作，它们是附加在视图上的对象，并允许对这些动作进行回应。手势识别器解释这些触摸事件是否是一个特定的手势，比如轻扫，缩放，旋转。如果它们能正确识别，它们会发送一个动作给目标对象。这个对象是你指定的视图控制器，如下图所示。这样的设计模式强大简单，你可以动态指定响应动作，而且你可以添加一个手势识别给一个视图，而不用子类化视图。<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gestureRecognizer_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gestureRecognizer_2x.png" alt="一个附加在视图上的手势识别"></a></p><p>##使用手势识别简化事件操作<br>UIKit 框架提供了预先定义的一些常用手势定义。它提供的预定义手势，大大简化了你自己去写识别代码,而且用标准的识别可以确保你的APP可以正确识别用户所期望的内容。<br>如果你想自己定义一个不一样的手势，比如对勾或圈圈，你可以创建属于你自己的手势识别。如果设计和实现这些专属的手势识别，可以看这里 <a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/GestureRecognizer_basics/GestureRecognizer_basics.html#//apple_ref/doc/uid/TP40009541-CH2-SW44" target="_blank" rel="noopener">创建一个定制的手势识别</a><br>内嵌的常用手势识别<br>下表是UIKit 框架自带的手势类别</p><table><thead><tr><th>手势</th><th>UIKit class</th></tr></thead><tbody><tr><td>点击 (Tapping (any number of taps))</td><td>UITapGestureRecognizer</td></tr><tr><td>捏合 (Pinching in and out (for zooming a view))</td><td>UIPinchGestureRecognizer</td></tr><tr><td>滑动或拖动 (Panning or dragging)</td><td>UIPanGestureRecognizer</td></tr><tr><td>轻扫 (Swiping (in any direction))</td><td>UISwipeGestureRecognizer</td></tr><tr><td>旋转 (Rotating (fingers moving in opposite directions))</td><td>UIRotationGestureRecognizer</td></tr><tr><td>长按 (Long press (also known as “touch and hold”))</td><td>UILongPressGestureRecognizer</td></tr></tbody></table><p>你必须遵循苹果的规范去正确响应用户的手势操作 , 见 <a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/MobileHIG/index.html#//apple_ref/doc/uid/TP40006556" target="_blank" rel="noopener">iOS Human Interface Guidelines</a></p><p>##手势附加在一个视图上<br>任何手势都和一个视图相关联，不过，一个视图可以有多个手势，因为一个视图可能会响应多个不同的手势。为了一个视图能识别特殊的手势，你必须附加手势识别到这个视图上。当用户触摸这个视图时，手势识别会在视图动作前收到触摸的消息，然后手势可以应答这个消息。</p><ul><li>手势触发动作信息<br>当手势识别器识别它特定的手势，它会发送一个动作消息给它的对象。要创建一个手势识别，我要实例化它并附加一个对象和动作</li><li>离散和连续的手势<br>手势是离散或者连续的。一个离散的手势，比如轻击，只发生一次。一个连续的手势，比如捏合，是在一段时间内发生。对于离散的手势，手势识别器只发送一个单一的动作消息给对象。而一个连续的手势会持续的发送动作消息给它的对象直到多点触摸结束，正如下图所示：<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/discrete_vs_continuous_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/discrete_vs_continuous_2x.png" alt="离散和连续的手势"></a></li></ul><p>##响应手势识别事件<br>要添加一个手势给你的APP有三件事情是你要去做的<br>创建和配置一个手势识别实例 这一步包括附值一个目标对象，动作，有时还会要指定特定的手势属性(比如 numberOfTapsRequired)<br>附加这个手势识别器给视图<br>实现响应这个动作的方法</p><p>使用 Interface Builder 附加手势<br>PS: 用的不多，大家有空自己看苹果官方文档吧</p><p>编码方式添加手势识别<br>你可以通过allocating 和 initializing 来实例化 UIGestureRecognizer 的子类，比如UIPinchGestureRecognizer.<br>如果你创建这个实例化对象后，你需要通过 addGestureRecognizer: 方法附加给一个 View. 下面是一个示例</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">    <span class="comment">// Create and initialize a tap gesture </span></span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *tapRecognizer =</span><br><span class="line">    [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(respondToTapGesture:)];</span><br><span class="line">    <span class="comment">// Specify that the gesture must be a single tap</span></span><br><span class="line">    tapRecognizer.numberOfTapsRequired = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Add the tap gesture recognizer to the view </span></span><br><span class="line">    [<span class="keyword">self</span>.view addGestureRecognizer:tapRecognizer];</span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##响应离散的手势<br>当你创建了手势识别并添加了 action 方法后，你就可以用此方法去响应手势操作。下面的代码是一个响应视图点击并通过 locationInView: 方法定位显示图片的例子<br>原码在这里: <a href="https://developer.apple.com/library/ios/samplecode/SimpleGestureRecognizers/Introduction/Intro.html#//apple_ref/doc/uid/DTS40009460" target="_blank" rel="noopener">Simple Gesture Recognizers</a></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)showGestureForTapRecognizer:(<span class="built_in">UITapGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">     <span class="comment">// Get the location of the gesture </span></span><br><span class="line">    <span class="built_in">CGPoint</span> location = [recognizer locationInView:<span class="keyword">self</span>.view]; </span><br><span class="line">    <span class="comment">// Display an image view at that location </span></span><br><span class="line">    [<span class="keyword">self</span> drawImageForGestureRecognizer:recognizer atPoint:location];</span><br><span class="line">    <span class="comment">// Animate the image view so that it fades out</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">        <span class="keyword">self</span>.imageView.alpha = <span class="number">0.0</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个手势都有它特定的一些属性，比如下面的例子， showGestureForSwipeRecognizer: 方法使用 swipe 手势识别的 direction属性来判断用户滑动的方向是左还是右。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Respond to a swipe gesture</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)showGestureForSwipeRecognizer:(<span class="built_in">UISwipeGestureRecognizer</span> *)recognizer &#123; </span><br><span class="line">    <span class="comment">// Get the location of the gesture </span></span><br><span class="line">    <span class="built_in">CGPoint</span> location = [recognizer locationInView:<span class="keyword">self</span>.view]; </span><br><span class="line">    <span class="comment">// Display an image view at that location </span></span><br><span class="line">    [<span class="keyword">self</span> drawImageForGestureRecognizer:recognizer atPoint:location]; </span><br><span class="line">    <span class="comment">// If gesture is a left swipe, specify an end location </span></span><br><span class="line">   <span class="comment">// to the left of the current location </span></span><br><span class="line">   <span class="keyword">if</span> (recognizer.direction == <span class="built_in">UISwipeGestureRecognizerDirectionLeft</span>) &#123;</span><br><span class="line">      location.x -= <span class="number">220.0</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      location.x += <span class="number">220.0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Animate the image view in the direction of the swipe as it fades out</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">         <span class="keyword">self</span>.imageView.alpha = <span class="number">0.0</span>; </span><br><span class="line">         <span class="keyword">self</span>.imageView.center = location; </span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##响应一个连续的手势<br>连续手势允许你的app响应手势正在发生的过程，例如，你可以在用户捏合时放大或缩小，或允许用户在屏幕在拖动对象<br>下面的例子显示当用户旋转手势时，将显示一个旋转后的图片。当用户手势放开时，将淡出并将图片回到水平方向。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Respond to a rotation gesture</span></span><br><span class="line">- (<span class="keyword">IBAction</span>)showGestureForRotationRecognizer:(<span class="built_in">UIRotationGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">    <span class="comment">// Get the location of the gesture </span></span><br><span class="line">    <span class="built_in">CGPoint</span> location = [recognizer locationInView:<span class="keyword">self</span>.view]; </span><br><span class="line">    <span class="comment">// Set the rotation angle of the image view to </span></span><br><span class="line">    <span class="comment">// match the rotation of the gesture </span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> transform =</span><br><span class="line">    <span class="built_in">CGAffineTransformMakeRotation</span>([recognizer rotation]);</span><br><span class="line">    <span class="keyword">self</span>.imageView.transform = transform;</span><br><span class="line">    <span class="comment">// Display an image view at that location </span></span><br><span class="line">    [<span class="keyword">self</span> drawImageForGestureRecognizer:recognizer atPoint:location];</span><br><span class="line">    <span class="comment">// If the gesture has ended or is canceled, begin the animation </span></span><br><span class="line">    <span class="comment">// back to horizontal and fade out </span></span><br><span class="line">    <span class="keyword">if</span> (([recognizer state] == <span class="built_in">UIGestureRecognizerStateEnded</span>||</span><br><span class="line">        ([recognizer state] == <span class="built_in">UIGestureRecognizerStateCancelled</span>)) &#123;</span><br><span class="line">         [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span> animations:^&#123;</span><br><span class="line">               <span class="keyword">self</span>.imageView.alpha = <span class="number">0.0</span>; </span><br><span class="line">               <span class="keyword">self</span>.imageView.transform = <span class="built_in">CGAffineTransformIdentity</span>; </span><br><span class="line">        &#125;];</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每次方法调用，在 drawImageForGestureRecognizer: 方法里都会被设置为不透明。当用户手势完成时，图片又会在 animateWithDuration: 方法里设置为透明。这个 showGestureForRotationRecognizer: 方法会持续检测手势状态。关于这个状态解释可以查看下面的 “手势状态机”。<br>如何定义手势识别交互转换<br>常常当你添加手势识别到你的app 后，如果你想要在与其它触摸事件之间做特定的交互时，你首先要理解一下更多关于手势识别工作的细节。<br>有限状态机中的手势识别<br>下图中，所有的手势开始于 Possible 状态 (UIGestureRecognizerStatePossible)，它们分析收到的多次触摸序列，然后决定转化为 fail 状态或其它状态.<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gr_state_transitions_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/gr_state_transitions_2x.png" alt="手势识别状态机"></a><br>当一个离散的手势识别器识别它是这样的手势后，它会将它的状态从 Possible 变为 Recognized (UIGestureRecognizerStateRecognized) ，然后识别完成。<br>对于连续的手势第一次识别时，将状态从 Possible 变为 Began (UIGestureRecognizerStateBegan). 然后，它再将状态从 Began 变为 Changed (UIGestureRecognizerStateChanged), 然后在手势发生时持续的将状态从 Changed 变为 Changed。直到用户的手指从视图离开，手势状态转变为 Ended (UIGestureRecognizerStateEnded)，然后手势识别完成.<br>如果你不想长时间适配手势，也只可以将一个连续的手势也可以从 Changed 变为 Canceled (UIGestureRecognizerStateCancelled)。<br>所有的时候，每次手势状态的改变，手势识别器都会发送一个 action message 给它的目标，除非它的状态是 Failed 或 Canceled.所以一个离散的手势，当从 Possible 到 Recognized 时 只发送一次 action message . 而一个连续的手势在状态变化时会发送很多 action message。<br>当手势识别状态变为 Recognized (或 Ended)状态时，它会重置经的状态为 Possible. 这个转化不会触发 action message.<br>和其它手势交互<br>一个视图可以有多个手势识别附加给它，你可以使用视图的 gestureRecognizers 属性来看有多少手势识别器，你也可以动态的添加或删除手势识别器，通过 addGestureRecognizer: 和 removeGestureRecognizer: 方法。<br>当一个视图有多个手势识别附加给它时，你可能想去解决他们产生的识别冲突。默认的情况下接收到触摸后，它们是没办法设定定顺序的，不过你可以覆盖这些默认的行为:<br>指定一个手势在识别时应该分析其它的手势识别<br>允许两个手势识别同时操作<br>通过触摸分析避免手势识别</p><p>使用 UIGestureRecognizer 类方法，delegate methods 或 子类化覆盖方法来达到这样的效果<br>声明指定两个手势的识别顺序<br>想象一下你想识别两种手势 swipe 与 pan 。你想区别这两种手势所触发的 action. 默认情况时，你的 swipe 手势会被识别为 pan . 这是因为它的手势必要条件被解释为了 pan 手势。<br>所以你可以显示的指明它们之间的关系，通过调用 requireGestureRecognizerToFail: 方法如下面所示<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123; </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">    <span class="comment">// Do any additional setup after loading the view, typically from a nib</span></span><br><span class="line">    [<span class="keyword">self</span>.panRecognizer requireGestureRecognizerToFail:</span><br><span class="line">    <span class="keyword">self</span>.swipeRecognizer];&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法指明只有其它的手势失败时才会让它自己开始识别。<br>注意如果你有单击与双击手势识别时，不能设定单击需要在双击失败时进行，因为这不符合苹果设计规范，也许用户就只是想单击而已</p><p>##通过分析触摸来避免手势识别<br>你可以修改手势行为，通过添加一个 delegate 对象去体质手势识别。这个 UIGestureRecognizerDelegate 协议支持多种办法分析触摸避免识别。你可以识别 gestureRecognizer:shouldReceiveTouch: 方法或 gestureRecognizerShouldBegin: 方法，这两个方法都是 UIGestureRecognizerDelegate 协议里可选的<br>当手势触摸开始，如果你想立即决定是否识别本次触摸，使用 gestureRecognizer:shouldReceiveTouch: 方法，这个方法每次触摸都发被调用。返回 NO 避免识别，返回 YES 不会修改手势识别状态。<br>下面的例子使用 gestureRecognizer:shouldReceiveTouch: 代理方法避免收到触摸手势在定制的 subview 后识别<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">    <span class="comment">// Add the delegate to the tap gesture recognizer</span></span><br><span class="line">    <span class="keyword">self</span>.tapGestureRecognizer.delegate = <span class="keyword">self</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// Implement the UIGestureRecognizerDelegate method</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer</span><br><span class="line">       shouldReceiveTouch:(<span class="built_in">UITouch</span> *)touch &#123; </span><br><span class="line">     <span class="comment">// Determine if the touch is inside the custom subview</span></span><br><span class="line">     <span class="keyword">if</span> ([touch view] == <span class="keyword">self</span>.customSubview)&#123; </span><br><span class="line">     <span class="comment">// If it is, prevent all of the delegate's gesture recognizers</span></span><br><span class="line">     <span class="comment">// from receiving the touch </span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">NO</span>; </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>gestureRecognizer:shouldReceiveTouch: 与 gestureRecognizerShouldBegin: 的区别是，shouldReceiveTouch 会拿到 touch 事件，决定是否开始识别，而 gestureRecognizerShouldBegin 是准备改变手势状态时，你可以通过识别的情况来决定是否转化。shouldReceiveTouch 会最先回调。</p><p>##允许同时响应手势识别<br>默认的情况时，同一时间两个手势不能同时被识别。但有一种情况下，比如你想用户在缩放视图时同时旋转同时进行。你需要改变他的默认行为了。 可以用 gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer: 这个 UIGestureRecognizerDelegate 协议里的方法。这个方法会在判定是否阻止一个方法在识别时，同时阻止另一个的识别。默认它会返回 NO. 返回 YES 的会你可以让两个手势同时识别。<br>注意：虽然返回 YES 可以让两个手势同时被识别，但设置为 NO 不一定它不会被同时识别，因为也许另一个手势的 delegate 里会设置为 YES</p><p>##指定两个手势之间的单向关系<br>如果你想控制两个手势的交互的单向关系，你可以覆盖 canPreventGestureRecognizer: 或 canBePreventedByGestureRecognizer: 子类方法，返回 NO (默认为 YES). 例如，你想旋转时防止收缩手势，但你不想收缩时防止旋转，你可以这样指定:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rotationGestureRecognizer canPreventGestureRecognizer:pinchGestureRecognizer];</span><br></pre></td></tr></table></figure></p><p>然后覆盖这个手势子类方法返回 NO. 更多的子类化手势定制可以看下面的: <a href="http://www.atatech.org/articles/22122" target="_blank" rel="noopener">创建自定义手势</a><br>与其它界面控件的交互<br>在 iOS 6 之后，默认的控件避免了重叠的手势行为。例如，你有一个按钮并也附加了单击动作，然后你又有一个单击的手势附加在了这个按钮的父视图上，然后用户点击了这个按钮，这个按钮方法会首先拦截到这个触摸事件而不去响应手势识别。这样的规则只在默认的控件行为上，包括:<br>在 UIBUutton, UISwitch, UIStepper, UISegmentedControl, 和 UIPageControl 上单击<br>在 UISlider 上滑动<br>在 UISwitch 上平移。</p><p>如果你想定制这些控件的默认行为，请尽量参照 iOS 人机交互指南.</p><p>##解释手势识别触摸原理<br>到目前为止，你已经了解到了怎样识别手势并如何响应他们，然而，如果你要创建一个自定义的手势识别，你还需要了解更多关于它的细节原理。<br>一个事件包括所有的点击序列<br>在 iOS 里，触摸表示手指出现在屏幕上或在上面运动。一个手势有一次或多次触摸，他们都被 UITouch 对象所表示。例如，一次捏合手势里有两个手指在屏幕上向相反的方向运动。<br>事件包括了一段时间里所有的触摸序列，触摸序列开始于一个手指的触摸，直到最后一个手指离开屏幕。作为一个手指移动，iOS 发送触摸对象给事件。多触摸事件被表示为 UIEventTypeTouches 类型的 UIEvent 对象.<br>每个触摸对象只跟踪一个手指，在一个多触摸序列中。这序列期间， UIKit 跟踪手指并更新它的触摸属性，这些属性包括触摸阶段，在视图的位置，上一次的位置，时间。<br>这个触摸阶段指明触摸开始，是否移动或停止等。看下图:<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/event_touch_time_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/event_touch_time_2x.png" alt="触摸序列与阶段"></a></p><p>##APP 收到触摸时调用的操作方法<br>在多点触摸序列中，当有新的或改变的触摸阶段时都会发送信息给这些回调方法:<br>touchesBegan:withEvent: 当一个或多个手指触摸到屏幕时touchesMoved:withEvent: 当手指开始移动时touchesEnded:withEvent: 当一个或多个手指离开屏幕时touchesCancelled:withEvent: 当触摸被系统取消时，比如来电话时<br>注意这些方法和手势识别状态无关，比如 UIGestureRecognizerStateBegan 和 UIGestureRecognizerStateEnded ，手势识别状态只表示它自己的识别状态，不是触摸的状态。</p><p>##将触摸发送到视图<br>当你想修改触摸的交付路径时，你需要理解它的默认行为。在一般情况下，当触摸发生，这个触摸对象会从 UIApplication 对象传递给 UIWindow 对象。在传递触摸对象给视图之前，它会先发送触摸对象到附加在触摸到的视图（或他的父视图）上的手势识别对象，<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/path_of_touches_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/path_of_touches_2x.png" alt="默认触摸的交付路径"></a></p><p>##手势识别首先得到识别触摸的机会<br>一个 window 延迟交付触摸对象给这个视图，所以是手势识别首先识别手势，在延误期间，如果手势能识别这个触摸手势，接下来这个 window 永远不会将触摸事件传递给视图.<br>例如你有一个离散的手势识别需要两个手指，下图显示了两个手指传入时将会的变化:<br><a href="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/recognize_touch_2x.png" target="_blank" rel="noopener"><img src="https://developer.apple.com/library/ios/documentation/EventHandling/Conceptual/EventHandlingiPhoneOS/Art/recognize_touch_2x.png" alt="触摸信息序列"></a><br>注意最后当触摸被识别后，之前在视图上的触摸就会被取消，发送了 touchesCancelled:withEvent: 方法。</p><p>##影响交付触摸到视图<br>你可以通过一些 UIGestureRecognizer 属性修改默认的将会行为，如果你改变了它们默认的属性，你将得到下列的行为<br>delaysTouchesBegan (默认为 NO) ，默认 window 在 Began 和 Moved 阶段会发送触摸对象给视图和手势. 如果设置为 YES 的时候，window 会延迟交付给视图，这确保当手势识别成功后不再将交付给视图. 注意设置这个属性的时候要谨慎，他可能会让你的界面感觉无反应。</p><p>这样的设置提供了一个类似的行为在 UIScrollView 的 delaysContentTouches 属性中，在这样的场景下，当滚动开始不久后，scroll-view 里的子对象不会收到 touch 信息，这样不会让他看直起来闪烁。<br>delaysTouchesEnded (默认为YES) , 当它为 YES 时，如果手势想取消它时，确保视图不完成 action 。当手势识别在分析手势时， window 不会在 Ended 阶段交付触摸对象给视图。当手势识别它是手势时，触摸对象被取消。如果 识别失败，window 会交付它到视图，发送 touchesEnded:withEvent: 信息。设置它为 NO 时， 在发析时，也同时发送信息给视图。</p><p>考虑这样的情部，一个视图需要双击识别，用户双击这个视图，如果 属性设置为 YES, 这个视图会得到 touchesBegan:withEvent:, touchesBegan:withEvent:, touchesCancelled:withEvent:, 和 touchesCancelled:withEvent:。如果这个属性设置为 NO, 这个视图收到这样的序列 : touchesBegan:withEvent:, touchesEnded:withEvent:, touchesBegan:withEvent:, 和 touchesCancelled:withEvent:, which means that in touchesBegan:withEvent:，这个视图可以识别一个双击<br>如果手势识别判定一个触摸不是它手势的一部分，它可以直接传递给它的视图，要做到这一点，可以调用手势识别方法 ignoreTouch:forEvent: 。<br>定制手势识别<br>实现一个定制的手势，首先要创建 UIGestureRecognizer 的子类，然后 import 这个子类的头文件</p><p>#import<br>然后从 UIGestureRecognizerSubclass.h 头文件中拷贝下面的方法声明到你的子类里:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset;</span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure></p><p>这些方法和触摸操作一样有明确的行为，在你覆盖它们前，你要先调用父类的实现，即使它是一个空的实现。<br>注意 state 这个属性在你引入 UIGestureRecognizerSubclass.h 头文件后，就从只读变为可读写的了。<br>实现自定义的触摸实别操作<br>核心是在于通过下面四个方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">touchesBegan:withEvent:,</span><br><span class="line">touchesMoved:withEvent:, </span><br><span class="line">touchesEnded:withEvent:, </span><br><span class="line">touchesCancelled:withEvent:</span><br></pre></td></tr></table></figure></p><p>去将抽像低的触摸行为变为可识别的高级行为。<br>下面这个例子中，仅有一个 view ，但很多 app 中有多个 view ， 通常，你应该转换为屏幕坐标，以正确识别手势。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIGestureRecognizerSubclass.h&gt;</span></span></span><br><span class="line"><span class="comment">// Implemented in your custom subclass</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesBegan:touches withEvent:event]; </span><br><span class="line">    <span class="keyword">if</span> ([touches count] != <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateFailed</span>; </span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [<span class="keyword">super</span> touchesMoved:touches withEvent:event];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state == <span class="built_in">UIGestureRecognizerStateFailed</span>)  <span class="keyword">return</span>; </span><br><span class="line">    <span class="built_in">UIWindow</span> *win = [<span class="keyword">self</span>.view window]; </span><br><span class="line">    <span class="built_in">CGPoint</span> nowPoint = [touches.anyObject locationInView:win];</span><br><span class="line">    <span class="built_in">CGPoint</span> nowPoint = [touches.anyObject locationInView:<span class="keyword">self</span>.view];</span><br><span class="line">    <span class="built_in">CGPoint</span> prevPoint = [touches.anyObject previousLocationInView:<span class="keyword">self</span>.view]; </span><br><span class="line">    <span class="comment">// strokeUp is a property </span></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">self</span>.strokeUp) &#123;</span><br><span class="line">   <span class="comment">// On downstroke, both x and y increase in positive direction </span></span><br><span class="line">    <span class="keyword">if</span> (nowPoint.x &gt;= prevPoint.x &amp;&amp; nowPoint.y &gt;= prevPoint.y) &#123;</span><br><span class="line">        <span class="keyword">self</span>.midPoint = nowPoint; </span><br><span class="line">        <span class="comment">// Upstroke has increasing x value but decreasing y value </span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nowPoint.x &gt;= prevPoint.x &amp;&amp; nowPoint.y &lt;= prevPoint.y)&#123;</span><br><span class="line">         <span class="keyword">self</span>.strokeUp = <span class="literal">YES</span>; </span><br><span class="line">       &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">          <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateFailed</span>;</span><br><span class="line">       &#125; </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">      [<span class="keyword">super</span> touchesEnded:touches withEvent:event];</span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">self</span>.state == <span class="built_in">UIGestureRecognizerStatePossible</span>) &amp;&amp; <span class="keyword">self</span>.strokeUp) &#123; </span><br><span class="line">       <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateRecognized</span>; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">       [<span class="keyword">super</span> touchesCancelled:touches withEvent:event]; </span><br><span class="line">       <span class="keyword">self</span>.midPoint = <span class="built_in">CGPointZero</span>; </span><br><span class="line">       <span class="keyword">self</span>.strokeUp = <span class="literal">NO</span>; </span><br><span class="line">       <span class="keyword">self</span>.state = <span class="built_in">UIGestureRecognizerStateFailed</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于状态转化离散和持续手势是不一样的，正如上面的 “有限状态机中的手势识别” 所述一样，当你创建一个自定义手势识别，你必需明确指明它的相关状态是否为离散或连续。上面的那个例子，它的状态永远不会设置为 Began 或 Changed ，因为它是离散的。<br>更多的自定义手势资料可以查看 <a href="https://developer.apple.com/videos/wwdc/2012/?id=233" target="_blank" rel="noopener">WWDC 2012: Building Advanced Gesture Recognizers</a><br>重置手势状态<br>如果你的手势识别转变为 Recognized/Ended, Canceled, 或 Failed, 这个 UIGestureRecognizer 类会在状态变为 Possible 之前调用 reset 方法<br>实现 reset 方法以便重置你的一些内部状态，以便你可以为下一次的识别做准备。下面是一个例子:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reset &#123; </span><br><span class="line">      [<span class="keyword">super</span> reset]; </span><br><span class="line">      <span class="keyword">self</span>.midPoint = <span class="built_in">CGPointZero</span>; </span><br><span class="line">      <span class="keyword">self</span>.strokeUp = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-手势详解&quot;&gt;&lt;a href=&quot;#iOS-手势详解&quot; class=&quot;headerlink&quot; title=&quot;iOS 手势详解&quot;&gt;&lt;/a&gt;iOS 手势详解&lt;/h1&gt;&lt;h2 id=&quot;手势识别&quot;&gt;&lt;a href=&quot;#手势识别&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>UIWindow 整理</title>
    <link href="https://hongruqi.github.io/2016/07/21/UIWindow%20%E6%95%B4%E7%90%86/"/>
    <id>https://hongruqi.github.io/2016/07/21/UIWindow 整理/</id>
    <published>2016-07-20T16:00:00.000Z</published>
    <updated>2019-02-22T07:52:20.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UIWindow-整理"><a href="#UIWindow-整理" class="headerlink" title="UIWindow 整理"></a>UIWindow 整理</h1><p>##<strong>UIWindow概念</strong><br>UIWindw定义了一个负责管理，协调一个App的View是如何显示在设备屏幕上的窗口类，除非一个App可以显示在一个外部的设备屏幕上，那么一个App只拥有一个窗口。UIWindow本身没有标题栏，关闭操作栏等任何的装饰物，用户不会看见，移动或者是关闭它，这跟Mac OS上的window有很大的差别。      UIWindow的两大主要功能是提供了一块给View的显示区域，并且负责分发各种事件给View，比如传递触摸事件给各项View或者其它对象。而改变App的显示内容，可以改变UIWindow的rootView，而不需要去创建一个新的UIWindow。同时，它还负责与ViewController协同去处理设备旋转时的情况。      讲到Window还必须要提的两个概念是UIWindowLevel以及KeyWindow。UIWindowLevel是一个CGFloat值，现在UIKit定义了三种Level:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelNormal</span>; </span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelAlert</span>;</span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="keyword">const</span> <span class="built_in">UIWindowLevel</span> <span class="built_in">UIWindowLevelStatusBar</span></span><br></pre></td></tr></table></figure></p><p>UIWindowLevel为2D的iOS世界引入了Z轴的概念，它相当于以屏幕为原地，以使用者为正方向的一根轴。值越小代表离使用者越远，越大代表越靠近使用者。高Level的Window会盖住低Level的window，若是两者Level一样则根据添加顺序来决定，这类似于我们添加子View(UIWindow本来也就是UIView的子类)。而上面三个值分别是0.0,2000.0,1000.0，而大部分在App上使用的都是UIWindowLevelNormal，这也是每个Window被创建出来时的默认值。    我们在创建一个新的window的时候，要让它显示出来必须要调用makeKeyAndVisible方法，让window显示出来，并让它成为一个KeyWindow。KeyWindow是UIApplication的一个开放属性，它是当前App的主window，用来接收键盘输入以及非触摸事件(触摸事件是传递给触摸事件发生的window，不一定是keyWindow)，或者是跟坐标值无关的事件都会被传递给keyWindow。并且在同一时刻，只有一个window会成为keyWindow。但是需要注意一件事情，成为keywindow与windowLevel无关，并不是windowLevel最高的window会成为keywindow.</p><p>##<strong>UIWindow在App启动时扮演的角色</strong><br><strong>(1)The Main Function</strong><br>  所有以C语言为基础的程序的入口都是main函数，iOS App也不例外。以下程序就是iOS App的main函数：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"AppDelegate.h"</span> </span></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])&#123; </span><br><span class="line">      <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>])); </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>唯一不同的是你不用去写main函数，这是Xcode自动创建的。这段代码也很简单，它唯一做的工作就是把控制权移交给UIKit framework，根据第三个参数principalClassName创建一个UIApplication对象，根据第四个参数创建一个AppDelegate对象。 </p><p><strong>(2)UIApplication</strong><br>     UIApplication是一个App的核心，它主要的职能是负责方便系统和App的交互，管理Event Loop进行各项事件的处理，以及向自己的Delegate，即AppDelegate进行一些关键事件的传递。一个App只有一个UIApplication单例对象，可以通过[UIApplication sharedApplication]来获得单例。它还能做一些应用级别的事，比如设置桌面上App图标右上角的红点数字，或者是使用openURL直接拨电话，发短信等。在此不做延伸。<br><img src="http://upload-images.jianshu.io/upload_images/901318-74734c584f6565e3.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.jpeg"></p><p><strong> (3)UIWindow</strong></p><p>UIWindow是iOS启动之后，被创建的第一个视图控件。它有可能是通过Interface Builder被创建出来的，也有可能是我们在AppDelegate中自定义创建出来的。当它被创建，添加了rootView之后，一个App的界面最终被展示在用户面前。而如果是自定义创建window时，我们通常会使用window.rootViewController来为它添加rootView，值得注意的是，这句代码仅仅是给UIWindow添加了rootViewController的view，或者说这是一种更加便利的方式来为UIWindow添加rootView,而这个rootViewController属性并不是用来让controller与UIWindow之间进行通信的。除此之外，UIWindow还负责与UIApplication一起负责传递Event给View以及ViewController。</p><p>##拾遗<br><strong>(1)UITextEffectsWindow</strong><br> 这是iOS8引入的一个新window，是键盘所在的window。它的windowLevel是10，高于UIWindowLevelNormal。<br><strong>(2)UIRemoteKeyboardWindow</strong><br>iOS9之后,新增了一个类型为 UIRemoteKeyboardWindow 的窗口用来显示键盘按钮。目前对这个研究还不是很多，以后有了新发现再与大家分享。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;UIWindow-整理&quot;&gt;&lt;a href=&quot;#UIWindow-整理&quot; class=&quot;headerlink&quot; title=&quot;UIWindow 整理&quot;&gt;&lt;/a&gt;UIWindow 整理&lt;/h1&gt;&lt;p&gt;##&lt;strong&gt;UIWindow概念&lt;/strong&gt;&lt;br&gt;U
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 性能提升总结</title>
    <link href="https://hongruqi.github.io/2016/07/20/iOS%20%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E6%80%BB%E7%BB%93/"/>
    <id>https://hongruqi.github.io/2016/07/20/iOS 性能提升总结/</id>
    <published>2016-07-19T16:00:00.000Z</published>
    <updated>2019-02-22T07:50:59.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-性能提升总结"><a href="#iOS-性能提升总结" class="headerlink" title="iOS 性能提升总结"></a>iOS 性能提升总结</h1><p>##使用复用机制</p><p>在我们使用 UITableView 和 UICollectionView 时我们通常会遇到「复用 Cell」这个提法，所谓「复用 Cell」就是指当需要展示的数据条目较多时，只创建较少数量的 Cell 对象（一般是屏幕可显示的 Cell 数再加一）并通过复用它们的方式来展示数据的机制。这种机制不会为每一条数据都创建一个 Cell，所以可以节省内存，提升程序的效率和交互流畅性。<br>从 iOS 6 以后，我们在 UITableView 和 UICollectionView 中不光可以复用 Cell，还可以复用各个 Section 的 Header 和 Footer。<br>在 UITableView 做复用的时候，会用到的 API：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 复用 Cell：</span></span><br><span class="line">- [<span class="built_in">UITableView</span> dequeueReusableCellWithIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> registerNib:forCellReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> registerClass:forCellReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> dequeueReusableCellWithIdentifier:forIndexPath:];<span class="comment">// 复用 Section 的 Header/Footer：</span></span><br><span class="line">- [<span class="built_in">UITableView</span> registerNib:forHeaderFooterViewReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> registerClass:forHeaderFooterViewReuseIdentifier:];</span><br><span class="line">- [<span class="built_in">UITableView</span> dequeueReusableHeaderFooterViewWithIdentifier:];</span><br></pre></td></tr></table></figure></p><p>复用机制是一个很好的机制，但是不正确的使用却会给我们的程序带来很多问题。下面拿 UITableView 复用 Cell 来举例：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier =  <span class="string">@"UITableViewCell"</span>; </span><br><span class="line">    <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>;</span><br><span class="line">    cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!cell) &#123; </span><br><span class="line">         cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleSubtitle</span> reuseIdentifier:CellIdentifier]; </span><br><span class="line"><span class="comment">// 偶数行 Cell 的 textLabel 的文字颜色为红色。</span></span><br><span class="line">        <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">               [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> redColor]]; </span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   cell.textLabel.text = <span class="string">@"Title"</span>;</span><br><span class="line"> <span class="comment">// 偶数行 Cell 的 detailTextLabel 显示 Detail 文字。</span></span><br><span class="line">      <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">       cell.detailTextLabel.text = <span class="string">@"Detail"</span>; </span><br><span class="line">     &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们本来是希望只有偶数行的 textLabel 的文字颜色为红色，并且显示 Detail 文字，但是当你滑动 TableView 的时候发现不对了，有些奇数行的 textLabel 的文字颜色为红色，而且还显示了 Detail 文字，很奇怪。其实造成这个问题的原因就是「复用」，当一个 Cell 被拿来复用时，它所有被设置的属性（包括样式和内容）都会被拿来复用，如果刚好某一个的 Cell 你没有显式地设置它的属性，那么它这些属性就直接复用别的 Cell 的了。就如上面的代码中，我们并没有显式地设置奇数行的 Cell 的 textLabel 的文字颜色以及 detailTextLabel 的文字，那么它就有可能复用别的 Cell 的这些属性了。此外，还有个问题，对偶数行 Cell 的 textLabel 的文字颜色的设置放在了初始一个 Cell 的 if 代码块里，这样在复用的时候，逻辑走不到这里去，那么也会出现复用问题。所以，上面的代码需要改成这样：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier = <span class="string">@"UITableViewCell"</span>; </span><br><span class="line">   <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>; </span><br><span class="line">   cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; </span><br><span class="line">   <span class="keyword">if</span> (!cell) &#123; </span><br><span class="line">       cell = [[<span class="built_in">UITableViewCell</span> alloc] initWithStyle:<span class="built_in">UITableViewCellStyleSubtitle</span> reuseIdentifier:CellIdentifier];</span><br><span class="line">   &#125; </span><br><span class="line"></span><br><span class="line">   cell.textLabel.text = <span class="string">@"Title"</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">       [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> redColor]]; </span><br><span class="line">       cell.detailTextLabel.text = <span class="string">@"Detail"</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">       [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> blackColor]];</span><br><span class="line">       cell.detailTextLabel.text = <span class="literal">nil</span>; </span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总之在复用的时候需要记住：<br><strong>设置 Cell 的存在差异性的那些属性（包括样式和内容）时，有了 if 最好就要有 else，要显式的覆盖所有可能性。</strong><br><strong>设置 Cell 的存在差异性的那些属性时，代码要放在初始化代码块的外部。</strong></p><p>上面的代码中，我们展示了 - [UITableView dequeueReusableCellWithIdentifier:];<br> 的用法。下面看看另几个 API 的用法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITableView</span> *myTableView;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123; </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">        <span class="comment">// Setup table view. </span></span><br><span class="line">    <span class="keyword">self</span>.myTableView.delegate = <span class="keyword">self</span>;</span><br><span class="line">    <span class="keyword">self</span>.myTableView.dataSource = <span class="keyword">self</span>;</span><br><span class="line">   [<span class="keyword">self</span>.myTableView registerClass:[MyTableViewCell <span class="keyword">class</span>] forCellReuseIdentifier:<span class="string">@"MyTableViewCell"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">NSString</span> *CellIdentifier = <span class="string">@"MyTableViewCell"</span>; </span><br><span class="line">     <span class="built_in">UITableViewCell</span> *cell = <span class="literal">nil</span>; </span><br><span class="line">     cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath];</span><br><span class="line">     cell.textLabel.text = <span class="string">@"Title"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (indexPath.row % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">           [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> redColor]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          [cell.textLabel setTextColor:[<span class="built_in">UIColor</span> blackColor]];</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，- [UITableView dequeueReusableCellWithIdentifier:forIndexPath:];<br> 必须搭配- [UITableView registerClass:forCellReuseIdentifier:];或者- [UITableView registerNib:forCellReuseIdentifier:];<br> 使用。当有可重用的 Cell 时，前者直接拿来复用，并调用 - [UITableViewCell prepareForReuse]<br> 方法；当没有时，前者会调用 Identifier 对应的那个注册的 UITableViewCell 类的 - [UITableViewCell initWithStyle:reuseIdentifier:]方法来初始化一个，这里省去了你自己初始化的步骤。当你自定义了一个 UITableViewCell 的子类时，你可以这样来用。</p><p>##优化 UITableView<br>UITableView 是我们最常用来展示数据的控件之一，并且通常需要 UITableView 在承载较多内容的同时保证交互的流畅性，对 UITableView 的性能优化是我们开发应用程序必备的技巧之一。<br>在前文「使用复用机制」一节，已经提到了 UITableView 的复用机制。现在就来看看 UITableView 在复用时最主要的两个回调方法：- [UITableView tableView:cellForRowAtIndexPath:]和- [UITableView tableView:heightForRowAtIndexPath:]。UITableView 是继承自 UIScrollView，所以在渲染的过程中它会先确定它的 contentSize 及每个 Cell 的位置，然后才会把复用的 Cell 放置到对应的位置。比如现在一共有 50 个 Cell，当前屏幕上显示 5 个。那么在第一次创建或 reloadData 的时候， UITableView 会先调用 50 次- [UITableView tableView:heightForRowAtIndexPath:]<br> 确定 contentSize 及每个 Cell 的位置，然后再调用 5 次 - [UITableView tableView:cellForRowAtIndexPath:]<br> 来渲染当前屏幕的 Cell。在滑动屏幕的时候，每当一个 Cell 进入屏幕时，都需要调用一次 - [UITableView tableView:cellForRowAtIndexPath:]和- [UITableView tableView:heightForRowAtIndexPath:]方法。<br>了解了 UITableView 的复用机制以及相关回调方法的调用次序，这里就对 UITableView 的性能优化方案做一个总结：</p><ul><li>通过正确的设置 reuseIdentifier 来重用 Cell。</li><li>尽量减少不必要的透明 View。</li><li>尽量避免渐变效果、图片拉伸和离屏渲染。</li><li>当不同的行的高度不一样时，尽量缓存它们的高度值。</li><li>如果 Cell 展示的内容来自网络，确保用异步加载的方式来获取数据，并且缓存服务器的 response。</li><li>使用 shadowPath 来设置阴影效果。</li><li>尽量减少 subview 的数量，对于 subview 较多并且样式多变的 Cell，可以考虑用异步绘制或重写 drawRect。</li><li>尽量优化 - [UITableView tableView:cellForRowAtIndexPath:]</li><li>方法中的处理逻辑，如果确实要做一些处理，可以考虑做一次，缓存结果。</li><li>选择合适的数据结构来承载数据，不同的数据结构对不同操作的开销是存在差异的。</li><li>对于 rowHeight、sectionFooterHeight、sectionHeaderHeight 尽量使用常量。</li></ul><p>##尽可能设置 View 为不透明<br>UIView 有一个 opaque属性，在你不需要透明效果时，你应该尽量设置它为 YES 可以提高绘图过程的效率。<br>在一个静态的视图里，这点可能影响不大，但是当在一个可以滚动的 Scroll View 中或是一个复杂的动画中，透明的效果可能会对程序的性能有较大的影响。</p><p>##避免臃肿的 XIB 文件<br>如果你压根不用 XIB，那就不需要看了。</p><p>在你需要重用某些自定义 View 或者因为历史兼容原因用到 XIB 的时候，你需要注意：当你加载一个 XIB 时，它的所有内容都会被加载，如果这个 XIB 里面有个 View 你不会马上就用到，你其实就是在浪费宝贵的内存。而加载 StoryBoard 时并不会把所有的 ViewController 都加载，只会按需加载。</p><p>##不要阻塞主线程<br>基本上 UIKit 会把它所有的工作都放在主线程执行，比如：绘制界面、管理手势、响应输入等等。当你把所有代码逻辑都放在主线程时，有可能因为耗时太长卡住主线程造成程序无法响应、流畅性太差等问题。造成这种问题的大多数场景是因为你的程序把 I/O 操作放在了主线程，比如从硬盘或者网络读写数据等等。</p><p>你可以通过异步的方式来进行这些操作，把他们放在别的线程中处理。比如处理网络请求时，你可以使用 NSURLConnection 的异步调用 API：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)sendAsynchronousRequest:(<span class="built_in">NSURLRequest</span> *)request queue:(<span class="built_in">NSOperationQueue</span> *)queue completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span>*, <span class="built_in">NSData</span>*, <span class="built_in">NSError</span>*))handler;</span><br></pre></td></tr></table></figure></p><p>或者使用第三方的类库，比如 <a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFNetworking</a>。<br>当你做一些耗时比较长的操作时，你可以使用 GCD、NSOperation、NSOperationQueue。比如 GCD 的常见使用方式：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123; </span><br><span class="line">     <span class="comment">// switch to another thread and perform your expensive operation</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; </span><br><span class="line">            <span class="comment">// switch back to the main thread to update your UI</span></span><br><span class="line">     &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于 GCD 更多的知识，你可以看看这篇文章：<a href="http://www.atatech.org/articles/41244" target="_blank" rel="noopener">GCD</a>。</p><p>###图片尺寸匹配 UIImageView</p><p>当你从 App bundle 中加载图片到 UIImageView 中显示时，最好确保图片的尺寸能够和 UIImageView 的尺寸相匹配（当然，需要考虑 @2x @3x 的情况），否则会使得 UIImageView 在显示图片时需要做拉伸，这样会影响性能，尤其是在一个 UIScrollView 的容器里。</p><p>有时候，你的图片是从网络加载的，这时候你并不能控制图片的尺寸，不过你可以在图片下载下来后去手动 scale 一下它，当然，最好是在一个后台线程做这件事，然后在 UIImageView 中使用 resize 后的图片。<br>关于这一点SDWebImage进行了优化，如果你使用SDWebImage，它会帮你进行Scale优化。</p><p>##选择合适的容器<br>我们经常需要用到容器来转载多个对象，我们通常用到的包括：NSArray、NSDictionary、NSSet，它们的特性如下：</p><ul><li>Array：数组。有序的，通过 index 查找很快，通过 value 查找很慢，插入和删除较慢。</li><li>Dictionary：字典。存储键值对，通过键查找很快。</li><li>Set：集合。无序的，通过 value 查找很快，插入和删除较快。</li></ul><p>根据以上特性，在编程中需要选择适合的容器。更多内容请看：<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Collections/Collections.html" target="_blank" rel="noopener">Collections Programming Topics</a></p><p>##启用 GZIP 数据压缩<br>现在越来越多的应用需要跟服务器进行数据交互，当交互的数据量较大时，网络传输的时延就会较长，通过启动数据压缩功能，尤其是对于文本信息，可以降低网络传输的数据量，从而减短网络交互的时间。</p><p>一个好消息是当你使用 NSURLConnection 或者基于此的一些网络交互类库（比如 AFNetworking）时 iOS 已经默认支持 GZIP 压缩。并且，很多服务器已经支持发送压缩数据。</p><p>通过在服务器和客户端程序中启用对网络交互数据的压缩，是一条提高应用程序性能的途径。</p><p>##View 的复用和懒加载机制<br>当你的程序中需要展示很多的 View 的时候，这就意味着需要更多的 CPU 处理时间和内存空间，这个情况对程序性能的影响在你使用 UIScrollView 来装载和呈现界面时会变得尤为显著。</p><p>处理这种情况的一种方案就是向 UITableView 和 UICollectionView 学习，不要一次性把所有的 subviews 都创建出来，而是在你需要他们的时候创建，并且用复用机制去复用他们。这样减少了内存分配的开销，节省了内存空间。</p><p>「懒加载机制」就是把创建对象的时机延后到不得不需要它们的时候。这个机制常常用在对一个类的属性的初始化上，比如：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableView</span> *)myTableView &#123; </span><br><span class="line">    <span class="keyword">if</span> (!_myTableView) &#123;</span><br><span class="line">    <span class="built_in">CGRect</span> viewBounds = <span class="keyword">self</span>.view.bounds;</span><br><span class="line">    _myTableView = [[<span class="built_in">UITableView</span> alloc] initWithFrame:viewBounds style:<span class="built_in">UITableViewStylePlain</span>];</span><br><span class="line">    _myTableView.showsHorizontalScrollIndicator = <span class="literal">NO</span>; </span><br><span class="line">    _myTableView.showsVerticalScrollIndicator = <span class="literal">NO</span>; </span><br><span class="line">    _myTableView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">    [_myTableView setSeparatorStyle:<span class="built_in">UITableViewCellSeparatorStyleNone</span>];</span><br><span class="line">    _myTableView.dataSource = <span class="keyword">self</span>; </span><br><span class="line">    _myTableView.delegate = <span class="keyword">self</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> _myTableView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只有当我们第一次用到 self.myTableView 的时候采取初始化和创建它。<br>但是，存在这样一种场景：你点击一个按钮的时候，你需要显示一个 View，这时候你有两种实现方案：</p><ol><li>在当前界面第一次加载的时候就创建出这个 View，只是把它隐藏起来，当你需要它的时候，只用显示它就行了。</li><li>使用「懒加载机制」，在你需要这个 View 的时候才创建它，并展示它。<br>这两种方案都各有利弊。采用方案一，你在不需要这个 View 的时候显然白白地占用了更多的内存，但是当你点击按钮展示它的时候，你的程序能响应地相对较快，因为你只需要改变它的 hidden 属性。采用方案二，那么你得到的效果相反，你更准确的使用了内存，但是如果对这个 View 的初始化和创建比较耗时，那么响应性相对就没那么好了。</li></ol><p>所以当你考虑使用何种方案时，你需要根据现实的情况来参考，去权衡到底哪个因素才是影响性能的瓶颈，然后再做出选择。</p><p>##缓存</p><p>在开发我们的程序时，一个很重要的经验法则就是：对那些更新频度低，访问频度高的内容做缓存。<br>有哪些东西使我们可以缓存的呢？比如下面这些：</p><ul><li>服务器的响应信息（response）。</li><li>图片。</li><li>计算值。比如：UITableView 的 row heights。<br>NSURLConnection 可以根据 HTTP 头部的设置来决定把资源内容缓存在磁盘或者内存，你甚至可以设置让它只加载缓存里的内容：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMutableURLRequest</span> *)imageRequestWithURL:(<span class="built_in">NSURL</span> *)url &#123; </span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url]; </span><br><span class="line">    request.cachePolicy = <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>; </span><br><span class="line">    <span class="comment">// this will make sure the request always returns the cached image </span></span><br><span class="line">    request.HTTPShouldHandleCookies = <span class="literal">NO</span>;</span><br><span class="line">    request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">    [request addValue:<span class="string">@"image/*"</span> forHTTPHeaderField:<span class="string">@"Accept"</span>]; </span><br><span class="line">    ]<span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于 HTTP 缓存的更多内容可以关注 NSURLCache。关于缓存其他非 HTTP 请求的内容，可以关注 NSCache。对于图片缓存，可以关注一个第三方库 <a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a>。</p><p>##关于图形绘制<br>当我们为一个 UIButton 设置背景图片时，对于这个背景图片的处理，我们有很多种方案，你可以使用全尺寸图片直接设置，还可以用 resizable images，或者使用 CALayer、CoreGraphics 甚至 OpenGL 来绘制。<br>当然，不同的方案的编码复杂度不一样，性能也不一样。关于图形绘制的不同方案的性能问题，可以看看：<a href="https://robots.thoughtbot.com/designing-for-ios-graphics-performance" target="_blank" rel="noopener">Designing for iOS: Graphics Performance</a><br>简而言之，使用 pre-rendered 的图片会更快，因为这样就不需要在程序中去创建一个图像，并在上面绘制各种形状了（Offscreen Rendering，离屏渲染）。但是缺点是你必须把这些图片资源打包到代码包，从而需要增加程序包的体积。这就是为什么 resizable images 是一个很棒的选择：不需要全尺寸图，让 iOS 为你绘制图片中那些可以拉伸的部分，从而减小了图片体积；并且你不需要为不同大小的控件准备不同尺寸的图片。比如两个按钮的大小不一样，但是他们的背景图样式是一样的，你只需要准备一个对应样式的 resizable image，然后在设置这两个按钮的背景图的时候分别做拉伸就可以了。<br>但是一味的使用使用预置的图片也会有一些缺点，比如你做一些简单的动画的时候各个帧都用图片叠加，这样就可能要使用大量图片。<br>总之，你需要去在图形绘制的性能和应用程序包的大小上做权衡，找到最合适的性能优化方案。</p><p>##处理 Memory Warnings</p><p>关于内存警告，苹果的官方文档是这样说的：</p><blockquote><p>If your app receives this warning, it must free up as much memory as possible. The best way to do this is to remove strong references to caches, image objects, and other data objects that can be recreated later.</p></blockquote><p>我们可以通过这些方式来获得内存警告：<br>在 AppDelegate 中实现 - [AppDelegate applicationDidReceiveMemoryWarning:]代理方法。<br>在 UIViewController 中重载 didReceiveMemoryWarning方法。<br>监听 UIApplicationDidReceiveMemoryWarningNotification通知。</p><p>当通过这些方式监听到内存警告时，你需要马上释放掉不需要的内存从而避免程序被系统杀掉。<br>比如，在一个 UIViewController 中，你可以清除那些当前不显示的 View，同时可以清除这些 View 对应的内存中的数据，而有图片缓存机制的话也可以在这时候释放掉不显示在屏幕上的图片资源。<br>但是需要注意的是，你这时清除的数据，必须是可以在重新获取到的，否则可能因为必要数据为空，造成程序出错。在开发的时候，可以使用 iOS Simulator 的 Simulate memory warning的功能来测试你处理内存警告的代码。</p><p>##复用高开销的对象<br>在 Objective-C 中有些对象的初始化过程很缓慢，比如：NSDateFormatter和 NSCalendar，但是有些时候，你也不得不使用它们。为了这样的高开销的对象成为影响程序性能的重要因素，我们可以复用它们。<br>比如，我们在一个类里添加一个 NSDateFormatter 的对象，并使用懒加载机制来使用它，整个类只用到一个这样的对象，并只初始化一次：<br>保证应用快速启动的指导原则：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your .h or inside a class extension</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDateFormatter</span> *dateFormatter;</span><br><span class="line"><span class="comment">// inside the implementation (.m)</span></span><br><span class="line"><span class="comment">// When you need, just use self.dateFormatter</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123; </span><br><span class="line">     <span class="keyword">if</span> (! _dateFormatter) &#123; </span><br><span class="line">     _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">     [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>]; </span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> _dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是上面的代码在多线程环境下会有问题，所以我们可以改进如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no property is required anymore. The following code goes inside the implementation (.m)</span></span><br><span class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *dateFormatter; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">   <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">      _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init]; </span><br><span class="line">      [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd a HH:mm:ss EEEE"</span>];</span><br><span class="line">   &#125;);</span><br><span class="line"> <span class="keyword">return</span> dateFormatter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就线程安全了。（关于多线程 GCD 的知识，可以看看这篇文章：<a href="http://www.samirchen.com/ios-gcd/" target="_blank" rel="noopener">GCD</a>）<br>需要注意的是：设置 NSDateFormatter 的 date format 跟创建一个新的 NSDateFormatter 对象一样慢，因此当你的程序中要用到多种格式的 date format，而每种又会用到多次的时候，你可以尝试为每种 date format 创建一个可复用的 NSDateFormatter 对象来提供程序的性能。</p><p>##减少应用启动时间<br>快速启动应用对于用户来说可以留下很好的印象。尤其是第一次使用时。尽量将启动过程中的处理分拆成各个异步处理流，比如：网络请求、数据库访问、数据解析等等。<br>避免臃肿的 XIB 文件，因为它们会在你的主线程中进行加载。重申：Storyboard 没这个问题，放心使用。<br>注意：在测试程序启动性能的时候，最好用与 Xcode 断开连接的设备进行测试。因为 watchdog 在使用 Xcode 进行调试的时候是不会启动的。</p><p>##选择正确的数据格式</p><p>我们的 iOS 应用程序与服务器进行交互时，通常采用的数据格式就是 JSON 和 XML 两种。那么在选择哪一种时，需要考虑到它们的优缺点。<br>JSON 文件的优点是：</p><ul><li>能够更快的被解析。</li><li>在承载相同的数据时，通常体积比 XML 更小，这意味着传输的数据量更小。</li></ul><p>缺点是：</p><ul><li>需要整个 JSON 数据全部加载完成后才能开始解析。</li></ul><p>而 XML 文件的优缺点则刚好反过来。 XML 的一个优点就是它可以使用 <a href="https://en.wikipedia.org/wiki/Simple_API_for_XML" target="_blank" rel="noopener">SAX</a> 来解析数据，从而可以边加载边解析，不用等所有数据都读取完成了才解析。这样在处理很大的数据集的时提高性能和降低内存消耗。<br>所以，你需要根据具体的应用场景来权衡使用何种数据格式。</p><p>##合理的设置背景图片<br>我们通常有两种方式来设置一个 View 的背景图片：</p><ul><li>通过 - [UIColor colorWithPatternImage:]方法来设置 View 的 background color。</li><li>通过给 View 添加一个 UIImageView 来设置其背景图片。<br>当你有一个全尺寸图片作为背景图时，你最好用 UIImageView 来，因为 - [UIColor colorWithPatternImage:]<br>是用来可重复填充的小的样式图片。这时对于全尺寸的图片，用 UIImageView 会节省大量的内存。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// You could also achieve the same result in Interface Builder</span></span><br><span class="line"><span class="built_in">UIImageView</span> *backgroundView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"background"</span>]];</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:backgroundView];</span><br></pre></td></tr></table></figure></li></ul><p>但是，当你计划采用一个小块的模板样式图片，就像贴瓷砖那样来重复填充整个背景时，你应该用- [UIColor colorWithPatternImage:]<br> 这个方法，因为这时它能够绘制的更快，并且不会用到太多的内存。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> colorWithPatternImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"backgroundPattern"</span>]];</span><br></pre></td></tr></table></figure></p><p>##优化 WebView<br>UIWebView 在我们的应用程序中非常有用，它可以便捷的展示 Web 的内容，甚至做到你用标准的 UIKit 控件较难做到的视觉效果。但是，你应该注意到你在应用程序里使用的 UIWebView 组件不会比苹果的 Safari 更快。这是首先于 Webkit 的 Nitro Engine 引擎。所以，为了得到更好的性能，你需要优化你的网页内容。</p><p>优化第一步就是避免过量使用 Javascript，例如避免使用较大的 Javascript 框架，比如 jQuery。一般使用原生的 Javascript 而不是依赖于 Javascript 框架可以获得更好的性能。</p><p>优化第二步，如果可能的话，可以异步加载那些不影响页面行为的 Javascript 脚本，比如一些数据统计脚本。</p><p>优化第三步，总是关注你在页面中所使用的图片，根据具体的场景来显示正确尺寸的图片，同时也可以使用上面提到的「使用 Sprites Sheets」的方案来在某些地方减少内存消耗和提高速度。</p><p>##减少离屏渲染</p><p>什么是「离屏渲染」？离屏渲染，即 Off-Screen Rendering。与之相对的是 On-Screen Rendering，即在当前屏幕渲染，意思是渲染操作是用于在当前屏幕显示的缓冲区进行。那么离屏渲染则是指图层在被显示之前是在当前屏幕缓冲区以外开辟的一个缓冲区进行渲染操作。<br>离屏渲染需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上又需要将上下文环境从离屏切换到当前屏幕，而上下文环境的切换是一项高开销的动作。<br>通常图层的以下属性将会触发离屏渲染：</p><ul><li>阴影（UIView.layer.shadowOffset/shadowRadius/…）</li><li>圆角（当 UIView.layer.cornerRadius 和 UIView.layer.maskToBounds 一起使用时）</li><li>图层蒙板<br>在 iOS 开发中要给一个 View 添加阴影效果，有很简单快捷的做法：<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:...];</span><br><span class="line"><span class="comment">// Setup the shadow ...</span></span><br><span class="line">imageView.layer.shadowOffset = <span class="built_in">CGSizeMake</span>(<span class="number">5.0</span>f, <span class="number">5.0</span>f);</span><br><span class="line">imageView.layer.shadowRadius = <span class="number">5.0</span>f;</span><br><span class="line">imageView.layer.shadowOpacity = <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure></li></ul><p>但是上面这样的做法有一个坏处是：将触发 Core Animation 做离屏渲染造成开销。<br>那要做到阴影图层效果，又想减少离屏渲染、提高性能的话要怎么做呢？一个好的建议是：设置 ShadowPath 属性。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initFrame:...];</span><br><span class="line"><span class="comment">// Setup the shadow ...</span></span><br><span class="line">imageView.layer.shadowPath = [[<span class="built_in">UIBezierPath</span> bezierPathWithRect:</span><br><span class="line"><span class="built_in">CGRectMake</span>(imageView.bounds.origin.x+<span class="number">5</span>, imageView.bounds.origin.y+<span class="number">5</span>,imageView.bounds.size.width, imageView.bounds.size.height)] <span class="built_in">CGPath</span>];</span><br><span class="line">imageView.layer.shadowOpacity = <span class="number">0.6</span>;</span><br></pre></td></tr></table></figure></p><p>如果图层是一个简单几何图形如矩形或者圆角矩形（假设不包含任何透明部分或者子图层），通过设置 ShadowPath 属性来创建出一个对应形状的阴影路径就比较容易，而且 Core Animation 绘制这个阴影也相当简单，不会触发离屏渲染，这对性能来说很有帮助。如果你的图层是一个更复杂的图形，生成正确的阴影路径可能就比较难了，这样子的话你可以考虑用绘图软件预先生成一个阴影背景图。</p><p>##光栅化<br>CALayer 有一个属性是 shouldRasterize<br> 通过设置这个属性为 YES 可以将图层绘制到一个屏幕外的图像，然后这个图像将会被缓存起来并绘制到实际图层的 contents 和子图层，如果很很多的子图层或者有复杂的效果应用，这样做就会比重绘所有事务的所有帧来更加高效。但是光栅化原始图像需要时间，而且会消耗额外的内存。这是需要根据实际场景权衡的地方。<br>当我们使用得当时，光栅化可以提供很大的性能优势，但是一定要避免在内容不断变动的图层上使用，否则它缓存方面的好处就会消失，而且会让性能变的更糟。<br>为了检测你是否正确地使用了光栅化方式，可以用 Instrument 的 Core Animation Template 查看一下Color Hits Green and Misses Red<br> 项目，看看是否已光栅化图像被频繁地刷新（这样就说明图层并不是光栅化的好选择，或则你无意间触发了不必要的改变导致了重绘行为）。<br>如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为合适的值。在我们使用 UITableView 和 UICollectionView 时经常会遇到各个 Cell 的样式是一样的，这时候我们可以使用这个属性提高性能：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cell.layer.shouldRasterize = <span class="literal">YES</span>;</span><br><span class="line">cell.layer.rasterizationScale = [[<span class="built_in">UIScreen</span> mainScreen] scale];</span><br></pre></td></tr></table></figure></p><p>但是，如果你的 Cell 是样式不一样，比如高度不定，排版多变，那就要慎重了。</p><p>##选择合适的数据存储方式<br>在 iOS 中可以用来进行数据持有化的方案包括：</p><ul><li>NSUserDefaults。只适合用来存小数据。</li><li>XML、JSON、Plist 等文件。JSON 和 XML 文件的差异在「选择正确的数据格式」已经说过了。</li><li>使用 NSCoding 来存档。NSCoding 同样是对文件进行读写，所以它也会面临必须加载整个文件才能继续的问题。</li><li>使用 SQLite 数据库。可以配合 <a href="https://github.com/ccgus/fmdb" target="_blank" rel="noopener">FMDB</a> 使用。数据的相对文件来说还是好处很多的，比如可以按需取数据、不用暴力查找等等。</li><li>使用 CoreData。也是数据库技术，跟 SQLite 的性能差异比较小。但是 CoreData 是一个对象图谱模型，显得更面向对象；SQLite 就是常规的 DBMS。</li></ul><h2 id="使用-Autorelease-Pool"><a href="#使用-Autorelease-Pool" class="headerlink" title="使用 Autorelease Pool"></a>使用 Autorelease Pool</h2><p>NSAutoreleasePool 是用来管理一个自动释放内存池的机制。在我们的应用程序中通常都是 UIKit 隐式的自动使用 Autorelease Pool，但是有时候我们也可以显式的来用它。</p><p>比如当你需要在代码中创建许多临时对象时，你会发现内存消耗激增直到这些对象被释放，一个问题是这些内存只会到 UIKit 销毁了它对应的 Autorelease Pool 后才会被释放，这就意味着这些内存不必要地会空占一些时间。这时候就是我们显式的使用 Autorelease Pool 的时候了，一个示例如下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *urls = &lt;<span class="meta"># An array of file URLs #&gt;;for (NSURL *url in urls) &#123; </span></span><br><span class="line">      <span class="keyword">@autoreleasepool</span> &#123; </span><br><span class="line">             <span class="built_in">NSError</span> *error;</span><br><span class="line">             <span class="built_in">NSString</span> *fileContents = [<span class="built_in">NSString</span>  stringWithContentsOfURL:url</span><br><span class="line">                                                                encoding:<span class="built_in">NSUTF8StringEncoding</span></span><br><span class="line">                                                                   error:&amp;error];</span><br><span class="line"> <span class="comment">/* Process the string, creating and autoreleasing more objects. */</span> </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码在每一轮迭代中都会释放掉临时对象，从而缓解内存压力，提高性能。</p><p>##imageNamed 和 imageWithContentsOfFile<br>在 iOS 应用中加载图片通常有 - [UIImage imageNamed:]<br> 和 -[UIImage imageWithContentsOfFile:]<br> 两种方式。它们的不同在于前者会对图片进行缓存，而后者只是简单的从文件加载文件。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"myImage"</span>]; <span class="comment">// caching</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="built_in">UIImage</span> *img = [<span class="built_in">UIImage</span> imageWithContentsOfFile:<span class="string">@"myImage"</span>]; <span class="comment">// no caching</span></span><br></pre></td></tr></table></figure></p><p>在整个程序运行的过程中，当你需要加载一张较大的图片，并且只会使用它一次，那么你就没必要缓存这个图片，这时你可以使用 -[UIImage imageWithContentsOfFile:]<br>，这样系统也不会浪费内存来做缓存了。当然，如果你会多次使用到一张图时，用 - [UIImage imageNamed:]<br> 就会高效很多，因为这样就不用每次都从硬盘上加载图片了。</p><p>##避免使用 NSDateFormatter</p><p>在前文中，我们已经讲到了通过复用或者单例来提高 NSDateFormatter 这个高开销对象的使用效率。但是如果你要追求更快的速度，你可以直接使用 C 语言替代 NSDateFormatter 来解析 date，你可以看看这篇文章：<a href="http://blog.soff.es/how-to-drastically-improve-your-app-with-an-afternoon-and-instruments" target="_blank" rel="noopener">link</a>，其中展示了解析 ISO-8601 date string 的代码，你可以根据你的需求改写。完成的代码见：<a href="https://github.com/samsoffes/sstoolkit/blob/master/SSToolkit/NSDate%2BSSToolkitAdditions.m" target="_blank" rel="noopener">SSToolkit/NSDate+SSToolkitAdditions.m</a>。<br>当然，如果你能够控制你接受到的 date 的参数的格式，你一定要尽量选择 Unix timestamps<br> 格式，这样你可以使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSDate</span>*)dateFromUnixTimestamp:(<span class="built_in">NSTimeInterval</span>)timestamp &#123; </span><br><span class="line">           <span class="keyword">return</span> [<span class="built_in">NSDate</span> dateWithTimeIntervalSince1970:timestamp];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样你可以轻松的将时间戳转化为 NSDate 对象，并且效率甚至高于上面提到的 C 函数。<br>需要注意的是，很多 web API 返回的时间戳是以<strong>毫秒</strong>为单位的，因为这更利于 Javascript 去处理，但是上面代码用到的方法中 NSTimeInterval 的单位是<strong>秒</strong>，所以当你传参的时候，记得先除以 1000。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-性能提升总结&quot;&gt;&lt;a href=&quot;#iOS-性能提升总结&quot; class=&quot;headerlink&quot; title=&quot;iOS 性能提升总结&quot;&gt;&lt;/a&gt;iOS 性能提升总结&lt;/h1&gt;&lt;p&gt;##使用复用机制&lt;/p&gt;
&lt;p&gt;在我们使用 UITableView 和 UI
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 适配 &amp; 开发策略</title>
    <link href="https://hongruqi.github.io/2016/07/16/iOS%20%E9%80%82%E9%85%8D%20&amp;%20%E5%BC%80%E5%8F%91%E7%AD%96%E7%95%A5/"/>
    <id>https://hongruqi.github.io/2016/07/16/iOS 适配 &amp; 开发策略/</id>
    <published>2016-07-15T16:00:00.000Z</published>
    <updated>2019-02-22T07:45:37.349Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-适配-amp-开发策略"><a href="#iOS-适配-amp-开发策略" class="headerlink" title="iOS 适配 &amp; 开发策略"></a>iOS 适配 &amp; 开发策略</h1><h2 id="屏幕尺寸适配"><a href="#屏幕尺寸适配" class="headerlink" title="屏幕尺寸适配"></a>屏幕尺寸适配</h2><hr><p> 2007 年，初代 iPhone发布，其拥有 3.5寸屏幕，运行 iPhone OS X。在后续几年中Apple 陆续发布了 iPhone 3GS，iPhone 4，iPhone 4S，iPhone 5C，iPhone 5S，iPhone 6，iPhone 6 Plus，iPhone 6S、iPhone 6S Plus，iPhoneSE ，iPhone7，iPhone7 Plus, 2017年9月将发布iphone 8。其运行的操作系统也从 iOS 4、iOS 5、iOS 6、iOS 7 、iOS 8， iOS 9，iOS10，iOS11。随着新版 iPhone，新版iOS操作系统的上市，随着维护的iPhone和IOS版本增多，如何确保 App适配新版iPhone及iOS操作系统？而这又是必须解决的问题，否则App将丧失新版iPhone新版iOS 系统上的用户，从而带来巨大的损失。<br>        Apple 提供的解决方案之一就是：引入了点(point)的概念。在 iPhone 3GS 中, 1个点对应1个像素，点和像素两者在数值上是一致的。在iPhone 4/4S中，虽然机型变化，其荧幕宽高像素点增加了，但是其宽高点坐标是不变的。所以在开发过程中可以使用点绝对坐标，用来确定视图的位置。同时提供两套图片: ~.png 和 <a href="mailto:~@2x.png" target="_blank" rel="noopener">~@2x.png</a>。 iOS 系统将根据 iPhone 的像素来自动决定使用哪一张图片。 </p><table><thead><tr><th>机型</th><th>屏幕尺寸</th><th>屏幕宽高（像素）</th><th>屏幕宽高（点）</th><th>模式</th></tr></thead><tbody><tr><td>iPhone 3GS</td><td>3.5</td><td>320x480</td><td>320 x 480</td><td>1x</td></tr><tr><td>iPhone 4</td><td>3.5</td><td>640 x 960</td><td>320 x 480</td><td>2x</td></tr><tr><td>iPhone 4S</td><td>3.5</td><td>640 x 960</td><td>320 x 480</td><td>2x</td></tr><tr><td>iPhone 5</td><td>4</td><td>640 x 1136</td><td>320 x 568</td><td>2x</td></tr><tr><td>iPhone 5C</td><td>4</td><td>640 x 1136</td><td>320 x 568</td><td>2x</td></tr><tr><td>iPhone 5S</td><td>4</td><td>640 x 1136</td><td>320 x 568</td><td>2x</td></tr><tr><td>iPhone 5SE</td><td>4</td><td>640 x 1136</td><td>320 x 568</td><td>2x</td></tr><tr><td>iPhone 6</td><td>4.7</td><td>750 x 1134</td><td>375 x 667</td><td>2x</td></tr><tr><td>iPhone 6 Plus</td><td>5.5</td><td>1080 x 1920</td><td>414 x 736</td><td>2.6x</td></tr><tr><td>iPhone 6S</td><td>4.7</td><td>750 x 1134</td><td>375 x 667</td><td>2x</td></tr><tr><td>iPhone 6S Plus</td><td>5.5</td><td>1080 x 1920</td><td>414 x 736</td><td>2.6x</td></tr><tr><td>iPhone 7</td><td>4.7</td><td>750 x 1134</td><td>375 x 667</td><td>2x</td></tr><tr><td>iPhone 7 Plus</td><td>5.5</td><td>1080 x 1920</td><td>414 x 736</td><td>2.6x</td></tr></tbody></table><p> 在iPhone5/5C/5S中，其荧幕，像素以及点，都已经发生变化。相比iPhone4/4S, 其荧幕宽度不变，高度增加88个点。在这种情况下，就不能再使用绝对坐标，否则将导致程序高度不够。如果App没有对其做适配处理，iOS 将对88个点均分为上下两部分，荧幕上下各出现44个点的黑边。在不同机型上，荧幕点坐标改变了，于是再也不能使用绝对坐标。为了彻底解决这个问题，iOS提出了一种新技术AutoLayout。使用AutoLayout技术，将不使用绝对坐标，而是指定View，button，TextField之间的相对位置，比如靠左多少，靠右多少，相距多少等。通过指定这一系列的约束条件，AutoLayout在荧幕上自动的画出对应布局。在iPhone5/5C/5S中，由于像素：点的比例仍为2，所以将直接使<a href="mailto:~@2x.png" target="_blank" rel="noopener">~@2x.png</a> 图片即可。如果没有提供<a href="mailto:~@2x.png" target="_blank" rel="noopener">~@2x.png</a>的图片，那么就直接使用~.png的图片覆盖同样的点。虽然点的数量一样，但是像素点却多了1倍，以致在这种情况下，图片显示会比较模糊。在iPhone6面世后，其荧幕大小坐标已经变化，宽，高都增加了。但是宽，高比不变，为9:16。而且其像素：点比仍然为2。在2x和3x的图片都不太合适。iOS的解决方案是：现有的银幕分辨率明显超过2x但没有达到3x，于是想象一个满足3x的银幕总可以吧?<br>        于是App在iPhone 6 Plus上运行的时候，iOS会骗App说，App现在运行在一个 3x的荧幕上，其像素为1242x2208，点为414 x 736，而且都比iPhone 6要大。于是程序设计师和UED也按照3x来设计。UED 提供 3x 的高清图片，程序设计师依据414 x 736 来编写App。但是借来的总是要还的。iOS 在拿到这个假想 1242x2208 的绘制结果，再缩小到实际 1080 x 1920 荧幕来画图（通过某种缩小算法)。于是在 iPhone 6 Plus荧幕上看到的永远是缩小的图像。通过3x模式,使得设计开发过程得到了大大的简化。</p><p>##CPU 指令集<br>| 机型 | ARM 架构|<br>| ——| —— |<br>| iPhone 3GS | ARM V6|<br>| iPhone 4 | ARM V7|<br>| iPhone 4S | ARM V7|<br>| iPhone 5 | ARM V7S|<br>| iPhone 5C | ARM V7S|<br>| iPhone 5S | ARM V8(64)|<br>| iPhone 6 | ARM V8(64)|<br>| iPhone 6 Plus | ARM V8(64)|<br>| iPhone 6S | ARM V8(64)|<br>| iPhone 6S Plus | ARM V8(64)|<br>| iPhone 5SE  | ARM V8(64)|<br>| iPhone 7 | ARM V8(64)|<br>| iPhone 7 Plus | ARM V8(64)|</p><p>指令集是向后兼容的。比如ARMV7S指令集下生成的二进制包，可以运行在iPhone 6上，只是有些优化不可用，效率没有那么高而已。反之，ARM V8生成的二进制包, 就不能在 ARM V7S的iPhone 5上。 在编译二进制包的时候，需要确认其所能支持的ARM架构。如果希望App在各版iPhone上都能够高效运行，则需要将Build Active Architecture Only改为NO，Valid architectures选择对应的指令集：ARM V7 ARM V7S ARM 8。为各个指令集编译对应的代码，因此最后的ipa包的体积基本翻了3倍。如果希望App体积保持最小, 则现阶段应该选Valid architectures为ARM V7，这样Build Active Architecture Only选YES或NO就无所谓了。在ARM V8上，最明显的一个区别就是支持64-bit。于是在iOS上的数据类型发生了变化。数据长度的改变给App带来的影响之一就是: 当把一个值从大的数据类型拷贝到小的数据类型，数据可能被截断，例如从NSInteger 转换到int。</p><p><img src="http://upload-images.jianshu.io/upload_images/901318-d53902919c7842c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.png"><br>Architecture ：指你想支持的指令集。Valid architectures ：指即将编译的指令集。Build Active Architecture Only : 只是否只编译当前适用的指令集。</p><p><img src="http://upload-images.jianshu.io/upload_images/901318-c0bfe38c8bc650fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.png"></p><p>##iOS 系统<br>每次iPhone机型的升级，往往同时伴随着新版iOS系统的发布。最开始的iPhone OSX，其创新的多点触控操作和极简的用户体验受到了用户的追捧。虽然初代的系统还存在各种各样的问题，比如无法复制粘贴等，但是它开启了移动设备操作系统的新时代。随着iOS 4增加了对Retina和多任务的支持，iOS 5带来了Siri 语音助手，iOS 6引入了全新的地图，iOS 7全新的扁平化图标界面设计，到iOS 8开始支持的Touch ID，iOS 9 Watch OS 2、App Thinning、3D Tought、分屏多任务，iOS系统在不断的更新(当然每次iOS系统的迭代更新，其对应的SDK也被推向开发人员)。发布上线的 App，必须考虑到对不同版本iOS系统的适配。因为在某一个特定时间点，并不是所有的用户都在最新版本的操作系统，比如有些用户在使用iOS 8，但总还是有一些用户停留在iOS 7,iOS 6甚至iOS 5。举例来说,相对 iOS 7 而言,iOS 8 中对内置相机做了改动—-自由调节进光量，在拍摄中，触摸屏幕对好焦点后，会在对焦框旁边出现进光量调节轴，增加或降低拍摄的曝光量，从而不必因为光的问题频繁找焦点测光了。值得注意的是:：App AliExpress.com使用了调用了iOS拍照的功能，且其在iOS 7上工作中正常。在安装该App的iPhone升级为iOS 8之后，需要验证App的拍照功能是否工作正常, 确认其没有受到 iOS 8 拍照功能改动的影响。与之类似,和 iOS 7相比，iOS 8还有一些新功能，比如开放支持第三方输入法；锁屏推送中直接操作，而并不需要打开信息应用；多人群聊，实时位置共享，还可以发送语音和视频消息。根据这些iOS 8新功能，评估其对App风险。再而一一测试App上对应的功能。只有这些点都被测试通过之后，才能够宣布该App已经适配了iOS 8。</p><table><thead><tr><th>iOS系统</th><th>iOS各版本市场占比</th><th>与前版本主要不同之处</th></tr></thead><tbody><tr><td>iOS 7</td><td>&lt; 8%</td><td>1. 重新设计的视觉界面,扁平化文件系统</td></tr><tr><td></td><td></td><td>2. 全新的控制中心从下侧边缘滑出控制中心</td></tr><tr><td></td><td></td><td>3. 全新的MultiTasking设计，App预览及App关闭方式</td></tr><tr><td></td><td></td><td>4. 通知中心，锁屏下可以查看推送</td></tr><tr><td></td><td></td><td>5. Safari 升级，包括支持全荧幕浏览，左右切换等</td></tr><tr><td></td><td></td><td>6.其他多项新功能</td></tr><tr><td>iOS 8</td><td>15%</td><td>1. 相机延时拍照，进光量调节</td></tr><tr><td></td><td></td><td>2. QuickType及第三方输入法</td></tr><tr><td></td><td></td><td>3. 交互式通知中心</td></tr><tr><td></td><td></td><td>4. Safari升级，向外切换到书签，分享链接</td></tr><tr><td></td><td></td><td>5. 即时聊天，群聊，位置分享，分享视频等</td></tr><tr><td></td><td></td><td>6.  其他多项新功能</td></tr><tr><td>iOS 9</td><td>77%</td><td>1. 3D Tought</td></tr><tr><td></td><td></td><td>2.应用内搜索</td></tr><tr><td></td><td></td><td>3.  App Watch OS 2.0支持</td></tr><tr><td></td><td></td><td>4. BitCode App瘦身</td></tr><tr><td></td><td></td><td>5.  App Transport Security（ATS)</td></tr><tr><td>iOS 9</td><td>77%</td><td>1. 3D Tought</td></tr><tr><td></td><td></td><td>2.应用内搜索</td></tr><tr><td></td><td></td><td>3.  App Watch OS 2.0支持</td></tr><tr><td></td><td></td><td>4. BitCode App瘦身</td></tr><tr><td></td><td></td><td>5.  App Transport Security（ATS)</td></tr></tbody></table><p>##开发策略<br>了解iPhone设备，iOS系统的适配原理，有益于App的开发。<br>在App开发阶段，将适配性作为代码的规范之一。从而能够在源头改善代码质量，提高App质量，降低App适配风险。其指导性策略如下:<br>1、布局相关：不使用绝对坐标，建议使用第三方（Masonry）进行相对位置设置。<br>2、通过点的概念，而不使用像素，来统一思考不同机器上的适配，为适配创造良好的基础。 比如要在view里面画一个44x44个点的按钮，2x模式，就乘以2，3x模式就乘以3。<br>3、调用系统API之前，需要考虑iOS的版本。<br>4、特定的API在不同iOS版本中，其功能，参数，返回数据可能有所不同。这些数据在对应的SDK中可以找到详情。所以在使用这些API之前，需要对这些功能, 参数，返回数据进行特殊处理。<br>5、iOS的某些特定版本，自身也存在一些bug。这些bug的详情在Apple Inc.官网<a href="http://www.apple.com中iOS的release" target="_blank" rel="noopener">www.apple.com中iOS的release</a> document中有披露。在App设计中，要避免踩到iOS特定版本自身的 bug。</p><p>##测试策略<br>依据上述的iPhone机型市场占比可以对其适配性专项进行优先级排序。市场占比最多的iPhone 5S，iPhone 6的优先级别最高，依次为 iPhone 5／5C，iPhone 6 Plus等。优先级别最低为iPhone 4S。在这些级别中，主要注意机型之间不同尺寸荧幕所带来的差别，包括分辨率，像素的不同。在App安装到这些机型上面后，其UI应该拉升或者压缩到满荧幕，不得出现空白区域或者某些部分不能显示。UI所对应的功能，与硬件相隔离，而一一工作正常。在编译二进制包而选择指令集，其包在跨机型上工作正常，App对指令集兼容。</p><p>App 在不同尺寸/分辨率/像素的荧幕手机下，其UI拉升压缩满整屏幕，视觉显示正常，对应功能正常。<br>基于不同指令集下编译的包，安装在跨机型上工作正常。<br>       在iOS系统适配方面，根据各个iOS系统的改动功能点，和App上与之对应的相关功能, 一一评估其风险并验证。其中iOS 7和iOS 8之间的系统差异特别明显，需要特别关注。在App的适配测试中，需要同时考虑 iPhone和iOS系统两个维度，建议从代码层面深层次的分析问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-适配-amp-开发策略&quot;&gt;&lt;a href=&quot;#iOS-适配-amp-开发策略&quot; class=&quot;headerlink&quot; title=&quot;iOS 适配 &amp;amp; 开发策略&quot;&gt;&lt;/a&gt;iOS 适配 &amp;amp; 开发策略&lt;/h1&gt;&lt;h2 id=&quot;屏幕尺寸适配&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>Bonjour！实现零配置网络联网的解决方案</title>
    <link href="https://hongruqi.github.io/2016/07/16/Bonjour%EF%BC%81%E5%AE%9E%E7%8E%B0%E9%9B%B6%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E8%81%94%E7%BD%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://hongruqi.github.io/2016/07/16/Bonjour！实现零配置网络联网的解决方案/</id>
    <published>2016-07-15T16:00:00.000Z</published>
    <updated>2019-02-22T07:49:26.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bonjour！实现零配置网络联网的解决方案"><a href="#Bonjour！实现零配置网络联网的解决方案" class="headerlink" title="Bonjour！实现零配置网络联网的解决方案"></a>Bonjour！实现零配置网络联网的解决方案</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>简单介绍一下项目对本地网络连接的需求：车机连接移动设备。</p><p>那我们如何进行连接呢。</p><ol><li><p>首先我们想到的最简单的方法就是通过IP连接。</p></li><li><p>UDP广播。</p></li></ol><p>利用UDP广播我们能向同一本地网络所有设备发送一条消息,接收到信息后我们能够解析出发送方的端口和IP。</p><p>问题：</p><ol><li>耗电问题。不断的UDP Broadcast 会耗费大量电源。</li><li>网络阻塞问题。因为UDP广播会对同一本地网络的所有Host都发送信息。过于密集的发送,有可能会造成网络的堵塞。</li><li>稳定性,UDP Socket可能会因为各种情况而中断。</li></ol><h3 id="什么是-Bonjour"><a href="#什么是-Bonjour" class="headerlink" title="什么是 Bonjour ?"></a>什么是 Bonjour ?</h3><p><strong>bonjour</strong> 是苹果公司发布的一个基于 <strong>ZEROCONF</strong> 工作组 <strong>(IETF</strong>下属小组) 的工作,用于实现零配置网络联网的解决方案。<strong>Bonjour</strong>是基于<strong>IP</strong>层协议的。</p><p>Bonjour是Apple推出的零配置网络协议，主要的目的是在缺少中心服务器的情况下解决网络设备的IP获取，名称解析和服务发现等关键问题。</p><h3 id="Bonjour可以做什么"><a href="#Bonjour可以做什么" class="headerlink" title="Bonjour可以做什么"></a>Bonjour可以做什么</h3><hr><p> Bonjour可以完成的工作主要是在缺少中心服务器的情况下解决IP获取，名称解析和服务发现这三个问题。</p><ul><li>IP获取<br>在传统网络环境下，设备的IP地址通过两种方式获取，一种是静态配置，通过手工方式为设备指定一个IP地址，一种是动态配置，设备通过路由器的DHCP服务获得动态的IP地址。<br>在无中心服务器的网络环境下，没有中心服务器提供DHCP服务，用户手工配置IP地址也很不方便，这就需要一种新的方式来帮助设备获取IP地址，就是希望设备可以主动为自己指定一个可用的IP地址。<br>在IPV6环境下，IPV6协议本身就提供了设备自指定IP地址的能力，所以实现很简单，直接使用IPV6的协议支持就可以了。<br>在IPV4环境下，Bonjour使用了随机指定IP地址的方法，首先为设备随机指定一个属于本地网段的IP地址，然后检查该地址在本地是否有冲突，如果有冲突就随机生成另一个新的IP地址，直到找到可用IP地址为止。<br>我在做测试的时候没有测试这部分，都是使用的DHCP的动态地址。以后有时间测试了这个部分后再和大家分享测试结果。</li><li><strong><em>**</em></strong>名称解析<strong><em>**</em></strong><br>在传统网络环境下，名称和IP地址的对应关系是通过DNS服务解析的。当一个设备需要访问一个域名，如“<a href="http://www.abc.com”，设备将“www.abc.com”发给DNS服务器，服务器返回该域名对应的IP地址，设备再使用返回的IP地址对目标服务器进行访问。" target="_blank" rel="noopener">www.abc.com”，设备将“www.abc.com”发给DNS服务器，服务器返回该域名对应的IP地址，设备再使用返回的IP地址对目标服务器进行访问。</a><br>在没有中心服务器的网络环境中，没有DNS服务器提供域名解析服务，名称解析变成一个严重问题。针对这一问题，业界的解决方案是mDNS，中文叫“组播DNS”，在标准文档RFC6762中定义。<br>“组播DNS”的原理很简单，当一个设备需要解析一个名称时，如“abc.local”，这个设备通过UDP协议向本地网络中的所有设备广播一个消息，问谁是“abc.local”，本地网络中如果有一个设备认为自己是“abc.local”，它就给出响应，说出自己的IP地址。<br>因为“组播DNS”基于UDP协议，采用广播消息的方式，所以不需要一个中心服务器提供DNS解析服务就可以完成本地的名称解析。<br>Bonjour也是基于mDNS协议的，不过Bonjour在mDNS协议上作了扩展，加强了设备响应“组播DNS”请求的能力。在Bonjour协议下，应用只需要对某个名称进行注册，就可以将响应“组播DNS”请求的工作交由底层处理。也就是说在Bonjour协议下，应用不需要侦听本地网络的“组播DNS”请求并进行响应，这些工作由底层系统完成。<br>为了区分全球域名和本地域名，mDNS协议使用“.local.”作为本地域名的根域名。</li><li><strong><em>**</em></strong>服务搜索（自动在网络搜索服务）<strong><em>**</em></strong><br>当一个提供服务的设备获取IP地址，并自我指定一个域名后，其实还是不能满足用户的需求。因为用户需要的是某种服务，如打印服务，web服务，用户并不关心这些服务对应的服务器名称和它的IP地址。<br>为了让用户更容易发现本地网络中的各种服务，Bonjour为设备提供了服务发现的能力。<br>Bonjour提供的“服务发现”能力基于一个简单直接的规定，就是提供服务的设备在按以下标准对服务进行注册：“名称.服务类型.传输协议类型.local.”，比如：“DamonWebServer._http._tcp.local.”，又比如“DummiesWebServer._http._tcp.local.”。<br>这样，当一个设备使用希望查找http服务的时候，Bonjour会去查找本地网络中注册过的包含”_http”的服务，然后将结果返回给用户选择。这时用户面对的是“DamonWebServer”和”DummiesWebServer”，用户可以不去关心到底这两个web服务到底在那台设备上，该设备的IP地址是什么。<br>###如何使用Bonjour</li></ul><hr><p> 对于最终用户来讲，Bonjour基本上是透明的，他们不需要了解如何去使用Bonjour，往往都是应用开发者去考虑如何使用Bonjour。<br> 对于应用开发者来讲，他们需要考虑有两部分，一是如何作为Bonjour客户端去发现使用本地服务，二是如何作为服务端如何注册Bonjour服务</p><ul><li>如何作为Bonjour客户端去发现本地服务<br>iOS开发可以使用NSNetService框架中的NSNetServiceBrowser类去发现本地服务。<br>基本过程如下：<br>首先创建NSNetServiceBrowser实例：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    serviceBrowser = [[NSNetServiceBrowser alloc] init]<span class="comment">;</span></span><br><span class="line">    serviceBrowser.delegate = self<span class="comment">;</span></span><br><span class="line">    [serviceBrowser searchForServicesOfType:@<span class="string">"_http._tcp."</span> inDomain:@<span class="string">"local."</span>]<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)<span class="string">netServiceBrowser:</span>(NSNetServiceBrowser *)netServiceBrowser <span class="string">didFindService:</span>(NSNetService *)netService <span class="string">moreComing:</span>(BOOL)moreServicesComing &#123;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure><ul><li><p>如何作为服务端注册Bonjour服务<br>要注册成为Bonjour服务，开发者可以直接创建NSNetService实例，<br>并通过initwithDomain:type:name:port:方法进行初始化，指定服务的域，类型，名称和端口，样例代码如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in"> service </span>= [[NSNetService alloc] initWithDomain:@<span class="string">"local."</span> type:@<span class="string">"_http._tcp."</span> name:@<span class="string">"DamonWebServer"</span> port:port];</span><br></pre></td></tr></table></figure><p>NSNetService创建成功后，可以通过setDelegate指定代理，同时通过publish方法发布注册服务：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">        [service setDelegate:self]</span><span class="comment">;</span></span><br><span class="line"><span class="section">        [service publish]</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ul><p> 其中指定的代理需要遵从“NSNetServiceDelegate”协议，可以对服务发布成功，发布失败等事件。</p><p> 正常来讲，如果需要发布一个服务，需要在发布服务之前准备好服务并启动它。不过NSNetService的publish方法并不依赖它所发布的服务，不管服务是否准备好，是否启动，NSNetService的publish都可以成功将服务发布出去，只不过服务发布出去后其它使用这个服务的客户端会发现这个发布出来的服务是个无效服务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bonjour！实现零配置网络联网的解决方案&quot;&gt;&lt;a href=&quot;#Bonjour！实现零配置网络联网的解决方案&quot; class=&quot;headerlink&quot; title=&quot;Bonjour！实现零配置网络联网的解决方案&quot;&gt;&lt;/a&gt;Bonjour！实现零配置网络联网的解决
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 降低线上版本Crash率</title>
    <link href="https://hongruqi.github.io/2016/07/11/%5BIOS%20%E9%98%B2%E6%AD%A2Crash%20%E7%BB%84%E4%BB%B6WTSafeGuard%20%5D(https---github.com-hongruqi-SafeGuard)/"/>
    <id>https://hongruqi.github.io/2016/07/11/[IOS 防止Crash 组件WTSafeGuard ](https---github.com-hongruqi-SafeGuard)/</id>
    <published>2016-07-10T16:00:00.000Z</published>
    <updated>2019-02-22T07:58:32.890Z</updated>
    
    <content type="html"><![CDATA[<p>#iOS 降低线上版本Crash率 </p><h3 id="IOS-防止Crash-组件WTSafeGuard"><a href="#IOS-防止Crash-组件WTSafeGuard" class="headerlink" title="IOS 防止Crash 组件WTSafeGuard "></a><a href="https://github.com/hongruqi/SafeGuard" target="_blank" rel="noopener">IOS 防止Crash 组件WTSafeGuard </a></h3><p>##背景<br>由于Object-C本身的不安全性，导致很容易产生Crash。在这些Crash，很多我们可以利用自定义手段，进行避免。这样可以降低线上版本的Crash率，提升用户<br>体验。WTSafeGuard 避免APP Crash 组件，目前能做到的还很有限。</p><h3 id="UIKit-Called-on-Non-Main-Thread"><a href="#UIKit-Called-on-Non-Main-Thread" class="headerlink" title="UIKit Called on Non-Main Thread"></a>UIKit Called on Non-Main Thread</h3><p>UIKit不是线程安全的，执行UIKit操作如果不在主线程很可能造成程序Crash。所以我们对Hook，UIView 的setNeedsLayout，layoutIfNeeded，layoutSubviews，setNeedsUpdateConstraints方法。如果执行以上函数没有在主队列，通过强行将执行代码，在主队列执行。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)wt_safe_setNeedsLayout</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_setNeedsLayout failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_setNeedsLayout];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_setNeedsLayout];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wt_safe_layoutIfNeeded</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_layoutIfNeeded failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_layoutIfNeeded];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_layoutIfNeeded];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wt_safe_layoutSubviews</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_layoutSubviews failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_layoutSubviews];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_layoutSubviews];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)wt_safe_setNeedsUpdateConstraints</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="built_in">NSThread</span> isMainThread])&#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSAssert</span>(<span class="literal">false</span>, <span class="string">@"wt_safe_setNeedsUpdateConstraints failed"</span>);</span><br><span class="line">            [<span class="keyword">self</span> wt_safe_setNeedsUpdateConstraints];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        [<span class="keyword">self</span> wt_safe_setNeedsUpdateConstraints];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##避免 Foundation 类Carsh</p><p>###NSString<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)stringWithUTF8String:(<span class="keyword">const</span> <span class="keyword">char</span> *)bytes</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithUTF8String:(<span class="keyword">const</span> <span class="keyword">char</span> *)nullTerminatedCString</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithFormat:(<span class="built_in">NSString</span> *)format locale:(<span class="keyword">id</span>)locale arguments:(va_list)argList</span><br><span class="line">- (<span class="built_in">NSString</span> *)stringByAppendingString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">unichar</span>)characterAtIndex:(<span class="built_in">NSUInteger</span>)index</span><br><span class="line">- (<span class="keyword">void</span>)getCharacters:(<span class="keyword">unichar</span> *)buffer range:(<span class="built_in">NSRange</span>)range</span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfCharacterFromSet:(<span class="built_in">NSCharacterSet</span>  *)searchSet </span><br><span class="line">                            options:(<span class="built_in">NSStringCompareOptions</span>)mask</span><br><span class="line">                              range:(<span class="built_in">NSRange</span>)searchRange</span><br><span class="line">                                    </span><br><span class="line">- (<span class="built_in">NSRange</span>)rangeOfString:(<span class="built_in">NSString</span> *)searchString</span><br><span class="line">                options:(<span class="built_in">NSStringCompareOptions</span>)mask</span><br><span class="line">                  range:(<span class="built_in">NSRange</span>)searchRange</span><br><span class="line">                 locale:(<span class="built_in">NSLocale</span> *)locale</span><br><span class="line">- (<span class="built_in">NSString</span> *)substringFromIndex:(<span class="built_in">NSUInteger</span>)from</span><br><span class="line">- (<span class="built_in">NSString</span> *)substringWithRange:(<span class="built_in">NSRange</span>)range</span><br><span class="line">- (<span class="built_in">NSString</span> *)substringToIndex:(<span class="built_in">NSUInteger</span>)to</span><br><span class="line">- (<span class="keyword">void</span>)getLineStart:(<span class="built_in">NSUInteger</span> *)startPtr   </span><br><span class="line">                 end:(<span class="built_in">NSUInteger</span> *)lineEndPtr                                         </span><br><span class="line">                 contentsEnd:(<span class="built_in">NSUInteger</span> *)contentsEndPtr</span><br><span class="line">                   forRange:(<span class="built_in">NSRange</span>)range</span><br></pre></td></tr></table></figure></p><h3 id="NSAttributedString"><a href="#NSAttributedString" class="headerlink" title="NSAttributedString"></a>NSAttributedString</h3><p>hook 方法：对传入参数range 进行check，如果range有问题，直接返回nil</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSAttributedString</span> *)attributedSubstringFromRange:(<span class="built_in">NSRange</span>)range;</span><br></pre></td></tr></table></figure><h3 id="NSFileManager"><a href="#NSFileManager" class="headerlink" title="NSFileManager"></a>NSFileManager</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDirectoryEnumerator</span>&lt;<span class="built_in">NSURL</span> *&gt; *)enumeratorAtURL:(<span class="built_in">NSURL</span> *)url includingPropertiesForKeys:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURLResourceKey</span>&gt; *)keys options:(<span class="built_in">NSDirectoryEnumerationOptions</span>)mask errorHandler:(<span class="keyword">nullable</span> <span class="built_in">BOOL</span> (^)(<span class="built_in">NSURL</span> *url, <span class="built_in">NSError</span> *error))handler</span><br></pre></td></tr></table></figure><p>###NSIndexPath<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getIndexes:(<span class="built_in">NSUInteger</span> *)indexes range:(<span class="built_in">NSRange</span>)positionRang</span><br></pre></td></tr></table></figure></p><p>###NSJSONSerialization<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSData</span> *)dataWithJSONObject:(<span class="keyword">id</span>)obj options:(<span class="built_in">NSJSONWritingOptions</span>)opt error:(<span class="built_in">NSError</span> **)error</span><br></pre></td></tr></table></figure></p><h3 id="NSDictionary"><a href="#NSDictionary" class="headerlink" title="NSDictionary"></a>NSDictionary</h3><p>hook 方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedKeySetForKeys:(<span class="built_in">NSArray</span>&lt;KeyType &lt;<span class="built_in">NSCopying</span>&gt;&gt; *)keys</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjects:(<span class="keyword">const</span> ObjectType _Nonnull [_Nullable])objects forKeys:(<span class="keyword">const</span> KeyType &lt;<span class="built_in">NSCopying</span>&gt; _Nonnull [_Nullable])keys</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithObjects:(<span class="keyword">const</span> ObjectType _Nonnull [_Nullable])objects forKeys:(<span class="keyword">const</span> KeyType &lt;<span class="built_in">NSCopying</span>&gt; _Nonnull [_Nullable])keys count:(<span class="built_in">NSUInteger</span>)cnt</span><br></pre></td></tr></table></figure><h3 id="NSMutableDictionary"><a href="#NSMutableDictionary" class="headerlink" title="NSMutableDictionary"></a>NSMutableDictionary</h3><p>hook 方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMutableDictionary</span>&lt;KeyType, ObjectType&gt; *)dictionaryWithSharedKeySet:(<span class="keyword">id</span>)keyset</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(ObjectType)anObject forKey:(KeyType &lt;<span class="built_in">NSCopying</span>&gt;)aKey;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(KeyType)aKey;</span><br></pre></td></tr></table></figure><p>###NSSet<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)WT_initWithObjects:(<span class="keyword">const</span> <span class="keyword">id</span> [])objects count:(<span class="built_in">NSUInteger</span>)cnt</span><br><span class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)object;</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformSelector:(SEL)aSelector</span><br><span class="line">- (<span class="keyword">void</span>)makeObjectsPerformSelector:(SEL)aSelector</span><br><span class="line">                        withObject:(<span class="keyword">id</span>)argument</span><br></pre></td></tr></table></figure></p><p>###NSMutableSet<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObject</span><br></pre></td></tr></table></figure></p><p>###NSMutableString<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">void</span>)appendString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">- (<span class="keyword">void</span>)deleteCharactersInRange:(<span class="built_in">NSRange</span>)range</span><br><span class="line">- (<span class="keyword">void</span>)insertString:(<span class="built_in">NSString</span> *)aString atIndex:(<span class="built_in">NSUInteger</span>)loc</span><br><span class="line">- (<span class="keyword">void</span>)replaceCharactersInRange:(<span class="built_in">NSRange</span>)range withString:(<span class="built_in">NSString</span> *)aString</span><br><span class="line">-  (<span class="built_in">NSUInteger</span>)replaceOccurrencesOfString:(<span class="built_in">NSString</span> *)target</span><br><span class="line">                                     withString:(<span class="built_in">NSString</span> *)replacement</span><br><span class="line">                                        options:(<span class="built_in">NSStringCompareOptions</span>)options</span><br><span class="line">                                          range:(<span class="built_in">NSRange</span>)searchRange</span><br></pre></td></tr></table></figure></p><p>###NSURL<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPath:(<span class="built_in">NSString</span> *)path isDirectory:(<span class="built_in">BOOL</span>)isDir</span><br><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPathComponents:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)components</span><br><span class="line">+ (<span class="built_in">NSURL</span> *)fileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                      isDirectory:(<span class="built_in">BOOL</span>)isDir</span><br><span class="line">                    relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithString:(<span class="built_in">NSString</span> *)URLString relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br><span class="line">- (<span class="keyword">instancetype</span>)initFileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">- (<span class="keyword">instancetype</span>)initFileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                             relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br><span class="line">- (<span class="keyword">instancetype</span>)initFileURLWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">                               isDirectory:(<span class="built_in">BOOL</span>)isDir</span><br><span class="line">                             relativeToURL:(<span class="built_in">NSURL</span> *)baseURL</span><br></pre></td></tr></table></figure></p><ol start="2"><li>KVO</li><li>容器越界（NSArray， NSDictionary,…）</li><li>unrecognized selector crash (这个很多时候是由于class使用错误导致)</li><li>NSTimer 导致crash</li></ol><hr><h3 id="KVO-Crash"><a href="#KVO-Crash" class="headerlink" title="KVO Crash"></a>KVO Crash</h3><p>项目中KVO crash 占比很高， 主要原因为，添加删除不对称导致。<br>解决方法为，添加Map进行缓存。<br>不过这个方案，目前还有缺陷。</p><h3 id="unrecognized-selector-crash"><a href="#unrecognized-selector-crash" class="headerlink" title="unrecognized selector crash"></a>unrecognized selector crash</h3><p>这个就比较简单了，直接上代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    [<span class="built_in">NSObject</span> jr_swizzleMethod:<span class="keyword">@selector</span>(forwardingTargetForSelector:) withMethod:<span class="keyword">@selector</span>(WT_safeForwardingTargetForSelector:) error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    - (<span class="keyword">id</span>)WT_safeForwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">self</span> methodSignatureForSelector:aSelector];</span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:aSelector] || signature) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> WT_safeForwardingTargetForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [WTSafeGuard createFakeForwardTargetObject:<span class="keyword">self</span> selector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#iOS 降低线上版本Crash率 &lt;/p&gt;
&lt;h3 id=&quot;IOS-防止Crash-组件WTSafeGuard&quot;&gt;&lt;a href=&quot;#IOS-防止Crash-组件WTSafeGuard&quot; class=&quot;headerlink&quot; title=&quot;IOS 防止Crash 组件WT
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS 音频开发</title>
    <link href="https://hongruqi.github.io/2015/12/01/IOS%20%E9%9F%B3%E9%A2%91%E5%BC%80%E5%8F%91/"/>
    <id>https://hongruqi.github.io/2015/12/01/IOS 音频开发/</id>
    <published>2015-11-30T16:00:00.000Z</published>
    <updated>2019-02-22T07:43:14.407Z</updated>
    
    <content type="html"><![CDATA[<h1 id="iOS-音频开发"><a href="#iOS-音频开发" class="headerlink" title="iOS 音频开发"></a>iOS 音频开发</h1><hr><ul><li>音频基础知识</li><li>音频文件计算大小</li><li>音频转码</li></ul><hr><h2 id="音频基础知识"><a href="#音频基础知识" class="headerlink" title="音频基础知识"></a>音频基础知识</h2><p>###组成<br>音频文件的组成：文件格式(或者音频容器)  + 数据格式(或者音频编码)。</p><p>###文件格式(或音频容器)是用于形容文件本身的格式。</p><p>我们可以通过多种不同的方法为真正的音频数据编码。例如CAF文件便是一种文件格式，它能够包含MP3格式，线性PCM以及其它数据格式的音频。</p><p>###数据格式(或音频编码)<br>我们将从音频编码开始阐述(而不是文件格式)，因为编码是最重要的环节。</p><p>###线性PCM：<br>这是表示线性脉冲编码调制，主要是描写用于将模拟声音数据转换成数字格式的技术。简单地说也就是未压缩的数据。因为数据是未压缩的，所以我们便可以最快速地播放出音频，而如果空间不是问题的话这便是iPhone音频的优先代码选择。</p><p>##音频文件计算大小 ##</p><hr><p>声卡对声音的处理质量可以用三个基本参数来衡量，即采样频率、采样位数和声道数。</p><p>####采样频率:<br>是指单位时间内的采样次数。采样频率越大，采样点之间的间隔就越小，数字化后得到的声音就越逼真，但相应的数据量就越大。声卡一般提供11.025kHz、22.05kHz和44.1kHz等不同的采样频率。</p><p>####采样位数：<br>是记录每次采样值数值大小的位数。采样位数通常有8bits或16bits两种，采样位数越大，所能记录声音的变化度就越细腻，相应的数据量就越大。</p><p>####声道数<br>是指处理的声音是单声道还是立体声。单声道在声音处理过程中只有单数据流，而立体声则需要左、右声道的两个数据流。显然，立体声的效果要好，但相应的数据量要比单声道的数据量加倍。</p><p>####声音数据量的计算公式为：<br>数据量（字节/秒）= (采样频率（Hz）× 采样位数（bit） × 声道数)/ 8</p><p><em>单声道的声道数为1，立体声的声道数为2。</em></p><p>【例1】请计算对于5分钟双声道、16位采样位数、44.1kHz采样频率声音的不压缩数据量是多少？<br>根据公式：数据量=（采样频率×采样位数×声道数×时间）/8<br>得，数据量(MB)=[44.1×1000×16×2×（5×60）] /（8×1024×1024）=50.47MB<br>计算时要注意几个单位的换算细节：<br>时间单位换算：1分=60秒<br>采样频率单位换算：1kHz=1000Hz<br>数据量单位换算：1MB=1024×1024=1048576B</p><p>【例2】请计算对于双声道立体声、采样频率为44.1kHz、采样位数为16位的激光唱盘（CD-A），用一个650MB的CD-ROM可存放多长时间的音乐？<br>已知音频文件大小的计算公式如下：<br>文件的字节数/每秒=采样频率（Hz）X采样位数（位）X声道数/8<br>根据上面的公式计算一秒钟时间内的不压缩数据量：(44.1×1000×16×2)/8=0.168MB/s<br>那么，一个650MB的CD-ROM可存放的时间为：（650/0.168）/（60×60）=1.07小时。</p><hr><p>##IOS 音频转码 ##</p><p>音频转码使用的框架为：AudioToolBox</p><p>###内存转码： ###<br>    使用函数： AudioConverterFillComplexBuffer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">    - (void)handleAudioPackets:(const void *)inputData</span><br><span class="line">             numberOfBytes:(UInt32)numberOfBytes</span><br><span class="line">           numberOfPackets:(UInt32)numberOfPackets</span><br><span class="line">        packetDescriptions:(AudioStreamPacketDescription *)packetDescriptions</span><br><span class="line">&#123;</span><br><span class="line">    if (!_audioFileStream || !_parseAudioHeader || !_decodeConverterRef) return;</span><br><span class="line">    </span><br><span class="line">    AudioConvertInfo convertInfo = (AudioConvertInfo)&#123;</span><br><span class="line">        .done = NO,</span><br><span class="line">        .numberOfPackets = numberOfPackets,</span><br><span class="line">        .packetDescriptions = packetDescriptions,</span><br><span class="line">        .audioBuffer = (AudioBuffer)&#123;</span><br><span class="line">            .mData = (void *)inputData,</span><br><span class="line">            .mDataByteSize = numberOfBytes,</span><br><span class="line">            .mNumberChannels = _sourceAsbd.mChannelsPerFrame</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    AudioBufferList decodedData;</span><br><span class="line">    decodedData.mNumberBuffers = 1;</span><br><span class="line">    decodedData.mBuffers[0].mNumberChannels = _canonicalAsbd.mChannelsPerFrame;</span><br><span class="line">    decodedData.mBuffers[0].mDataByteSize = _decodeBufferSize;</span><br><span class="line">    decodedData.mBuffers[0].mData = _decodeBuffer;</span><br><span class="line">    </span><br><span class="line">    UInt32 ioOutputDataPackets1, ioOutputDataPackets2;</span><br><span class="line">    OSStatus decodingStatus, encodingStatus;</span><br><span class="line">    </span><br><span class="line">    while (1)</span><br><span class="line">    &#123;</span><br><span class="line">        ioOutputDataPackets1 = numberOfPackets;</span><br><span class="line">        </span><br><span class="line">        decodingStatus = AudioConverterFillComplexBuffer(_decodeConverterRef, AudioConverterCallback, (void*)&amp;convertInfo, &amp;ioOutputDataPackets1, &amp;decodedData, NULL);</span><br><span class="line">        </span><br><span class="line">        if (decodingStatus == OS_STATUS_DONE || decodingStatus == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            if (ioOutputDataPackets1 &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                // Start encoding</span><br><span class="line">                </span><br><span class="line">                AudioConvertInfo encodeConvertInfo = (AudioConvertInfo)&#123;</span><br><span class="line">                    .done = NO,</span><br><span class="line">                    .numberOfPackets = ioOutputDataPackets1,</span><br><span class="line">                    .packetDescriptions = NULL,</span><br><span class="line">                    .audioBuffer = (AudioBuffer)&#123;</span><br><span class="line">                        .mData = decodedData.mBuffers[0].mData,</span><br><span class="line">                        .mDataByteSize = decodedData.mBuffers[0].mDataByteSize,</span><br><span class="line">                        .mNumberChannels = _canonicalAsbd.mChannelsPerFrame</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                </span><br><span class="line">                AudioBufferList encodedData;</span><br><span class="line">                encodedData.mNumberBuffers = 1;</span><br><span class="line">                encodedData.mBuffers[0].mNumberChannels = _destinationAsbd.mChannelsPerFrame;</span><br><span class="line">                encodedData.mBuffers[0].mDataByteSize = _encodeBufferSize;</span><br><span class="line">                encodedData.mBuffers[0].mData = _encodeBuffer;</span><br><span class="line">                </span><br><span class="line">                while (1)</span><br><span class="line">                &#123;</span><br><span class="line">                    ioOutputDataPackets2 = _encodePacketsPerBuffer;</span><br><span class="line">                    </span><br><span class="line">                    encodingStatus = AudioConverterFillComplexBuffer(_encodeConverterRef, AudioConverterCallback, (void*)&amp;encodeConvertInfo, &amp;ioOutputDataPackets2, &amp;encodedData, _encodePacketDescriptions);</span><br><span class="line">                    </span><br><span class="line">                    if (encodingStatus == OS_STATUS_DONE || encodingStatus == 0)</span><br><span class="line">                    &#123;</span><br><span class="line">                        //一个buffer 转码成功</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        [self failureOccurred];</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    if (encodingStatus == OS_STATUS_DONE)</span><br><span class="line">                    &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // End encoding</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [self failureOccurred];</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (decodingStatus == OS_STATUS_DONE)</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="文件转码"><a href="#文件转码" class="headerlink" title="文件转码"></a>文件转码</h3><pre><code>使用函数 ExtAudioFileRead</code></pre><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> startConvert(ExtAudioConverterSettings* settings)&#123;</span><br><span class="line">    <span class="comment">//Determine the proper buffer size and calculate number of packets per buffer</span></span><br><span class="line">    <span class="comment">//for CBR and VBR format</span></span><br><span class="line">    <span class="built_in">UInt32</span> sizePerBuffer = <span class="number">32</span>*<span class="number">1024</span>;<span class="comment">//32KB is a good starting point</span></span><br><span class="line">    <span class="built_in">UInt32</span> framesPerBuffer = sizePerBuffer/<span class="keyword">sizeof</span>(SInt16);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// allocate destination buffer</span></span><br><span class="line">    SInt16 *outputBuffer = (SInt16 *)malloc(<span class="keyword">sizeof</span>(SInt16) * sizePerBuffer);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        AudioBufferList outputBufferList;</span><br><span class="line">        outputBufferList.mNumberBuffers              = <span class="number">1</span>;</span><br><span class="line">        outputBufferList.mBuffers[<span class="number">0</span>].mNumberChannels = settings-&gt;outputFormat.mChannelsPerFrame;</span><br><span class="line">        outputBufferList.mBuffers[<span class="number">0</span>].mDataByteSize   = sizePerBuffer;</span><br><span class="line">        outputBufferList.mBuffers[<span class="number">0</span>].mData           = outputBuffer;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UInt32</span> framesCount = framesPerBuffer;</span><br><span class="line">        </span><br><span class="line">        CheckError(ExtAudioFileRead(settings-&gt;inputFile,</span><br><span class="line">                                    &amp;framesCount,</span><br><span class="line">                                    &amp;outputBufferList),</span><br><span class="line">                   <span class="string">"ExtAudioFileRead failed"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (framesCount==<span class="number">0</span>) &#123;</span><br><span class="line">            printf(<span class="string">"Done reading from input file\n"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        CheckError(ExtAudioFileWrite(settings-&gt;outputFile,</span><br><span class="line">                                     framesCount,</span><br><span class="line">                                     &amp;outputBufferList),</span><br><span class="line">                   <span class="string">"ExtAudioFileWrite failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a><a href="http://download.csdn.net/download/qihongru1227/9326777" target="_blank" rel="noopener">代码下载</a></h3><h2 id="外部链接"><a href="#外部链接" class="headerlink" title="外部链接"></a>外部链接</h2><p><a href="https://developer.apple.com/library/ios/documentation/MusicAudio/Conceptual/CoreAudioOverview/SupportedAudioFormatsMacOSX/SupportedAudioFormatsMacOSX.html" target="_blank" rel="noopener">苹果官网</a></p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;iOS-音频开发&quot;&gt;&lt;a href=&quot;#iOS-音频开发&quot; class=&quot;headerlink&quot; title=&quot;iOS 音频开发&quot;&gt;&lt;/a&gt;iOS 音频开发&lt;/h1&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;音频基础知识&lt;/li&gt;
&lt;li&gt;音频文件计算大小&lt;/li&gt;
&lt;li&gt;音
      
    
    </summary>
    
      <category term="iOS" scheme="https://hongruqi.github.io/categories/iOS/"/>
    
    
  </entry>
  
</feed>
